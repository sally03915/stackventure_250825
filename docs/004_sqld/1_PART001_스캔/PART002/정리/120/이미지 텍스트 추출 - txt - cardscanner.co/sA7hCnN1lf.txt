
제3장. SQL 최적화 기본 원리
128. CBO, 비용기반 옵티마이저, Cost Based Optimizer
129. 4
해설: 실행계획은 예상 정보이다. 실제 처리 건수는 트레이스 정보를 통해서 알 수 있다.
130,
3, 4, 2
해설: 실행계획을 읽는 순서는 위에서 아래로, 안에서 밖으로 읽는다.
131, 3
그러므로 3→4→2→6→5→ 1 순으로 수행된다.
해설 : 실행계획 즉, 실행방법이 달라진다고 해서 결과가 달라지지는 않는다.
132, 2, 4
해설: SQL 처리 흐름도는 SQL 실행계획을 시각화해서 표현한 것이다. SQL 처리 흐름도만 보고 실행 시간을 알 수는 없다.
133. 1, 4
해설: 규칙기반 옵티마이저에서 제일 낮은 우선순위는 전체 테이블 스캔이고, 제일 높은 우선순위는 ROWID 를 활용하여 테이블을 액세스하는 방법이다.
134. 2
SQL 처리 흐름도는 SQL문의 처리 절차를 시각적으로 표현한 것으로, 인덱스 스캔 및 전체 테이블 스캔 등의 액세스 기법을 표현할 수 있으며, 성능적인 측면도 표현할 수 있다.
인덱스 범위 스캔은 결과 건수만큼 반환하지만, 결과가 없으면 한 건도 반환하지 않을 수 있다.
해설: 기본 인덱스(Primary Key)는 UNIQUE & NOT NULL의 제약조건을 가진다.
135, 2, 4
보조 인덱스는 UNIQUE 인덱스가 아니라면 중복 데이터의 입력 가능하며, 자주 변경되는 속성을 인덱스로 선정할 경우 UPDATE, DELETE 성능에 좋지 않은 영향을 미치므로 인덱스 후보로 적절하지 않다.
해설: 테이블의 전체 데이터를 읽는 경우는 인덱스를 사용하지 않는 FTS를 사용한다.
인덱스는 조회만을 위한 오브젝트이며, 삽입, 삭제, 갱신의 경우 오히려 부하를 가중한다. Balance Tree는 관계형 데이터베이스에서 가장 많이 사용되는 인덱스이다.
인덱스가 존재하는 상황에서 데이터를 입력하면, 매번 인덱스 정렬이 일어나므로 데이터 마이그레이 션 같이 대량의 데이터를 삽입할 때는 모든 인덱스를 제거하고, 데이터 삽입이 끝난 후에 인덱스를 다시 생성하는 것이 좋다.