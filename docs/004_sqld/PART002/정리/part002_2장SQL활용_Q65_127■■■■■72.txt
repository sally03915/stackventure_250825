*065  다음 중 순수 관계 연산자에 해당하지 않는 것은?
1 SELECT
2 UPDATE
3 JOIN
4 DIVIDE




*066 다음 중 아래 데이터 모델을 참고하여 설명에 맞게 올바르게 작성한
SQL 문장을 2개 고르시오.

_________________________  아래   _________________________

[데이터 모델]

그림

설명]
우리는 매일 배치작업을 통하여 고객에게 추천할 컨텐츠를 생성하고 고객에게 추천서비스를 제공한다.
추천 컨텐츠 엔터티에서 언제 추천을 해야 하는지를 정의하는 추천 대상일자가 있어 해당일에만 컨텐츠를 추천해야 한다. 또한 고객 이 컨텐츠를 추천 받았을 때 선호하는 컨텐츠가 아닌 경우에는 고객 이 비선호 컨텐츠로 분류하여 더 이상 추천 받기를 원하지 않는다. 그러므로 우리는 비선호 컨텐츠 엔터티에 등록된 데이터에 대해서는 추천을 수행하지 않아야 한다.

※ 배치작업이란? 어떤 처리를 연속적으로 하는 것이 아니고 일정량 나누어 처리하는 경우 그 일정량을 배치(batch)라고 한다. 배치의 원뜻은 한 묶음이라는 의미다.
[기계공학용어사전] 예) 상품을 주문하는 로직은 그당시에 발생하는 트랜잭션에 대한 처리이므로 배치작업이라 표현하지는 않는다. 하지만 상품별 주 문량을 집계하는 로직의 경우 특정조건(기간등)으로 일괄처리를 해야함으로 배치작업이라 표현할 수 있다.


__________________________________________________________


1     SELECT C. 컨텐츠ID, C. 컨텐츠
FROM 고객 A INNER JOIN 추천컨텐츠 B
ON (A. 고객ID= B. 고객ID) INNER JOIN 컨텐츠 C
ON  (B.ID = C.ID)
WHERE A.고객ID = #custId#
AND  B.추천대상일자 =  TO CHAR(SYSDATE, YYYYMMDD)
AND  NOT EXISTS (SELECT X, 콘텐츠ID FROM 비선호컨텐츠 X  WHERE X.고객ID = B.고객ID);


2      SELECT C.컨텐츠ID, C.컨텐츠명
FROM 고객 A INNER JOIN 추천컨텐츠 B
ON (A.고객ID  = #custId# AND A.고객ID = B.고객ID) INNER JOIN HE C
ON (B.컨텐츠ID= C.컨텐츠ID) RIGHT OUTER JOIN 비선호컨텐츠 D
ON (B.고객ID  = D.고객ID AND B.컨텐츠ID = D.컨텐츠ID)
WHERE B.추천대상일자 = TO_CHAR(SYSDATE, 'YYYY.MM.DD')
AND B.콘텐츠ID IS NOT NULL;


3       SELECT C.컨텐츠ID, C.컨텐츠명
FROM 고객 A INNER JOIN 추천컨텐츠 B
ON (A.고객ID= B.고객ID) INNER JOIN 컨텐츠 C
ON (B.컨텐츠ID =C.컨텐츠ID) LEFT OUTER JOIN 비선호컨텐츠 D
ON (B.고객ID  = D.고객ID AND B.컨텐츠ID = D.컨텐츠ID)
WHERE AID = #custId#
AND  B.추천대상일자 = TO_CHAR(SYSDATE, 'YYYY.MM.DD')
AND  D.콘텐츠ID IS NOT NULL;

4      SELECT C.컨텐츠ID, C.컨텐츠명
FROM 고객 A INNER JOIN 추천컨텐츠 B
ON (A.고객ID=#custId# AND A 고객ID=B.고객ID) INNER JOIN 컨텐츠 C
ON (B.컨텐츠ID=C.컨텐츠ID)
WHERE B.추천대상일자 = TO_CHAR(SYSDATE, 'YYYY.MM.DD')
AND NOT EXISTS (SELECT X.콘텐츠ID
                FROM 비선호컨텐츠 X
                 WHERE X.고객ID =  B.고객ID
                 AND   X.콘텐츠ID= B.콘텐츠ID);



*067 아래는 어느 회사의 생산설비를 위한 데이터 모델의 일부에 대한 설명으로
가장 적절한 것을 2개 고르시오.

_________________________  아래   _________________________

[그림]
__________________________________________________________

1 제품 생산제품 생산라인 엔터티를 Inner Join 하기 위해서 생산제품 엔터티는 WHERE절에 최소 2번이 나타나야 한다.
2 제품과 생산라인 엔터티를 Join 시 적절한 Join 조건이 없으므로 카티시 안 곱(Cartesian Product)이 발생한다.
3 제품과 생산라인 엔터티에는 생산제품과 대응되지 않는 레코드는 없다.
4 특정 생산라인번호에서 생산되는 제품의 제품명을 알기위해서는 제품 생산제품, 생산라인까지 3개 엔터티의 Inner Join인 필요하다.



*068  아래의 테이블 스키마 정보를 참고하여 다음 중 구매 이력이 있는 고객 중
구매 횟수가 3회 이상인 고객의 이름과 등급을 출력하시오.'라는 질의에 대해
아래 SQL 문장의 [ㄱ] , [ㄴ] 에 들어 갈 구문으로 가장 적절한 것은?

_________________________  아래   _________________________
[테이블]
고객(고객번호(PK), 이름, 등급)
구매정보(구매번호(PK), 구매금액, 고객번호(FK))
* 구매정보 테이블의 고객번호는 고객 테이블의 고객번호를 참조하
는 외래키(Foreign Key)이다.

[SQL 문장]
SELECT A. 이름, A. 등급
FROM 고객 A
[ㄱ]
GROUP BY A.이름, A.등급
[ㄴ]
__________________________________________________________


1   [ㄱ]  : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호
    [ㄴ]  : HAVING SUM(B.구매번호) >=3

2   [ㄱ]  : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호
    [ㄴ]  : HAVING COUNT(B.구매번호) >=3

3   [ㄱ]  : LEFT OUTER JOIN 구매정보 B  ON A.고객번호=B.고객번호
    [ㄴ]  : HAVING SUM(B.구매번호)>=3

4   [ㄱ]  : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호
    [ㄴ]  : WHERE B.구매번호>=3





*069  아래는 어느 회사의 정산 데이터 모델의 일부이며 고객이 서비스를 사용한
시간대에 따라 차등 단가를 적용하려고 한다. 다음 중 시간대별사용량 테이블을 기반으로
고객별 사용금액을 추출하는 SQL으로 가장 적절한 것은?

_________________________  아래   _________________________

[그림]
__________________________________________________________

1    SELECT A.고객ID, A. 고객명, SUM(B.사용량 * C.단가) AS 사용금액
FROM 고객 A  INNER JOIN 시간대별사용량 B
ON   (A.고객ID = B.고객ID) INNER JOIN 시간대구간 C
ON   (B.사용시간대 <= C.시작시간대 AND B.사용시간대 >= C.종료시간대)
GROUP BY A.고객ID, A.고객명
ORDER BY A.고객ID, A.고객명:

2    SELECT A.고객ID, A.고객명, SUM(B.사용량 * C.단가) AS 사용금액
FROM 고객 A INNER JOIN 시간대별사용량 B INNER JOIN 시간대구간 C
ON   (A.고객ID= B.고객ID   AND B.사용시간대
     BETWEEN C.시작시간대 AND C.종료시간대 )
GROUP BY A.고객ID, A.고객명
ORDER BY A.고객ID, A.고객명:


3      SELECT A.고객ID, A.고객명, SUM(B.사용량 * C.단가) AS 사용금액
FROM 고객 A INNER JOIN 시간대별사용량 B
ON    (A.고객ID= B.고객ID) INNER JOIN 시간대구간 C
ON     B.사용시간대 BETWEEN C.시작시간대 AND C.종료시간대
GROUP BY A.고객ID, A.고객명
ORDER BY A.고객ID, A.고객명:

4      SELECT A.고객ID, A.고객명, SUM(B.사용량 * C.단가) AS 사용금액
FROM 고객 A INNER JOIN 시간대별사용량 B
ON (A.고객ID=B.고객ID) BETWEEN JOIN 시간대구간 C
GROUP BY A.고객ID, A.고객명
ORDER BY A.고객ID, A.고객명:




*070  다음 중 팀(TEAM) 테이블과 구장(STADIUM) 테이블의 관계를 이용해
서 소속팀이 가지고 있는 전용구장의 정보를 팀의 정보와 함께 출력하는
SQL을 작성할 때 결과가 다른 것은?

1   SELECT T, REGION_NAME, T. TEAM_NAME, T.STADIUM_ID,
S. STADIUM_NAME
FROM
TEAM T INNER JOIN STADIUM S
USING (T.STADIUM_ID = S.STADIUM_ID);

2   SELECT TEAM, REGION_NAME, TEAM, TEAM_NAME, TEAM, STADIUM_ID, STADIUM, STADIUM_NAME
FROM TEAM INNER JOIN STADIUM
ON (TEAM, STADIUM_ID = STADIUM, STADIUM_ID);


3    SELECT TREGION_NAME, T, TEAM_NAME, T.STADIUM_ID, S. STADIUM NAME
FROM   TEAM T, STADIUM S
WHERE T.STADIUM_ID = S.STADIUM_ID;

4    SELECT TEAM, REGION_NAME, TEAM TEAM NAME, TEAM, STADIUM ID, STADIUM, STADIUM_NAME
FROM TEAM, STADIUM
WHERE TEAM.STADIUM_ID= STADIUM.STADIUM ID:









*071  아래의 사례1은 Cartesian Product를 만들기 위한 SQL 문장이며
사례 1과 같은 결과를 얻기 위해 사례2 SQL 문장의[ㄱ] 안에 들어갈 내용을 작성하시오.

_________________________  아래   _________________________

[사례1]
SELECT ENAME, DNAME
FROM EMP, DEPT
ORDER BY ENAME;

[사례2]
SELECT ENAME, DNAME
FROM EMP   [ㄱ]   DEPT
ORDER BY ENAME;
__________________________________________________________



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

*072  다음 중 아래 테이블들을 대상으로 SQL 문장을 수행한 결과로 가장 적절한 것은?
_________________________  아래   _________________________


__________________________________________________________
[테이블: OS]
OSID(PK)
OS명
100
200
Android
iOS
300
Bada
[테이블: 단말기]
단말기[D(PK)
단말기명
OSID(FK)
1000
A1000
100
2000
B2000
100
3000
C3000
200
4000
D3000
300
[테이블: 고객]
고객번호(PK)
고객명
단말기ID(PK)
11000
홍길동
1000
12000
강감찬
NULL
13000
이순신
NULL
14000
안중근
3000
15000
고길동
4000
16000
이대로
4000
[SQL]
SELECT A. 고객번호, A. 고객명, B. 단말기ID, B. 단말기명, C.OSID,
COS명
FROM
ON
ON
고객 A LEFT OUTER JOIN 단말기 B
(A. 고객번호 IN (11000, 12000) AND A. 단말기ID=
B. 단말기ID) LEFT OUTER JOIN OS C
(B,OSIDC,OSID)
ORDER BY A. 고객번호:
1 고객번호
고객명단말기ID 단말기명
OSID
OS명
11000
홍길동
1000
A1000
100 Android
12000
강감찬 NULL
NULL
NULL NULL
13000
이순신
NULL
NULL
NULL
NULL
14000
안중근
NULL
NULL
NULL
NULL
15000
고길동
NULL
NULL
NULL
NULL
16000
NULL 이대로
NULL
NULL NULL
2 고객번호
고객명 단말기ID 단말기명
OSID
OS명
11000
홍길동
1000
A1000
100 Android
12000
강감찬
NULL
NULL
NULL
NULL





*073

73
3 고객번호
고객명
단말기ID
11000
홍길동
1000
단말기명 A1000
4 고객번호
고객명
단말기ID 단말기명
OS명
OSID 100 Android
OSID
OS명
11000
홍길동
1000
A1000
100
Android
12000
강감찬
NULL
NULL
NULL
NULL
13000
이순신
NULL
NULL
NULL
NULL
14000
안중근
3000
C3000
200
iOS
15000
고길동
4000
D4000
300
Bada
16000
이대로
4000 D4000
300
Bada
다음 중 아래 (1),(2),(3)의 SQL에서 실행결과가 같은 것은?
_________________________  아래   _________________________


__________________________________________________________
(1) SELECT A.ID, B.ID
FROM TBL1 A FULL OUTER JOIN TBL2 B
ON A, ID = B.ID
(2) SELECT A.ID, B.ID
FROM TBL1 A LEFT OUTER JOIN TBL2 B
ON A.ID = B.ID
UNION
SELECT A.ID, B.ID
FROM TBL1 A RIGHT OUTER JOIN TBL2 B
ON A.ID = B.ID
(3) SELECT A.ID, B.ID
FROM TBL1 A, TBL2 B
WHERE A.ID = B.ID
UNION ALL
SELECT A.ID, NULL
FROM TBL1 A
WHERE NOT EXISTS (SELECT 1 FROM TBL2 B WHERE A.ID = B.ID) UNION ALL
SELECT NULL, B.ID
FROM TBL2 B
WHERE NOT EXISTS (SELECT 1 FROM TBL1 A WHERE B.ID = A,ID)
11, 2 2 1, 3
3 2, 3
1, 2, 3




*074
74
아래의 EMP 테이블과 DEPT 테이블에서 밑줄 친 속성은 주키이며 EMP.C는 DEPT와 연결된 외래키이다. EMP 테이블과 DEPT 테이블을 LEFT, FULL RIGHT 외부조인(outer join)하면 생성되는 결과 건수로 가장 적절한 것은?
75
EMP 테이블
_________________________  아래   _________________________


__________________________________________________________
A
B
C
1
b
3
d
W
W
5
У
У
DEPT 테이블
C
D
E
W
1
10
Z
4
11
V
2
22
1 3건, 5건, 4건
2 4건, 5건, 3건
3 3건, 4건, 4건
4 3건, 4건, 5건





*075
신규 부서의 경우 일시적으로 사원이 없는 경우도 있다고 가정하고 DEPT와 EMP를 조인하되 사원이 없는 부서 정보도 같이 출력하도록 안에 들어갈 내용을 기술하시오. 할 때, 아래 SQL 문장의 ᄀ
_________________________  아래   _________________________


__________________________________________________________
SELECT E. ENAME, D. DEPTNO, D.DNAME
FROM
ON
DEPT D
EMP E
D_DEPTNO=E_DEPTNO:





*076

76
다음 중 아래와 같은 데이터 상황에서 SQL의 수행 결과로 가장 적절한 것은?
_________________________  아래   _________________________


__________________________________________________________
TAB1
of 2H
TAB2
C1
C2
C2
C1
B
2
1
A
C
3
2
B
D
4
3
C
4
D
5
E
SELECT *
FROM TAB1 A LEFT OUTER JOIN TAB2 B ON (A,C1 = B. C1 AND B. C2 BETWEEN 1 AND 3)
C1
C2
C1
02
A
1
B
2
B
2
C
3
C
3
D
4
D
4
E
5
C1
C2
C1
C2
A
1
Y SHAT
B
2
B
2
C
3
C
3
D
4
E
5
C1
C2
C1
C2
A
1
B
2
B
2
C
3
C
3
(4)
C1
C2
C1
C2
A
1
B
2
B
2
C
3
C
3
D
4
D
4




*077

77
아래와 같은 데이터 모델에서 ORACLE을 기준으로 SQL을 작성하였다. 그러나 SQL Server에서도 동일한 결과를 보장할 수 있도록 ANSI 구문 으로 SQL을 변경하려고 한다. 다음 중 아래의 SQL을 ANSI 표준 구문 으로 변경한 것으로 가장 적절한 것은?
_________________________  아래   _________________________


__________________________________________________________
게시판
게시글
게시판ID
게시판명
등록일시 사용여부
게시글ID
게시판ID (FK)
제목
내용 등록일시
등록자명
삭제여부
[SQL]
SELECT A. 게시판ID, A. 게시판명, COUNT(B. 게시글ID) AS CNT
FROM 게시판 A, 게시글 B
WHERE A. 게시판ID= B. 게시판ID(+)
AND
AND
B. 삭제여부(+)'N'
A. 사용여부=Y
GROUP BY A 게시판ID, A. 게시판명
ORDER BY A. 게시판ID:
1 SELECT A 게시판ID, A. 게시판명, COUNT(B. 게시글ID) AS CNT
FROM 게시판 A LEFT OUTER JOIN 게시글 B
ON (A. 게시판ID= B. 게시판ID AND B. 삭제여부= 'N') WHERE A. 사용여부 = 'Y
GROUP BY A. 게시판ID, A. 게시판명
ORDER BY A 게시판ID:
2 SELECT A. 게시판ID, A. 게시판명, COUNT(B. 게시글ID) AS CNT
FROM 게시판 A LEFT OUTER JOIN 게시글 B
ON (A 게시판ID= B. 게시판ID AND A 사용여부 Y)
WHERE B. 삭제여부= 'N'
GROUP BY A. 게시판ID, A. 게시판명
ORDER BY A 게시판ID:
=
9 SELECT A. 게시판ID. A. 게시판명, COUNT(B. 게시글ID) AS CNT
FROM 게시판 A LEFT OUTER JOIN 게시글 B
ON (A. 게시판ID=B. 게시판ID)
WHERE A. 사용여부 = 'Y'
AND B. 삭제여부
= 'N'
GROUP BY A. 게시판ID, A. 게시판명 ORDER BY A. 게시판ID;
87




*078

@SELECT A, D, A, A, COUNT(B.ID) AS CNT
FROM A RIGHT OUTER JOIN B
ON
(A. 게시판ID=B. 게시판ID AND A. 사용여부.
=
'N') B. 삭제여부
GROUP BY A. 게시판ID, A. 게시판명
'Y' AND
ORDER BY A.HD:

78
다음과 같은 2개의 릴레이션이 있다고 가정하자. student의 기본키는 st_num이고, department의 기본키는 dept_nurn이다. 또한 student의 d_num은 department의 dept_num을 참조하는 외래키이다. 아래
SQL문의 실행 결과 건수는?
SELECT count(st_name)
FROM student s
WHERE not exists
(SELECT *
FROM department d
WHERE s.d_num
and dept_name
of 2H
=
d. dept_num '전자계산학과');
Student
st_num
st_name
d_num
dept_num
Department
dept_name
1001
Yoo
10
10
컴퓨터공학과
1002
Kin
30
20
원자력공학과
1003
Lee
20
30
전자계산학과
1004
Park
10
1005
Choi
20
1006
Jeong
10




*079
79
(SQL Server) 다음 중 아래의 SQL과 동일한 결과를 추출하는 SQL은? (단, 테이블 TAB1, TAB2의 PK 컬럼은 A, B 이다)
_________________________  아래   _________________________


__________________________________________________________
[SQL]
SELECT A, B
FROM TAB1
EXCEPT
SELECT A, B
FROM TAB2;
SELECT TAB2, A, TAB2, B
FROM TAB1, TAB2
WHERE TAB1, A
AND TAB1,B
TAB2, A
TAB2, B
FROM
TAB1
2 SELECT TAB1, A, TAB1,B
WHERE TAB1, A NOT IN (SELECT TAB2, A
AND
FROM TAB2) TAB1, B NOT IN (SELECT TAB2,B FROM TAB2);
3 SELECT TAB2, A, TAB2, B
FROM TAB1, TAB2
WHERE TAB1, A
=
TAB2, A
AND TAB1, B = TAB2,B
4 SELECT TAB1, A, TAB1, B
FROM TAB1
WHERE NOT EXISTS (SELECT 'X'
FROM TAB2
WHERE TAB1, A
=
TAB2 A
AND TAB1 B
=
TAB2 B);





*080
80
SQL과 동일한 결과를 도출하는 SQL은?
아래와 같은 데이터 모델에 대해 SQL을 수행 하였다. 다음 중 수행된
_________________________  아래   _________________________


__________________________________________________________
서비스
서비스 ID
서비스이용
회원
회원ID (FK) 서비스 ID (FK)
회원ID
+
회원명
서비스명
이용일시
서비스URL
[수행 SQL]
SELECT A. 서비스ID, B. 서비스명, B. 서비스URL
FROM (SELECT 서비스ID
FROM 서비스
INTERSECT
SELECT AID
FROM 서비스이용) A, 서비스 B
WHERE A 서비스ID = B. 서비스ID:
1 SELECT B. 서비스ID, A. 서비스명, A. 서비스URL
FROM 서비스 A, 서비스이용 B
WHERE A. 서비스ID= B. 서비스ID:
2 SELECT X 서비스ID, X. 서비스명, X. 서비스URL
FROM 서비스 X
WHERE NOT EXISTS (SELECT 1
FROM (SELECT AHAID
FROM 서비스
MINUS
SELECT 서비스ID
FROM 서비스이용) Y
WHERE X.서비스ID=Y. 서비스ID);
1 SELECT B. 서비스ID, A. 서비스명. A. 서비스URL
FROM 서비스 A LEFT OUTER JOIN 서비스이용 B ON (A. 서비스ID= B. 서비스ID)
WHERE B. 서비스ID IS NULL
GROUP BY B. 서비스ID. A. 서비스명. A. 서비스URL:
4 SELECT A. 서비스ID. A. 서비스명, A. 서비스URL
FROM 서비스 A
WHERE 서비스ID IN (SELECT 서비스ID
FROM
서비스이용
MINUS
SELECT 서비스D
FROM 서비스):







*081
81
SET OPERATOR 중에서 수학의 교집합과 같은 기능을 하는 연산자로 가장 적절한 것은?
82
(1) UNION
2 INTERSECT
3 MINUS
EXCEPT
다음 중 아래의 EMP 테이블의 데이터를 참조하여 실행한 SQL의 결과로 가장 적절한 것은?
_________________________  아래   _________________________


__________________________________________________________
SELECT ENAME AAA, JOB AAB
FROM EMP
WHERE EMPNO = 7369
UNION ALL
SELECT ENAME BBA, JOB BBB
FROM EMP
WHERE EMPNO = 7566
ORDER BY 1, 2;
EMP
EMPNO ENAME
JOB MGR HIREDATE SAL COMM DEPTNO
7369 SMITH 7499 ALLEN
CLERK
7902 1980-12-17
800 SALESMAN 7698 1981-02-20 1600 300
20
30
7521 WARD 7566 JONES 7654 MARTIN 7698 BLAKE 7782 CLARK 7788 SCOTT 7839 KING 7844 TURNER 7876 ADAMS
7839
SALESMAN 7698 1981-02-22 1250 500 MANAGER SALESMAN MANAGER MANAGER ANALYST PRESIDENT SALESMAN 7698
30
1981-04-02 2975
20
7698 1981-09-28 1250 1400
30
7839 1981-05-01 2850
30
7839 1981-06-09 2450
10
7566 1987-07-13 3000
20
1981-11-17 5000
10
1981-09-08 1500
0
30
CLERK
7900 JAMES
CLERK
7902 FORD 7934 MILLER
ANALYST CLERK
7788 1987-07-13 1100 7698 1981-12-03 950 7566 1981-12-03 3000 7782 1982-01-23
20
30
20
1300
10
1 AAA
AAB
AAA
AAB
SMITH
CLERK
MANAG
JONES
MANAG
ER
JONES
ER
SMITH
CLERK
3
BBA
BBB
(4)
BBA
BBB
SMITH
CLERK
MANAG
JONES
MANAG
ER
JONES
ER
SMITH
CLERK




*082





*083
83
다음 중 아래 TBL1, TBL2 테이블에 대해 SQL을 수행한 결과인 것은?
_________________________  아래   _________________________


__________________________________________________________
[테이블: TBL1]
[테이블: TBL2]
COL1
COL2
COL1
COL2
A1
AA
A1
AA
AB
A2
AB
A2
AC
A3
AD
A4
[SQL)
SELECT COL1, COL2, COUNT(*) AS CNT
FROM (SELECT COL1, COL2
FROM TBL1
UNION ALL
SELECT COL1, COL2
FROM TBL2
UNION
SELECT COL1, COL2
FROM TBL1)
GROUP BY COL1, COL2;
1
COL1
COL2
CNT
AA
A1
1
AB
A2
1
AC
A3
1
BORO
AD
A4
1
2
COL1
COL2
CNT
AA
A1
2
AB
A2
2
AC
A3
1
AD
A4
1
COL1
COL2
CNT
AA
Al
3
AB
A2
3
AC
A3
1
AD
A4
1
COL1
COL2
CNT
AA
Al
3
AB
A2
3
AC
A3
2
AD
A4
2





*084
84
다음 중 아래에서 테이블 T1, T2에 대한 가, 나 두 개의 쿼리 결과 조회되는 행의 수로 가장 적절한 것은?
_________________________  아래   _________________________


__________________________________________________________
85
T1(A,B,C)
T2(A,B,C)
A
B
C
A
B
C
A3
B2
C3
Al
B1
C1
A1
B1
C1
A3
B2
C3
A2
B1
C2
가. SELECT A, B, C FROM RI
UNION ALL
SELECT A, B, C FROM R2
나. SELECT A, B, C FROM RI UNION
SELECT A, B, C FROM R2
1가: 5개, 나: 3개
2 가 5개, 나: 5개
3가: 3개, 나: 3개
4가: 3개, 나: 5개
다음 중 아래와 같은 집합이 존재 할 때, 집합 A와 B에 대하여 집합연산을 수행한 결과 집합 C가 되는 경우 이용되는 데이터베이스 집합연산은?
집합 A= 가, 나, 다, 라, 집합 B= 다. 라, 마, 배, 집합 C = 다.
1 Union
(2) Difference
3 Intersection
4 Product
아래





*085





*086
86
아래와 같은 데이터 모델에 대한 설명으로 가장 적절한 것은?
임을 보장한다.)
(단, 시스템적으로 회원기본정보와 회원상세정보는 1:1. 양쪽 필수 관계
_________________________  아래   _________________________


__________________________________________________________
[데이터 모델]
회원 기본정보
회원상세정보
회원ID
회원ID (FK)
1
1 회원ID 컬럼을 대상으로 (회원기본정보 EXCEPT 회원상세정보) 연산을
수행하면 회원상세정보가 등록되지 않은 회원ID가 추출된다. 3 회원ID 컬럼을 대상으로 (회원기본정보 UNION ALL 회원상세정보) 연산을 수행한 결과의 건수는 회원기본정보의 전체건수와 동일하다. 3 회원ID 컬럼을 대상으로 (회원기본정보 INTERSECT 회원상세정보 연산을 수행한 결과의 건수와 두 테이블을 회원ID로 JOIN 연산을 수행한 결과의 건수는 동일하다.
4 회원ID 컬럼을 대상으로 (회원기본정보 INTERSECT 회원상세정보 연산을 수행한 결과와 (회원기본정보 UNION 회원상세정보) 연산을 수행한 결과는 다르다.






*087  87
아래와 같은 데이터 상황에서 아래의 SQL을 수행할 경우 정렬 순서상 2번째 표시될 값을 적으시오.

_________________________  아래   _________________________


__________________________________________________________
TAB1
C1
C2
C3
1
A
2
1
B
3
1
C
4
2
D
SELECT C3
FROM TAB1
START WITH C2 IS NULL
CONNECT BY PRIOR C1 = C2
ORDER SIBLINGS BY C3 DESC





*088
88
다음 중 Oracle 계층형 질의에 대한 설명으로 가장 부적절한 것은?
i START WITH절은 계층 구조의 시작점을 지정하는 구문이다. 2 ORDER SIBLINGS BY절은 형제 노드 사이에서 정렬을 지정하는 구문이다. 3 순방향전개란 부모 노드로부터 자식 노드 방향으로 전개하는 것을 말한다. 1 루트 노트의 LEVEL 같은 0이다.






*089
89
다음 중 아래와 같은 사원 테이블에 대해서 SQL을 수행하였을 때의 결과로 가장 적절한 것은?

_________________________  아래   _________________________


__________________________________________________________
[테이블: 사원]
사원번호(PK)
사원명
입사일자 매니저사원번호(FK)
001
홍길동
2012-01-01
NULL
002
강감찬
2012-01-01
001
003
이순신
2013-01-01
001
004
이민정
2013-01-01
001
005
이병헌
2013-01-01
NULL
006
안성기
2014-01-01
005
007
008
이수근 김병만
2014-01-01
005
2014-01-01
005
[SQL]
SELECT 사원번호, 사원명, 입사일자, 매니저사원번호
FROM 사원
START WITH 매니저사원번호 IS NULL
=
CONNECT BY PRIOR 사원번호 매니저사원번호
AND 입사일자 BETWEEN '2013-01-01' AND '2013-12-31'
ORDER SIBLINGS BY 사원번호:
1 사원번호(PK)
사원명
입사일자
매니저사원번호(FK)
001
홍길동
003
이순신
004
이민정
005
이병헌
2012-01-01 2013-01-01 2013-01-01 2013-01-01
NULL
001
001
NULL
2 사원번호(PK)
사원명
입사일자
매니저사원번호(FK)
003
이순신
2013-01-01
001
004
이민정 2013-01-01
005
이병헌
2013-01-01
001
NULL
3 사원번호(PK)
사원명
입사일자
매니저사원번호(FK)
001
홍길동
2012-01-01
NULL
4 사원번호(PK)
사원명
입사일자
매니저사원번호(FK)
001
홍길동
005
이병헌
2012-01-01 2013-01-01
NULL
NULL
006
안성기
2014-01-01
005
007
이수근
2014-01-01
005
008
김병만
2014-01-01
005




*090

90
다음 중 계층형 질의문에 대한 설명으로 가장 부적절한 것은?




*091
91
1 SQL Server에서의 계층형 질의문은 CTE(Common Table Expression)를
재귀 호출함으로써 계층 구조를 전개한다.
@908 Server에서의 계층형 질의문은 앵커 멤버를 실행하여 기본 점
집합을 만들고 이후 재귀 멤버를 지속적으로 실행한다.
3 오라클의 제충청 질의문에서 WHERE 짙은 모든 전개를 진행한 이후 필터 조건으로서 조건을 만족하는 데이터만을 추출하는데 활용된다. 4 오라클의 제형 질의문에서 PRIOR 키워드는 CONNECT BY 사용할 수 있으며 PRIOR 자식 - 부모 형태로 사용하면 순방향 전
수행 된다.
아래 [부서와 매출 테이블에 대해서 SQL 문장을 실행하여 아래 [결과와 같이 데이터가 추출 되었다. 다음 중 동일한 결과를 추출하는 SQL 문장은?
[테이블: 부서]
_________________________  아래   _________________________


__________________________________________________________
[테이블: 매출
상위
부서코드
부서명
부서코드
매출액
(PK)
부서코드(FK)
100
아시아부
NULL
111
1000
110
한국지사
100
112
2000
111
서울지점
110
121
1500
112
부산지점
110
122
1000
120
일본지사
100
131
1500
121
도쿄지점
120
132
2000
122
오사카지
120
211
2000
130
중국지사
100
212
1500
131
베이징지점
130
221
1000
132
상하이지점
130
222
2000
200
남유럽지부
NULL
210 스페인지사
200
211 마드리드지점
210
212 그라나다지점
210
220 포르투갈지사
200
221 리스본지점
220
222
포르부지점
220
[결과]
부서코드
부서명
상위부서코드
100
아시아지부
NULL
매출액
LVL
120
일본지사
NULL
100
2
121
도쿄지점
NULL
120
1
122
오사카지점
1500
120
2
1000
2






*092





*093

93
92
다음 중 SELF JOIN을 수행해야 할 경우로 가장 적절한 것은?
1한 테이블 내에서 두 칼럼이 연관 관계가 있다.
2 두 테이블에 연관된 칼럼은 없으나 JOIN을 해야 한다.
3 두 테이블에 공통 칼럼이 존재하고 두 테이블이 연관 관계가 있다.
4 한 테이블 내에서 연관된 칼럼은 없으나 JOIN을 해야 한다.
아래와 같이 일자별매출 테이블이 존재할 때 아래 결과처럼 일자별 누적 매출액을 SQL로 구하려고 한다. WINDOW FUNCTION을 사용하지 않고
일자별 누적매출액을 구하는 SQL로 옳은 것은?

_________________________  아래   _________________________


__________________________________________________________
[테이블: 일자별매출]
일자
매출액
일자
[결과: 일자별 누적매출액] 누적대출액
2015.11.01
1000
2015,11,01
1000
2015.11.02
1000
2015.11.02
2000
2015.11.03
1000
2015.11.03
3000
2015.11.04
1000
2015.11.04
4000
2015.11.05
1000
2015.11.05
5000
2015.11.06
1000
2015,11,06
6000
2015.11.07
1000
2015.11.07
7000
2015.11.08
1000
2015.11.08
8000
2015.11.09
1000
2015.11.09
9000
2015,11,10
1000
2015, 11, 10
10000
1 SELECT A. 일자, SUM(A. 매출액) AS 누적매출액
FROM 일자별매출 A
GROUP BY A. 일자
ORDER BY A. 일자:
2 SELECT B. 일자, SUMB. 매출액) AS 누적매출액
FROM 일자별매출 A JOIN 일자별매출 BON (A. 일자>= B. 일자) GROUP BY B. 일자
ORDER BY B. 일자:
® SELECT A. 일자, SUMB. 매출액) AS 누적매출액
FROM 일자별매출 A JOIN 일자별매출 BON (A. 일자>= B. 일자)
GROUP BY A. 일자
ORDER BY A. 일자:
4 SELECT A. 일자
매출액
,(SELECT SUM(B. 매출액)
FROM 일자별매출 B WHERE B. 일자>= A. 일자) AS 누적
FROM 일자별매출 A
GROUP BY A. 일자
ORDER BY A. 일자:




*094

94
다음 중 아래의 SQL 수행 결과로 가장 적절한 것은?

_________________________  아래   _________________________


__________________________________________________________
SELECT COUNT(DISTINCT A||B)
FROM EMP
WHERE D = (SELECT D FROM DEPT WHERE E = 'T');
EMP 테이블
A
B
C
D
1
a
1
X
2
a
1
X
3
b
2
y
DEPT 테이블
D
E
F
X
i
5
y
m
6
10
2) 1
3 2
4 (4) 3




*095
95
아래는 서브쿼리에 대한 설명이다. 다음 중 올바른 것끼리 인 것은
96

_________________________  아래   _________________________


__________________________________________________________
가) 서브쿼리는 단일 행(Single Row) 또는 복수행(Multi Row) 비교
연산자와 함께 사용할 수 있다.
나) 서브쿼리는 SELECT 절, FROM 절, HAVING 절, ORDER BY 절
등에서 사용이 가능하다.
다) 서브쿼리의 결과가 복수 (Multi Bow) 결과를 반환하는 경우에는 '=', '<', '=>' 등의 연산자와 함께 사용이 가능하다.
라) 연관(Correlated) 서브퀴라는 서브쿼리가 메인쿼리 컬럼을 포함
하고 있는 형태의 서브쿼리이다.
마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환 되어 메인쿼리의 조건과 동시에 비교되는 것을 의미하며 Oracle 및 SQL Server 등의 DBMS에서 사용 할 수 있다.
1나, 라, 마
2 가, 나,라
3 나, 다, 라
4 가,나,마
MOR
아래 테이블은 어느 회사의 사원들과 이들이 부양하는 가족에 대한 것으로 밑줄 친 칼럼은 기본키(Primary Key)를 표시한 것이다. 다음 중 현재 부양하는 가족들이 없는 사원들의 이름을 구하라는 질의에 대해 아래 SQL 문장의 O ᄂ 에 들어 갈 내용으로 가장 적절한 것은?

_________________________  아래   _________________________


__________________________________________________________
[테이블]
사원 (사번, 이름, 나이)
가족 (이름, 나이, 부양사번)
※ 가족 테이블의 부양사번은 사원 테이블의 사번을 참조하는 외래
키(Foreign Key)이다.
[SQL 문장]
SELECT 이름
FROM 사원
WHERE
1 ᄀ: EXISTS
(SELECT * FROM 7 WHERE
ᄂ : 사번
=
부양사번
2
: EXISTS
3 ᄀ: NOT EXISTS
ᄂ: 사번◇부양사
ᄂ : 사번 =
부양사
4 ᄀ: NOT EXISTS
ᄂ : 사빈
부양사





*096





*097
97
다음 중 아래의 ERD를 참조하여 아래 SQL과 동일한 결과를 출력하는 SQL로 가장 부적절한 것은?

_________________________  아래   _________________________


__________________________________________________________
회원
동의항목
약관항목
회원번호
회원번호 (FK)
약관함목코드
약관항목코드 (FK)
회원명
+약관명
동의여부
동의일시
[SQL]
SELECT A. 회원번호, A. 회원명
FROM 회원 A, 동의항목 B
WHERE A. 회원번호 B. 회원번호
GROUP BY A. 회원번호, A. 회원명
HAVING COUNT(CASE WHEN B. 동의여부= 'N' THEN O ELSE
NULL END)>= 1
ORDER BY A. 회원번호:
1 SELECT A. 회원번호, A. 회원명
FROM 회원 A
WHERE EXISTS (SELECT 1 FROM
B
WHERE A. 회원번호= B. 회원번호 AND
ORDER BY A. 회원번호:
2 SELECT A 회원번호, A. 회원명
FROM 회원 A
B. 동의여부 = 'N)
WHERE A. 회원번호 IN (SELECT B. 회원번호 FROM 동의항목 B
ORDER BY A 회원번호:
3 SELECT A. 회원번호, A. 회원명
FROM 회원 A
WHERE B. 동의여부 = 'N)
WHERE ᄋ (SELECT COUNT(*)
FROM 동의항목 B WHERE B. 동의여부= 'N')
ORDER BY A 회원번호:
SELECT A. 회원번호, A. 회원명
FROM 회원 A 동의항목 B
WHERE A. 회원번호 = B. 회원번호 AND B. 동의여부 = 'N'
GROUP BY A 회원번호, A. 회원명
ORDER BY A. 회원번호:





*098

98
아래의 데이터 모델을 기준으로 SQL을 작성하였다. 다음 중 아래의
SQL에 대해 가장 바르게 설명한 것은?
회원
회원)
가입일시 이메일

_________________________  아래   _________________________


__________________________________________________________
메일발송
(이벤트)(FK)
SRD(FK)
-아 발송일시
이벤트 이벤트ID 이벤트명 시작일자 종료일자 내용
L
[SQL]
SELECT A. 회원ID, A. 회원명, A. 이메일
FROM
회원 A
WHERE EXISTS (SELECT 'X'
FROM 이벤트 B. 메일발송 C
WHERE B. 시작일자>= '2014.10.01 B. 이벤트ID=C. 이벤트ID
AND
AND A. 회원ID=C. 회원ID
HAVING COUNT(*) < (SELECT COUNT(*)
FROM 이벤트
WHERE 시작일자>= '2014.10.01'));
1 이벤트 시작일자가 2014.10.01'과 같거나 큰 이벤트를 대상으로 이메 일이 발송된 기록이 있는 모든 회원을 추출하는 SQL이다.
2ᄂ을 제거하고 ᄀ의 EXISTS 연산자를 IN연산자로 변경해도 결과는 동일하다.
3ᄃ은 이벤트 시작일자가 '2014.10.01'과 같거나 큰 이벤트건수와 그 이벤트들을 기준으로 회원별 이메일 발송건수를 비교하는 것이다. 4 GROUP BY 및 집계함수를 사용하지 않고 HAVING절을 사용하였으므로 SQL이 실행되지 못하고 오류가 발생한다.




*099

99
다음 중 서브쿼리에 대한 설명으로 가장 적절한 것은?
1 단일 행 서브쿼리는 서브쿼리의 실행 결과가 항상 한 건 이하인 서브쿼 리로서 IN, ALL 등의 비교 연산자를 사용하여야 한다.
2 다중 행 서브쿼리 비교 연산자는 단일 행 서브쿼리의 비교 연산자로도 사용할 수 있다.
3 연관 서브쿼리는 주로 메인쿼리에 값을 제공하기 위한 목적으로 사용 한다.
4 서브 쿼리는 항상 메인쿼리에서 읽혀진 데이터에 대해 서브쿼리에서 해당 조건이 만족하는지를 확인하는 방식으로 수행된다.
100
다음 중 아래 SQL에 대한 설명으로 가장 부적절한 것은?

_________________________  아래   _________________________


__________________________________________________________
[SQL]
SELECT B. 사원번호, B. 사원명, A. 부서번호, A. 부서명 , (SELECT COUNT(*) FROM 7 Y WHERE Y. 사원번호= B. 사원번호) AS 부양가족수
FROM 부서 A, (SELECT *
FROM 사원
WHERE 입사년도= '2014') B
WHERE A. 부서번호= B. 부서번호
AND
EXISTS (SELECT 1 FROM 사원 X WHERE X. 부서번호= A. 부서번호);
1 위 SQL에는 다중 행 연관 서브쿼리, 단일 행 연관 서브쿼리, Inline View 가 사용되었다.
2 SELECT절에 사용된 서브쿼리는 스칼라 서브쿼리라고도하며, 이러한 형태의 서브쿼리는 JOIN 으로 동일한 결과를 추출할 수도 있다. 3 WHERE 절의 서브쿼리에 사원 테이블 검색 조건으로 입사년도 조건을 FROM절의 서브쿼리와 동일하게 추가해야 원하는 결과를 추출할 수 있다.
4 FROM 절의 서브쿼리는 동적 뷰(Dynamic View)라고도 하며, SQL 문장 중 테이블 명이 올 수 있는 곳에서 사용할 수 있다.




*100





*101

101
아래와 같은 데이터 모델에서 평가대상상품에 대한 품질평가항목별 최종
평가결과를 추출하는 SQL 문장으로 옳은 것은? (단, 평가항목에 대한 평가(평가등급)가 기대수준에 미치지 못할 경우 해당 평가항목에 대해
서만 재평가를 수행한다)

_________________________  아래   _________________________


__________________________________________________________
[데이터 모델]
품질평가항목
평가결과
평가대상상품
평가항목 ID
상품ID(FK)
상품ID
평가회차
평가항목명
-OK 평가항목 ID (FK)
상품명
평가등급
평가일자
1 SELECT B. 상품ID, B. 상품명, C. 평가항목ID, C. 평가항목명, A. 평가회차,
A. 평가등급, A. 평가일자
FROM 평가결과 A, 평가대상상품 B, 품질평가항목 C.
(SELECT MAX(평가회차) AS 평가회차 FROM 평가결과) D
WHERE A. 상품ID= B. 상품ID
AND A. 평가항목ID = C. 평가항목ID
AND A. 평가회차 = D. 평가회차:
2 SELECT B. 상품ID, B. 상품명, C. 평가항목ID, C. 평가항목명, A. 평가회차, A. 평가등급, A. 평가일자
FROM 평가결과 A, 평가대상상품 B, 품질평가항목 C
WHERE A. 상품ID= B. 상품ID
AND A. 평가항목ID=C. 평가항목ID
AND
A. 평가회차= (SELECT MAX(X. 평가회차)
FROM 평가결과 X
WHERE X. 상품ID= B. 상품ID
AND X. 평가항목ID=C. 평가항목ID);



*102

102
아래 부서 테이블의 담당자 변경을 위해 부서임시 테이블에 입력된 데이
터를 활용하여 주기적으로 부서 테이블을 아래 결과와 같이 반영하기 기준으로 가장 최근에 변경된 데이터를 기준으로 부서 테이블에 반영되 위한 SQL으로 가장 적절한 것은?(단, 부서임시 테이블에서 변경일자를
어야 한다)

_________________________  아래   _________________________


__________________________________________________________
[테이블: 부서]
부서코드(PK)
부서명
상위부서코드
담당자
대표이사
NULL
김대표
A001
영업본부
A001
홍길동
A002
A003
경영지원본부
A001
이순신
A004
마케팅본부
A001
강감찬
A005
해외영업팀
A002
이청용
A006
국내영업팀
A002
박지성
A007
총무팀
A003
차두리
A008
인사팀
A003
이민정
A009
해외마케팅팀
A004
이병헌
A010
국내마케팅팀
A004
차승원
[테이블: 부서임시]
변경일자(PK) 부서코드(PK)
담당자
2014.01.23
A007
이달자
2015.01.25
A007
홍경민
2015.01.25
A008
유재석
[결과]
부서코드(PK)
부서명
상위부서코드
담당자
A001
대표이사
NULL
김대표
A002
영업본부
A001
홍길동
A003
경영지원본부
A001
이순신
A004
마케팅본부
A001
강감찬
A005
해외영업팀
A002
A006
국내영업팀
이청용
A002
A007
총무팀
박지성
A003
A008
인사팀
홍경민
A003
A009
해외마케팅팀
유재석
A004
A010
국내마케팅팀
이병헌
A004
차승원




*103
1 UPDATE 부서 A SET 담당자 = (SELECT C. 부서코드
FROM
(SELECT 부서코드, MAX(변경일자) AS 변경일자 FROM 부서입시
GROUP BY 부서코드) B. 부서임시 C
WHERE B. 부서코드 C. 부서코드
AND
B. 변경일자= C. 변경일자
AND
2 UPDATE 부서
FROM
A. 부서코드 = C. 부서코드)
A SET 담당자= (SELECT C. 부서코드
(SELECT 부서코드, MAX(변경일자) AS 변경일자
FROM 부서임시
GROUP BY 부서코드) B, 부서임시 C
WHERE B. 부서코드 C. 부서코드
AND B. 변경일자 = C. 변경일자
AND A. 부서코트 - C. 부시코드)
=
WHERE EXISTS (SELECT 1 FROM 부서 X WHERE A. 부서코드=
X. 부서코드);
3 UPDATE 부서 A SET 담당자= (SELECT B. 담당자
FROM
부서임시 B
= A. 부서코드
WHERE B. 부서코드
AND B. 변경일자 = (SELECT MAX(C.변경일자)
FROM 부서임시 CWHERE
C. 부서코드 = B. 부서코드)
WHERE 부서코드 IN (SELECT 부서코드 FROM 부서임시);
4 UPDATE 부서 A SET 담당자= (SELECT B. 담당자
FROM 부서임시 B
WHERE B. 부서코드= A. 부서코드
AND B. 변경일자= '2015.01.25.");
103
다음 중 뷰(View)에 대한 설명으로 가장 부적절한 것은?
1 뷰는 단지 정의만을 가지고 있으며, 실행 시점에 질의를 재작성하여 수행한다.
2 뷰는 복잡한 SQL 문장을 단순화 시켜주는 장점이 있는 반면, 테이블
구조가 변경되면 응용 프로그램을 변경해 주어야 한다.
3 뷰는 보안을 강화하기 위한 목적으로도 활용할 수 있다.
4 실제 데이터를 저장하고 있는 뷰를 생성하는 기능을 지원하는 DBMS도
있다.





*104
104
결과로 맞는 것은?
아래 테이블에 대한 [뷰 생성 스크립트를 실행한 후, 조회 SQL의 실용

_________________________  아래   _________________________


__________________________________________________________
[TBL]
C2
C1
100
A
200
B
B
100
B
200
[뷰 생성 스크립트)
CREATE VIEW V_TBL
AS
SELECT *
FROM TBL
WHERE C1 = 'B' OR C1 IS NULL
[조회 SQL]
SELECT SUM(C2) C2
FROM V TBL
WHERE C2>= 200AND C1='B'
10
3 300
(2) 200
4 400
105
다음 중 아래의 테이블에서 SQL을 실행할 때 결과로 가장 적절한 것은?

_________________________  아래   _________________________


__________________________________________________________
[데이블 : 서비스
서비스ID(PK)
서비스명
001
서비스!
002
서비스2
003
서비스3
004
[테이블: 서비스가입]
서비스4
회원번호(PK)
서비스ID(PK)
가입일자
1
001
2013-01-01
1
002
2013-01-02
2
001
2013-01-01
2
002
2013-01-02
2
003
2013-01-03
3
001
2013-01-01
3
002
2013-01-02
3
003
2013-01-03





*105





*106
106
같은 형식의 데이터를 추출하려고 할 때 올바른 SQL 문장은?
아래의 데이터 모델에서 SQL을 이용하여 표(지역별 월별 이용량

_________________________  아래   _________________________


__________________________________________________________
이용내역
지역
지역
이용자ID
이용일시
지역명
-sk
이용량
지역D(FX)
[표: 지역별 월별 이용량]
지역명
서울
서울
2014.02
서울
월별합계
경기 경기 경기 대전 대전
2014.01
2014.03
2014.05
이용원
이용량
2014.01
1,000
1,000
2,000
1,000
2,000
3,000
1,500
2014.06
1,000
대전
월별합계
2,500
지역전체
월별합계
7,500
1 SELECT (CASE GROUPING(B. 지역명) WHEN O THEN '지역전체
ELSE B. 지역명 END) AS 지역명
(CASE GROUPING(TO CHARIA 이용일시, YYYYMM))
WHEN THEN '월별합계
ELISE TO_CHARA 이용일시 'YYYYMM) END) AS 이용원
SUMIA 이용) AS 이용량
FROM 이용내역 A INNER JOIN 지역 B ON (A 지역ID=B. 지역D) GROUP BY ROLLUPB. 지역명, TO_CHARIA 이용일시, 'YYYYMM
2 SELECT (CASE GROUPING(B, 지역ID) WHEN THEN '지역전체 ELSE MIN(B. 지역명) END) AS 지역명
(CASE GROUPING(TO_CHAR(A. 이용일시, YYYYMM) WHEN 1 THEN '월별합계
ELSE TO_CHAR(A. 이용일시. YYYYMM) END) AS 이용원
,SUM(A. 이용량) AS 이용량
FROM 이용내역 A INNER JOIN 지역 B ON (A 지역ID= B. 지역ID)
GROUP BY ROLLUP(B. 지역ID, TO_CHAR(A. 이용일시, 'YYYYMM'))





*107
SELECT (CASE GROUPING WHEN I THEN
FROM
CAR GROUPINGTO CHARA YYYYMM
SUMA
WINTON Www
BAR TO CHARA PLYYYY MNC) NDA 19
A INNER JOIN ON (ADR
GROUP BY CUMB TO CHARCA 19 YYYYMMC)
SELECT (CASE GROUPINGA
ELSE MINOR
WHEN I THEN
END) AS apy
(CASE GROUPING TO CHARCA 1914, YYYY MM))
WHEN I THEN '월별합계
ELSE TO CHARCA 1941, YYYY MM) END AS 19
SUM(A. 이용량) AS 이용량
FROM 이용내역 A INNER JOIN 지역 B ON (A. 지역ID= B. 지역ID)
GROUP BY GROUPING SETSORD, TO CHARA 1894), YYYY, MMC))
107
아래 결과를 얻기 위한 SQL에서 ᄀ에 들어갈 함수를 작성하시오.

_________________________  아래   _________________________


__________________________________________________________
구매이력
구매고객
구매월
총 구매건
총 구매액
AAA
201001
1
1000
AAA
201002
2
3000
AAA
201003
1
1000
AAA
4
5000
BBB
201001
3
2000
BBB
201002
5
3000
BBB
201003
1
2000
BBB
9
7000
CCC
201101
1
2000
CCC
201102
1
5000
CCC
201103
1
1000
CCC
3
8000
16
20000
[SQL문]
SELECT 구매고객 구매월 COUNT(*) 총 구매, SUM(구매금액 총 구매액
FROM 구매이력
GROUP BY
(구매고객, 구매월)S





*108
핵심정리
108
다음 설명 중 가장 적절한 것은?
Grouping Columns0|
가질 수 있는 모든 경우에 대하여 Subtotal을
생성해야 하는 경우에는 CUBE를 사용하는 것이 바람직하나, ROLLUP에 비해 시스템에 많은
부담을 주므로 사용에 주의해야 한다.
1 일반 그룹 함수를 사용하여 CUBE, GROUPING SETS와 같은 그룹 함수와 동일한 결과를 추출할 수 있으나, ROLLUP 그룹 함수와 동일한
결과는 추출할 수 없다.
2 GROUPING SETS 함수의 경우에는 함수의 인자로 주어진 컬럼의 순서에
따라 결과가 달라지므로 컬럼의 순서가 중요하다.
3 CUBE, ROLLUP, GROUPING SETS 함수들의 대상 컬럼 중 집계된 컬럼 이외의 대상 컬럼 값은 해당 컬럼의 데이터 중 가장 작은 값을
반환한다.
4 CUBE 그룹 함수는 인자로 주어진 컬럼의 결합 가능한 모든 조합에 대해서 집계를 수행하므로 다른 그룹 함수에 비해 시스템에 대한 부하가
크다.
CUBE는 결합 가능한 모든 값에 대하여 다차원
109
아래와 같이 설비와 에너지사용 테이블을 이용하여 결과를 나타내려할
집계를 생성한다.
때 SQL으로 가장 적절한 것을 2개 고르시오.

_________________________  아래   _________________________


__________________________________________________________
CUBE도 결과에 대한
정렬이 필요한 경우는
ORDER BY 절에
[테이블: 설비]
명시적으로 정렬 칼럼이
설비ID
설비명
[테이블: 에너지사용] 설비ID 에너지코드
사용량
1
설비1
1
전기
100
표시가 되어야 한다.
2
설비2
1
용수
200
3
설비3
1
바람
300
2
전기
200
2
용수
300
3
전기
300
0008
0000
[결과]
0000
설비ID
에너지코드
사용량합계
1
바람
300
20006
1
용수
200
0000
1
전기
100
10000
1
NULL
600
0002
2
용수
300
2
전기
200
0008 00000
2
NULL
500
3
전기
300
3
NULL
300
NULL
바람
NULL
300
용수
NULL
500
전기
NULL
600
NULL
1400
112 | SQL 자격검정 실전문제





*109





*110
110
핵심정리
중 ᄀ에 들어갈 문장으로 옳은 것은?
자재발주 테이블에 SQL을 수행하여 아래와 같은 결과를 얻었다. 다음

_________________________  아래   _________________________


__________________________________________________________
GROUPING SETS
다양한 소계 집합을 만들 수 있는데, GROUPING SETS에 표시된 인수들에 대한 개별 집계를 구할 수 있으며, 이때 표시된
[테이블: 자재발주]
자재번호
발주처ID
발주일자
발주수량
001
20150102
100
1
001
20150103
200
1
인수들 간에는 계층
001
20150102
200
2
구조인 ROLLUP과는 달리
002
20150102
100
2
평등한 관계이므로 인수의
순서가 바뀌어도 결과는 같다.
3
001
20150103
100
3
002
20150103
200
그리고 GROUPING SETS
함수도 결과에 대한
[SQL]
정렬이 필요한 경우는
ORDER BY 절에
명시적으로 정렬 칼럼이
표시가 되어야 한다.
114 | SQL 자격검정 실전문제
SELECT CASE WHEN GROUPING(자재번호) = 1 THEN '자재전체'
FROM
ELSE 자재번호 END AS 자재번호
CASE WHEN GROUPING(발주처ID) = 1 THEN '발주처전체'
ELSE 발주처ID END AS 발주처ID
CASE WHEN GROUPING(발주일자) = 1 THEN '발주일자전체'
ELSE 발주일자 END AS 발주일자
,SUM(발주수량) AS 발주수량합계 자재발주
ᄀ
ORDER BY 자재번호, 발주처ID, 발주일자
[결과]
자재번호
발주처ID
발주일자
발주수량합계
1
발주처전체
발주일자전체
300
2 3
발주처전체
발주일자전체
300
발주처전체
발주일자전체
300
자재전체
001
20150102
300
자재전체
001
20150103
300
자재전체
002
20150102
100
자재전체
002
20150103
200
1 GROUP BY CUBE (자재번호, (발주처ID, 발주일자))
2 GROUP BY CUBE (자재번호, 발주처ID, 발주일자)
3 GROUP BY GROUPING SETS (자재번호, 발주처ID, 발주일자) 4 GROUP BY GROUPING SETS (자재번호, (발주처ID, 발주일자))



*111
111
다음 중 월별매출 테이블을 대상으로 아래 SQL을 수행한 결과인 것은?

_________________________  아래   _________________________


__________________________________________________________
[테이블: 월별매출]
상품ID
21
매출액
P001
2014,10
1500
P001
2014.11
1500
P001
2014.12
2500
P002
2014.10
1000
P002
2014.11
2000
P002
2014.12
1500
P003
2014.10
2000
P003
2014,11
1000
P003
2014.12
1000
[SQL]
SELECT 상품ID, 월, SUM(매출액) AS 매출액
FROM 월별매출
WHERE BETWEEN '2014.10' AND '2014.12'
GROUP BY GROUPING SETS((ID, ));
1 상품D
월
매출액
2 상품ID
food
매출액
NULL
2014.10
4500
P001
2014.10
1500
NULL 2014.11 4500
P001
2014.11
1500
NULL 2014.12 5000
P001
2014, 12
2500
P001
NULL
5500
P002
2014.10
1000
P002
NULL
4500
P002
2014.11
2000
P003
NULL 4000
P002
2014.12 1500
P003
2014.10 2000
P003
2014.11 1000
P003
2014.12 1000
3 상품ID
20
매출액
4 상품ID
20
매출액
NULL
2014.10
4500
P001
2014.10
1500
NULL
2014, 11
4500
P002
2014.10
1000
NULL
2014, 12
5000
P003
2014,10
2000
P001
NULL
5500
NULL
2014.10 4500
P002
NULL 4500
P001
2014.11 1500
P003
NULL 4000
P002
2014,11
2000
1400
P003
2014.11 1000
NULL
NULL
0
NULL
2014,11
4500
P001
2014.12
2500
P002
2014,12
1500
P003
2014,12
1000
MO
NULL
2014,12
5000




*112
112
113
다음 중 윈도우 함수(Window Function, Analytic Function)에 대한
설명으로 가장 부적절한 것은?
1 Partition과 Group By 구문은 의미적으로 유사하다.
• Partition 구문이 없으면 전체 집합을 하나의 Partition으로 정의한
것과 동일하다.
3 윈도우 함수 처리로 인해 결과 건수가 줄어든다.
4 윈도우 함수 적용 범위는 Partition을 넘을 수 없다.
다음 중 아래와 같은 테이블에서 SQL을 실행할 때 결과로 가장 적절한
것은?

_________________________  아래   _________________________


__________________________________________________________
[테이블: 고객]
고객번호(PK)
고객명
001
홍길동
002
이순신
003
강감찬
004
이상화
005
이규혁
[테이블: 월별매출]
월(PK)
고객번호(PK)
매출액
201301
001
200
201301
002
300
201301
003
250
201301
004
300
201301
005
250
201302
001
150
201302
002
150
201302
004
200
201302
005
100
201303
002
100
201303
003
100
201303
004
200
201303
005
350
[SQL]
1000
FROM (
SELECT 고객번호, 고객명, 매출액
RANK() OVER(ORDER BY 매출액 DESC) AS 순위
SELECT A. 고객번호
)
, MAX(A. 고객명) AS 고객명
SUM(B. 매출액) AS 매출액
FROM 고객 A INNER JOIN 월별매출 B (A. 고객번호 = B. 고객번호)
ON
GROUP BY A. 고객번호
ORDER BY RNK;





*113





*114
114
아래 데이터 모델에서 활동점수가 높은 고객을 게임상품별로 10까지 선별하여 사은행사를 진행하려고 한다. 다음 SOL 중 가장 적절한 것은?
(단, 활동점수가 동일한 고객은 동일등수로 한다. 아래 결과 예제 참조)
고객활동

_________________________  아래   _________________________


__________________________________________________________
고객
게임상품
고객ID(FK)
게임상품ID
게임상품명
ok
게임상품ID(FK) 활동점수
고객ID
+ 고객명
[결과 예제]
게임상품ID
고객ID
활동접수
등수(순위)
001
121
150
1
001
111
150
1
001
234
110
3
001
212
100
4
001
455
100
4
001
182
90
6
001
199
80
7
001
109
70
8
001
876
70
8
001
232
40
10
001
901
40
10





*115
115
다음 중 추천내역 테이블에서 아래와 같은 SQL을 수행하였을 때의 결과로
가장 적절한 것은?

_________________________  아래   _________________________


__________________________________________________________
테이블: 추천내역]
추천경로
추천인
피추천인
추천점수
나한일
강감찬
SNS
75
SNS
이순신
강감찬
80
이벤트응모
홍길동
강감찬
88
이벤트응모
저절로
이순신
78
홈페이지
저절로
이대로
93
홈페이지
홍두개
심청이
98
[SQL]
SELECT 추천경로, 추천인, 피추천인, 추천점수
FROM (SELECT 추천경로, 추천인, 피추천인, 추천점수
,ROW_NUMBER() OVER(PARTITION BY 추천경로
ORDER BY + DESC) AS RNUM
FROM 추천내역)
WHERE RNUM
= 1;
1 추천경로
추천인
피추천인
추천점수
SNS
나한일
강감찬
75
SNS
이순신
강감찬
80
이벤트응모
홍길동
강감찬
88
이벤트응모
저절로
이순신
78
홈페이지
저절로
이대로
93
홈페이지
홍두깨
심청이
98
추천경로
추천인
피추천인
추천점수
홈페이지
홍두깨
심청이
98
(3)
추천경로
추천인
피추천인
추천점수
SNS
이순신
강감찬
80
이벤트응모
홍길동
강감찬
88
홈페이지
홍두깨
심청이
98
(4)
추천경로
추천인
피추천인
추천점수
SNS
나한일
강감찬
75
이벤트응모
저절로
이순신
78
홈페이지
저절로
이대로
93





*116
116
다음 중 아래의 SQL에 대한 설명으로 가장 적절한 것은?

_________________________  아래   _________________________


__________________________________________________________
[SQL]
SELECT 상품분류코드
AVG(상품가격) AS 상품가격
COUNT(*) OVER(ORDER BY AVG(상품가격) RANGE BETWEEN 10000 PRECEDING
FROM 상품
AND 10000 FOLLOWING) AS 유사개수
GROUP BY 상품분류코드:
1 WINDOW FUNCTION GROUP BY 절과 함께 사용하였으므로 위의
SQL은 오류가 발생한다.
2 WINDOW FUNCTION ORDER BY절에 AVG 집계 함수를 사용하였 으므로 위의 SQL은 오류가 발생한다.
-
3 유사개수 컬럼은 상품분류코드별 평균상품가격을 서로 비교하여 - 10000~ +10000 사이에 존재하는 상품분류코드의 개수를 구한 것이다.
4 유사개수 컬럼은 상품전체의 평균상품가격을 서로 비교하여 -10000 ~ +10000 사이에 존재하는 상품의 개수를 구한 것이다.





*117
117
예상되는 결과로 가장 적절한 것은?
다음 중 [사원] 테이블에 대하여 아래와 같은 SQL을 수행하였을 때
[테이블: 사원]

_________________________  아래   _________________________


__________________________________________________________
사원ID
부서ID
사원명
연봉
100
홍길동
001
2500
100
강감찬
002
3000
003
200
김유신
4500
004
200
김선달
3000
005
200
유학생
2500
006
300
변사또
4500
007
300
박문수
3000
[SQL]
SELECT Y. 사원ID, Y. 부서ID, Y. 사원명 Y 연봉
FROM (SELECT 사원ID, MAX(연봉) OVER(PARTITION BY
부서(D) AS 최고연봉
FROM 사원) X, 사원 Y
WHERE X 사원ID Y. 사원ID
AND X. 최고연봉=Y. 연봉
사원ID
부서ID
사원명
연봉
002
100
강감찬
3000
003
200
김유신
4500
006
300
변사또
4500
사원ID
부서ID
사원명
연봉
001
100
홍길동
2500
005
200
유학생
2500
007
300
박문수
3000
(3)
사원ID
부서ID
사원명
연봉
003
200
김유신
006
300
변사또
(4)
사원ID
부서ID
사원명
004
200
김유신
4500
4500
연봉
4500





*118
118
다음 중 아래 SQL의 실행 결과로 가장 적절한 것은?

_________________________  아래   _________________________


__________________________________________________________
CREATE TABLE TBL
(ID VARCHAR2(10),
START VAL NUMBER,
END VAL NUMBER)
TBL
ID
START VAL
END VAL
A
10
14
A
14
15
A
15
15
A
15
18
A
20
25
A
25
SELECT ID, START_VAL, END_VAL
FROM (
SELECT ID, START_VAL, NVL(END_VAL, 99) END_VAL,
(CASE WHEN START_VAL = LAG(END VAL) OVER (PARTITION BY ID ORDER BY START_VAL, NVL(END_VAL, 99)) THEN 1 ELSE O
END) FLAGI,
(CASE WHEN END_VAL = LEAD(START VAL) OVER (PARTITION BY ID ORDER BY START_VAL, NVL(END_VAL, 99)) THEN 1
ELSE O
END) FLAG2
FROM TBL)
WHERE FLAGI = 0
OR FLAG2 = 0
ID
A
A
START VAL
END VAL
10
14
15
18
A
20
25
A
25
99
2 ID
START VAL
END VAL
A
15
15
(3) ID
START VAL
END VAL
A
10
14
A
15
15
A
20
99
4) ID
START VAL
END VAL
10
18
A
20
99
A





*119
119
아래 설명 중
ᄂ 에 해당하는 내용을 작성하시오.
120

_________________________  아래   _________________________


__________________________________________________________
DBMS에 생성된 USER와 다양한 권한들 사이에서 중개 역할을 합 수 있도록 DBMS에서는 ROLE을 제공한다. 이러한 ROLE DBMS
USER에게 부여하기 위해서는 [
ROLE을 회수하기 위해서는
명령을 사용하며,
명령을 사용한다.
다음 중 B_User가 아래의 작업을 수행할 수 있도록 권한을 부여하는
DCL로 가장 적절한 것은?
UPDATE A User, TB_A
SET col1='AAA'
WHERE col2-3

_________________________  아래   _________________________


__________________________________________________________
1 GRANT SELECT, UPDATE TO B_User;
REVOKE SELECT ON A_User. TB_A FROM B_User;
3 DENY UPDATE ONA_User. TB_A TO B_User;
4 GRANT SELECT, UPDATE ON A_User.TB_A TO B_User;
121
아래의
에 들어갈 내용을 쓰시오.
아래
DBMS 사용자를 생성하면 기본적으로 많은 권한을 부여해야 한다. 많은 DBMS에서는 DBMS 관리자가 사용자별로 권한을 관리해야 하는 부담과 복잡함을 줄이기 위하여 다양한 권한을 그룹으로 묶어 관리할 수 있도록 사용자와 권한 사이에서 중개 역할을 수행하는 을 제공한다.





*120







*121




*122

122
사용자 Lee가 릴레이션 R을 생성한 후, 아래와 같은 권한부여 SQL문들을
실행하였다. 그 이후에 기능이 실행 가능한 SQL을 2개 고르시오. (단, A, B의 데이터 타입은 정수형이다)

_________________________  아래   _________________________


__________________________________________________________
Lee: GRANT SELECT. INSERT, DELETE ON R TO Kim WITH GRANT OPTION:
Kim: GRANT SELECT. INSERT, DELETE ON R TO Park:
Lee: REVOKE DELETE ON R FROM Kim;
Lee: REVOKE INSERT ON R FROM Kim CASCADE;
1 Park: SELECT * FROM R WHEREA=400;
2 Park: INSERT INTO R VALUES(400, 600);
3 Park: DELETE FROM R WHERE B=800;
4 Kim: INSERT INTO R VALUES(500, 600);
123
다음 중 PL/SQL에 대한 설명으로 가장 부적절한 것은?
1 변수와 상수 등을 사용하여 일반 SQL 문장을 실행할 때 WHERE절의 조건 등으로 대입할 수 있다.
2 Procedure, User Defined Function, Trigger 객체를 PL/SQL로 작성 할 수 있다.
3 PL/SQL로 작성된 Procedure, User Defined Function은 전체가 하나의 트랜젝션으로 처리되어야 한다.
4 Procedure 내부에 작성된 절차적 코드는 PL/SQL 엔진이 처리하고 일 반적인 SQL 문장은 SQL 실행기가 처리한다.
수
수




*123





*124
124
아래는 임시부서(TMP_DEPT) 테이블로부터 부서(DEPT) 테이블에
데이터를 입력하는 PL/SQL 이다. 부서 테이블에 데이터를 입력하기
전에 부서 테이블의 모든 데이터를 ROLLBACK이 불가능 하도록 삭제
하려고 한다. 다음 중
에 들어갈 내용으로 옳은 것은?

_________________________  아래   _________________________


__________________________________________________________
[PL/SQL]
create or replace procedure insert_dept authid current_user
as
begin
INSERT /*+ APPEND */ INTO DEPT (DEPTNO, DNAME,
LOC)
SELECT DEPTNO, DNAME, LOC
FROM TMP_DEPT;
commit;
end;
1
1 TRUNCATE TABLE DEPT;
2 DELETE FROM DEPT;
3 execute immediate 'TRUNCATE TABLE DEPT';
execute 'TRUNCATE TABLE DEPT";
125
다음 중 절차형 SQL 모듈에 대한 설명으로 가장 부적절한 것은?
1 저장형 프로시저는 SQL을 로직과 함께 데이터베이스 내에 저장해 놓은 명령문의 집합을 의미한다.
2 저장형 함수(사용자 정의 함수)는 단독적으로 실행되기 보다는 다른 SQL문을 통하여 호출되고 그 결과를 리턴하는 SQL의 보조적인 역할을 한다.
3 트리거는 특정한 테이블에 INSERT, UPDATE, DELETE와 같은 DML 문이 수행되었을 때 데이터베이스에서 자동으로 동작하도록 작성된 프로그램이다.
4 데이터의 무결성과 일관성을 위해서 사용자 정의 함수를 사용한다.





*125





*126
126
다음 중 Trigger에 대한 설명으로 가장 부적절한 것은?
127
1 Trigger는 데이터베이스에 의해서 자동으로 호출되고 수행된다.
Trigger는 특정 테이블에 대해서 INSERT, UPDATE, DELETE 문이
수행되었을 때 호출되도록 정의할 수 있다.
3 Trigger는 TCL을 이용하여 트랜젝션을 제어할 수 있다.
4 Trigger는 데이터베이스에 로그인하는 작업에도 정의할 수 있다.
다음 중 특정한 테이블에 INSERT, UPDATE, DELETE와 같은 DML문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 저장 프로그램으로 가장 적절한 것은?(단, 사용자가 직접 호출하여 사용하는 것이 아니고 데이터베이스에 서 자동적으로 수행하게 된다.)
1 PROCEDURE
2 USER DEFINED FUNCTION
3 PACKAGE
4) TRIGGER





*127


