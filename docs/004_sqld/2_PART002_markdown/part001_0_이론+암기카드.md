 
---

## 📘 책표지 (텍스트 버전)

```
───────────────────────────────
SQLD 자격시험 이론 필기 & 암기카드

데이터 도시를 탐험하는 3부작 스토리텔링 해설서  
+ 핵심 요약 + 암기카드 + 대표 기출 문제

제작: 사장님  
버전: 2025년 최신 개정판  
───────────────────────────────
```

---

## 📖 목차

| 챕터 번호 | 제목 | 카드 범위 | 기출 문제 수 |
|-----------|-----------------------------|-------------|----------------|
| 01 | 🏙️ Episode 1: 모델링 탐정단 — 데이터 구조와 정규화 | 카드 1~20 | 6문제 |
| 02 | 🧾 Episode 2: 정보 탐험대 — SQL 문법과 쿼리 전략 | 카드 21~45 | 6문제 |
| 03 | 🛡️ Episode 3: 시스템 수호국 — 트랜잭션과 무결성 관리 | 카드 46~69 | 13문제 |
| 04 | 📚 부록: 전체 요약 정리 + 실무 연결 포인트 | 없음 | 없음  


## 🏙️ Episode 1: 데이터 도시의 설계자 — 모델링 탐정단 (완성판)

데이터 도시에는 수많은 건물(테이블)과 주민(데이터)이 살고 있었어요.  
각 건물은 고객, 주문, 상품 같은 정보를 담고 있었고,  
주민들은 그 안에서 살아가며 서로 연결되어 있었죠.  
처음엔 평화로웠지만, 도시가 커지면서 문제가 생기기 시작했어요.  
주민 이름이 겹치고, 주문 내역이 중복되고, 어떤 정보가 어디 있는지 헷갈리기 시작했죠.  
그래서 등장한 것이 바로 **모델링 탐정단**!  
그들은 도시를 질서 있게 설계하기 위해 움직였어요.

---

### 🎯 왜 필요한가?

모델링은 데이터베이스의 **설계도**예요.  
- 잘못 설계하면: 중복, 오류, 느린 검색, 유지보수 지옥  
- 잘 설계하면: 빠른 검색, 정확한 정보, 확장성 있는 구조

> 모델링은 “정보를 정리하는 기술”이자, “시스템의 뼈대”입니다.

---

### 🔍 탐정단의 도구들

| 도구 | 역할 | 예시 |
|------|------|------|
| 🕵️ 엔터티(Entity) | 관리할 대상 | 고객, 주문, 상품 |
| 📋 속성(Attribute) | 대상의 특징 | 이름, 가격, 날짜 |
| 🔗 관계(Relationship) | 대상 간 연결 | 고객은 주문을 한다 |

- 엔터티는 **테이블**, 속성은 **컬럼**, 관계는 **연결선**이라고 생각하면 쉬워요.  
- 관계에는 **몇 명이 연결되는지(카디널리티)**와 **필수인지 선택인지(참여도)**가 있어요.

---

### 🧙 정규화 마법 — 데이터 중복을 없애는 기술

| 단계 | 핵심 개념 | 쉽게 말하면 | 예시 |
|------|------------|--------------|------|
| **1NF** | 반복 제거 | 셀에 값 하나만 | ❌ 취미 = "독서, 음악" → ✅ 취미 테이블 따로 만들기 |
| **2NF** | 부분 종속 제거 | 키 일부에만 의존하면 분리 | ❌ (학생ID, 과목ID) → 과목명 → ✅ 과목 테이블 따로 |
| **3NF** | 이행 종속 제거 | 속성이 속성을 설명하면 분리 | ❌ 학과ID → 학과명 → ✅ 학과 테이블 따로 |
| **BCNF** | 결정자 후보키화 | 결정자가 후보키 아니면 분해 | ❌ 강의실번호 → 강의시간 → 강의실번호가 후보키 아니면 분리 |

> 💡 기억법:  
> - 1NF: 셀 안에 값이 여러 개면 ❌  
> - 2NF: 키 일부에만 의존하면 ❌  
> - 3NF: 속성이 속성을 설명하면 ❌  
> - BCNF: 결정자가 후보키 아니면 ❌

---

### 🧭 식별자 추적

| 종류 | 설명 | 예시 |
|------|------|------|
| 기본키 (PK) | 고유값, 중복/NULL 불가 | 주민번호, 주문번호 |
| 외래키 (FK) | 다른 테이블과 연결 | 주문 테이블에 고객ID 넣기 |
| 보조식별자 (AK) | PK는 아니지만 유일한 값 | 이메일, 전화번호 |

> 기본키는 “이름표”, 외래키는 “다리”, 보조식별자는 “예비 이름표”라고 생각하면 쉬워요.

---

### 📐 관계의 구성 요소

| 요소 | 설명 | 예시 |
|------|------|------|
| 관계명 | 연결 의미 | 고객은 주문을 한다 |
| 차수 (카디널리티) | 몇 명이 연결되는지 | 1:1, 1:N, N:M |
| 참여도 | 연결이 필수인지 선택인지 | 고객은 반드시 주문을 한다 (필수), 직원은 프로젝트에 참여할 수도 있다 (선택)

> 💡 기억법: 관·차·참

---

## 🧩 모델링 탐정단의 비밀 수첩 — 누락된 이론 보완

---

### 🔹 1. 엔터티의 분류 — 어떤 주민인가요?

| 분류 기준 | 유형 | 설명 | 예시 |
|-----------|------|------|------|
| 형태 기준 | 유형 엔터티 | 눈에 보이고 만질 수 있음 | 사원, 상품, 건물 |
| 〃 | 개념 엔터티 | 눈에 안 보이지만 개념적으로 존재 | 조직, 정책, 보험상품 |
| 〃 | 사건 엔터티 | 어떤 일이 발생했을 때 생김 | 주문, 사고, 청구 |
| 시점 기준 | 기본 엔터티 | 원래부터 존재함 | 고객, 부서 |
| 〃 | 중심 엔터티 | 기본 엔터티와 연결되어 중심 역할 | 주문, 계약 |
| 〃 | 행위 엔터티 | 중심 엔터티에서 파생됨 | 주문 상세, 이력, 결제 내역 |

> 💡 기억법: 유·개·사 / 기·중·행

---

### 🔹 2. 속성의 종류 — 주민의 특징은 어떻게 나뉘나요?

| 분류 기준 | 유형 | 설명 | 예시 |
|-----------|------|------|------|
| 업무 기준 | 기본 속성 | 업무에서 직접 나옴 | 이름, 생년월일 |
| 〃 | 설계 속성 | 규칙으로 만든 값 | 고객ID, 상품코드 |
| 〃 | 파생 속성 | 계산해서 나온 값 | 총금액 = 수량 × 단가 |
| 구조 기준 | 단일 속성 | 하나의 값만 가짐 | 이름, 나이 |
| 〃 | 복합 속성 | 여러 값이 묶여 있음 | 주소(시, 구, 동) |
| 〃 | 다중값 속성 | 여러 개의 값이 있음 | 취미 = 독서, 음악 |

> 💡 다중값 속성은 1NF 위반이므로 반드시 테이블로 분리해야 해요!

---

### 🔹 3. 식별자의 종류 — 주민을 어떻게 구분하나요?

| 기준 | 유형 | 설명 | 예시 |
|------|------|------|------|
| 대표 여부 | 주식별자 / 보조식별자 | 대표값 / 후보값 | 고객ID / 이메일 |
| 생성 방식 | 본질 / 인조 식별자 | 원래 있던 값 / 새로 만든 값 | 주민번호 / 고객번호 |
| 관계 기준 | 내부 / 외부 식별자 | 자기 테이블 / 다른 테이블 | 고객ID / 주문의 고객ID

> 💡 기억법: 주·보 / 본·인 / 내·외

---

### 🔹 4. 식별 관계 vs 비식별 관계 — 연결 방식의 차이

| 관계 유형 | 설명 | ERD 표현 | 예시 |
|-----------|------|-----------|------|
| 식별 관계 | 부모의 PK가 자식의 PK에 포함됨 | 실선 | 주문 ↔ 주문 상세 |
| 비식별 관계 | 부모의 PK가 자식의 일반 속성으로 들어감 | 점선 | 고객 ↔ 주문 |

> 💡 식별 관계는 “생명주기를 공유”하고, 비식별 관계는 “독립적”이에요.

---

### 🔹 5. 좋은 모델의 조건 — 완벽한 도시를 위한 체크리스트

| 조건 | 설명 |
|------|------|
| 완전성 | 필요한 데이터가 모두 들어 있음 |
| 중복 배제 | 같은 정보는 한 번만 저장 |
| 업무 규칙 표현 | 규칙이 명확하게 드러남 |
| 재사용성 | 다른 시스템에서도 활용 가능 |
| 의사소통 | 누구나 이해할 수 있음 |
| 통합성 | 같은 데이터는 한 번만 정의

---


좋아요 사장님! 기존 콘텐츠의 톤과 구조는 그대로 유지하면서, 제가 제안드린 SQLD 시험 대비 보완 포인트들을 **추가 확장**하는 방식으로 반영해드릴게요. 아래는 기존 문서에 이어 붙일 수 있는 **확장 파트**입니다. 원본은 건드리지 않고, 보완 내용을 따로 구성했어요:

---

## 🧩 모델링 탐정단의 비밀 수첩 — SQLD 시험 대비 확장편

---

### 🔹 6. 모델링 단계 — 개념 → 논리 → 물리

| 단계 | 설명 | 예시 |
|------|------|------|
| 개념 모델 | 업무 중심, 엔터티/관계 중심 | 고객은 주문을 한다 |
| 논리 모델 | DBMS 독립적, 정규화 적용 | 고객 테이블, 주문 테이블 |
| 물리 모델 | DBMS 종속적, 실제 구현 | PK/FK 설정, 인덱스 등 |

> 💡 암기 포인트: 개념은 “업무”, 논리는 “정규화”, 물리는 “구현”

---

### 🔹 7. ERD 표기법 — 관계를 표현하는 방식

| 표기법 | 특징 | 예시 |
|--------|------|------|
| 실선 | 식별 관계 | 주문 ↔ 주문 상세 |
| 점선 | 비식별 관계 | 고객 ↔ 주문 |
| Crow's Foot | 관계 방향과 차수 시각화 | 1:N 관계는 갈고리 모양 |

> 💡 SQLD에서는 Crow’s Foot 표기법이 자주 등장해요!

---

### 🔹 8. 정규화 실무 예시 — 현실적인 테이블 구조

#### ❌ 1NF 위반 예시
```plaintext
고객 테이블
┌───────┬───────────────┐
│ 고객ID │ 취미              │
├───────┼───────────────┤
│ 101     │ 독서, 음악       │
└───────┴───────────────┘
→ 취미 테이블로 분리 필요
```

#### ✅ 정규화 후 구조
```plaintext
고객 테이블
┌───────┐
│ 고객ID │
└───────┘

취미 테이블
┌───────┬──────┐
│ 고객ID │ 취미   │
└───────┴──────┘
```

---

### 🔹 9. SQLD 실무 연계 포인트

- 정규화는 성능과의 균형이 중요합니다.  
  → 지나친 정규화는 JOIN 비용을 높일 수 있어요.
- 식별 관계는 생명주기를 공유하므로  
  → 삭제 시 CASCADE 옵션을 고려해야 합니다.
- 외래키는 참조 무결성을 유지하지만  
  → 인덱스 설정 여부에 따라 성능이 달라질 수 있어요.



---

### 📌 기억하기 쉬운 요약 정리

- **엔터티**: 관리할 대상  
- **속성**: 대상의 특징  
- **관계**: 대상 간 연결  
- **정규화**: 중복 제거 기술  
- **식별자**: 기본키(PK), 외래키(FK), 보조식별자(AK)  
- **카디널리티**: 연결 수 (1:1, 1:N 등)  
- **참여도**: 필수/선택 여부  
- **모델링 단계**: 개념 → 논리 → 물리  
- **독립성**: 구조 변경 시 영향 없음  
- **엔터티 분류**: 유형/개념/사건, 기본/중심/행위  


 

---

### 🃏 모델링 탐정단 암기카드

```markdown
🃏 카드 1  
앞면: 엔터티(Entity)란?  
뒷면: 관리할 대상 (테이블)  
설명: 고객, 주문, 상품 등 현실 세계의 객체  
🔍 암기 포인트: “엔터티 = 테이블로 표현되는 대상”

🃏 카드 2  
앞면: 속성(Attribute)이란?  
뒷면: 엔터티의 특징 (컬럼)  
설명: 이름, 가격, 날짜 등  
🔍 암기 포인트: “속성 = 대상의 성질”

🃏 카드 3  
앞면: 관계(Relationship)란?  
뒷면: 엔터티 간의 연결  
설명: 고객은 주문을 한다  
🔍 암기 포인트: “관계 = 연결선”

🃏 카드 4  
앞면: 정규화의 목적은?  
뒷면: 중복 제거, 데이터 구조 정리  
설명: 데이터 무결성과 효율성 확보  
🔍 암기 포인트: “정규화 = 중복 제거 기술”

🃏 카드 5  
앞면: 1NF의 핵심 조건은?  
뒷면: 반복 속성 제거  
설명: 셀에 값 하나만  
🔍 암기 포인트: “1NF = 셀 안에 값 하나만”

🃏 카드 6  
앞면: 2NF의 핵심 조건은?  
뒷면: 부분 종속 제거  
설명: 키 일부에만 의존하는 속성 분리  
🔍 암기 포인트: “2NF = 키 일부에만 의존 ❌”

🃏 카드 7  
앞면: 3NF의 핵심 조건은?  
뒷면: 이행 종속 제거  
설명: 속성이 속성을 설명하면 분리  
🔍 암기 포인트: “3NF = 속성이 속성을 설명 ❌”

🃏 카드 8  
앞면: BCNF의 핵심 조건은?  
뒷면: 결정자가 후보키여야 함  
설명: 결정자가 후보키가 아니면 분해  
🔍 암기 포인트: “BCNF = 결정자 후보키 아니면 ❌”

🃏 카드 9  
앞면: 기본키(PK)의 특징은?  
뒷면: 고유값, 중복/NULL 불가  
설명: 주민번호, 주문번호 등  
🔍 암기 포인트: “PK = 이름표”

🃏 카드 10  
앞면: 외래키(FK)의 역할은?  
뒷면: 다른 테이블과 연결  
설명: 참조 무결성 유지  
🔍 암기 포인트: “FK = 테이블 간 다리”

🃏 카드 11  
앞면: 보조식별자(AK)란?  
뒷면: PK는 아니지만 유일한 값  
설명: 이메일, 전화번호 등  
🔍 암기 포인트: “AK = 예비 이름표”

🃏 카드 12  
앞면: 관계의 차수란?  
뒷면: 연결 수 (1:1, 1:N, N:M)  
설명: 고객 ↔ 주문 등  
🔍 암기 포인트: “차수 = 몇 명이 연결?”

🃏 카드 13  
앞면: 관계의 참여도란?  
뒷면: 필수/선택 여부  
설명: 고객은 반드시 주문 (필수), 직원은 프로젝트 참여 가능 (선택)  
🔍 암기 포인트: “참여도 = 꼭 연결돼야 하나?”

🃏 카드 14  
앞면: 엔터티 분류 기준은?  
뒷면: 형태 기준 / 시점 기준  
설명: 유형/개념/사건, 기본/중심/행위  
🔍 암기 포인트: “유·개·사 / 기·중·행”

🃏 카드 15  
앞면: 속성의 구조 기준은?  
뒷면: 단일 / 복합 / 다중값  
설명: 이름 / 주소 / 취미  
🔍 암기 포인트: “다중값 = 1NF 위반”

🃏 카드 16  
앞면: 식별자 생성 기준은?  
뒷면: 본질 / 인조 식별자  
설명: 주민번호 / 고객번호  
🔍 암기 포인트: “본질 = 원래 있던 값 / 인조 = 새로 만든 값”

🃏 카드 17  
앞면: 식별 관계란?  
뒷면: 부모의 PK가 자식의 PK에 포함됨  
설명: 실선으로 표현  
🔍 암기 포인트: “식별 관계 = 생명주기 공유”

🃏 카드 18  
앞면: 비식별 관계란?  
뒷면: 부모의 PK가 자식의 일반 속성으로 들어감  
설명: 점선으로 표현  
🔍 암기 포인트: “비식별 관계 = 독립적 연결”

🃏 카드 19  
앞면: 좋은 모델의 조건은?  
뒷면: 완전성, 중복 배제, 재사용성 등  
설명: 유지보수와 의사소통에 유리  
🔍 암기 포인트: “좋은 모델 = 완·중·재·통·의·업”

🃏 카드 20  
앞면: 데이터 독립성이란?  
뒷면: 구조 변경 시 영향 최소화  
설명: 논리적 / 물리적 독립성  
🔍 암기 포인트: “독립성 = 구조 바꿔도 영향 없음”
```

---

### 📘 대표 기출 문제

🧪 문제 1  
다음 중 1NF를 만족하지 않는 경우는?  
① 고객ID가 고유하다  
② 주소가 시/구/동으로 나뉘어 있다  
③ 취미가 “독서, 음악”으로 한 셀에 들어 있다  
④ 이름이 단일 값이다  
✅ 정답: ③  
🔍 암기 포인트: “1NF = 셀 안에 값 하나만”

🧪 문제 2  
다음 중 외래키(FK)의 역할은?  
① 테이블의 고유값을 지정한다  
② 다른 테이블과 연결한다  
③ 속성의 이름을 바꾼다  
④ 테이블을 삭제한다  
✅ 정답: ②  
🔍 암기 포인트: “FK = 테이블 간 다리”

🧪 문제 3  
다음 중 식별 관계의 특징은?  
① 부모의 PK가 자식의 일반 속성으로 들어감  
② 생명주기를 공유하지 않음  
③ ERD에서 점선으로 표현  
④ 부모의 PK가 자식의 PK에 포함됨  
✅ 정답: ④  
🔍 암기 포인트: “식별 관계 = 실선 + PK 공유”
 

🧪 문제 4  
다음 중 2NF를 만족하지 않는 경우는?  
① 모든 속성이 전체 키에 종속된다  
② 일부 속성이 키의 일부에만 종속된다  
③ 속성이 키 전체에 종속된다  
④ 키가 아닌 속성이 키 전체에 종속된다  
✅ 정답: ②  
🔍 암기 포인트: “2NF = 키 일부에만 의존 ❌”

🧪 문제 5  
다음 중 논리 모델의 특징은?  
① DBMS에 따라 달라진다  
② 업무 흐름을 중심으로 한다  
③ 정규화를 적용한다  
④ 인덱스를 설정한다  
✅ 정답: ③  
🔍 암기 포인트: “논리 모델 = 정규화 적용”

🧪 문제 6  
다음 중 Crow’s Foot 표기법에 대한 설명으로 옳은 것은?  
① 관계를 실선과 점선으로 표현한다  
② 관계의 방향성과 차수를 시각적으로 표현한다  
③ 엔터티의 속성을 표현한다  
④ 정규화 단계를 나타낸다  
✅ 정답: ②  
🔍 암기 포인트: “Crow’s Foot = 관계 방향 + 차수 시각화”

 
---

## 🧾 Episode 2: 정보 탐험대 — SQL 쿼리의 여정 (균형 확장판)

정보 탐험대는 도시 곳곳에 숨겨진 정보를 찾아내는 전문가들이었어요.  
그들의 무기는 바로 **SQL 쿼리**!  
이들은 SELECT 주문서를 들고, WHERE 조건을 붙이고, JOIN 마법으로 연결하며,  
GROUP BY로 정보를 묶고, 윈도우 함수로 시간의 흐름을 분석했죠.

---

### 🎯 왜 필요한가?

SQL은 데이터베이스와 대화하는 언어예요.  
- 정보를 꺼내고, 수정하고, 삭제하고, 추가하는 모든 작업은 SQL로 이루어져요.  
- SQL을 잘 다루면, 데이터 도시의 **모든 비밀을 자유롭게 탐험**할 수 있어요.

---

### 🔍 탐험대의 기술 요약

| 기술 | 설명 | 예시 |
|------|------|------|
| **SELECT** | 원하는 정보 조회 | “이름과 주소 알려줘!” |
| **WHERE** | 조건 필터링 | “서울에 사는 사람만 보여줘!” |
| **JOIN** | 테이블 연결 | “고객 정보와 주문 내역을 연결해줘!” |
| **GROUP BY + HAVING** | 그룹화 + 조건 | “지역별로 주문 수를 세고, 10건 이상인 곳만 보여줘!” |
| **서브쿼리** | 쿼리 안의 쿼리 | IN, EXISTS, NOT EXISTS — 조건을 더 정교하게! |
| **스칼라 서브쿼리** | 단일 값 반환 | SELECT 이름, (SELECT 부서명 FROM 부서 ...) |
| **윈도우 함수** | 행별 계산 | ROW_NUMBER(), RANK(), DENSE_RANK() |
| **OVER()** | 그룹 내 순서 지정 | OVER(PARTITION BY … ORDER BY …) |

---

### 🧠 실전에서 자주 나오는 포인트

| 항목 | 설명 |
|------|------|
| **집계 함수** | COUNT(*), AVG(), SUM(), MIN(), MAX() — 필수 |
| **NULL 처리** | IS NULL, COALESCE, NVL — 조건과 집계 시 중요 |
| **DML** | INSERT, UPDATE, DELETE — 트랜잭션과 연결됨 |
| **DDL** | CREATE, ALTER, DROP — 테이블 구조 변경 |
| **트랜잭션 제어** | COMMIT, ROLLBACK — 작업 단위 관리 |
| **윈도우 함수** | 순위, 누적합, 이전/다음 행 값 분석 |

---

### 📌 기억하기 쉬운 요약 정리

- **SELECT**: 꺼내기  
- **WHERE**: 필터링  
- **JOIN**: 연결  
- **GROUP BY**: 묶기  
- **HAVING**: 그룹 조건  
- **서브쿼리**: 쿼리 안의 쿼리  
- **윈도우 함수**: 행별 분석  
- **DML/DDL**: 데이터 조작/구조 변경  
- **트랜잭션**: 작업 묶음 관리
  
 
---

### 🃏 정보 탐험대 암기카드

```markdown
🃏 카드 21  
앞면: SELECT 문의 역할은?  
뒷면: 원하는 정보 조회  
설명: 테이블에서 특정 컬럼을 꺼냄  
🔍 암기 포인트: “SELECT = 꺼내기”

🃏 카드 22  
앞면: WHERE 절의 기능은?  
뒷면: 조건 필터링  
설명: 특정 조건에 맞는 행만 조회  
🔍 암기 포인트: “WHERE = 필터링”

🃏 카드 23  
앞면: JOIN의 목적은?  
뒷면: 테이블 연결  
설명: 두 테이블의 관련 데이터를 합침  
🔍 암기 포인트: “JOIN = 연결”

🃏 카드 24  
앞면: GROUP BY의 기능은?  
뒷면: 그룹화  
설명: 같은 값을 가진 행들을 묶음  
🔍 암기 포인트: “GROUP BY = 묶기”

🃏 카드 25  
앞면: HAVING 절은 언제 사용하나요?  
뒷면: 그룹 조건 필터링  
설명: GROUP BY 이후 조건 지정  
🔍 암기 포인트: “HAVING = 그룹 필터”

🃏 카드 26  
앞면: 서브쿼리란?  
뒷면: 쿼리 안의 쿼리  
설명: SELECT, WHERE, FROM 등에서 사용  
🔍 암기 포인트: “서브쿼리 = 쿼리 속 쿼리”

🃏 카드 27  
앞면: 스칼라 서브쿼리란?  
뒷면: 단일 값 반환  
설명: SELECT 절에서 사용 가능  
🔍 암기 포인트: “스칼라 = 하나의 값”

🃏 카드 28  
앞면: IN과 EXISTS의 차이는?  
뒷면: IN은 값 비교, EXISTS는 존재 여부 확인  
설명: EXISTS는 성능이 더 좋을 수 있음  
🔍 암기 포인트: “EXISTS = 존재 확인”

🃏 카드 29  
앞면: 윈도우 함수란?  
뒷면: 행별 계산 함수  
설명: GROUP 없이도 집계 가능  
🔍 암기 포인트: “윈도우 함수 = 행별 분석”

🃏 카드 30  
앞면: RANK와 DENSE_RANK의 차이는?  
뒷면: RANK는 건너뛰고, DENSE_RANK는 연속  
설명: 동점 처리 방식이 다름  
🔍 암기 포인트: “RANK = 건너뜀 / DENSE = 연속”

🃏 카드 31  
앞면: ROW_NUMBER 함수의 역할은?  
뒷면: 행 번호 부여  
설명: 순서대로 번호 매김  
🔍 암기 포인트: “ROW_NUMBER = 번호 매기기”

🃏 카드 32  
앞면: OVER 절의 기능은?  
뒷면: 윈도우 함수의 범위 지정  
설명: PARTITION BY, ORDER BY 포함  
🔍 암기 포인트: “OVER = 분석 범위”

🃏 카드 33  
앞면: COUNT(*)는 무엇을 세나요?  
뒷면: 전체 행 수  
설명: NULL 포함  
🔍 암기 포인트: “COUNT(*) = 전체 행”

🃏 카드 34  
앞면: COALESCE 함수의 역할은?  
뒷면: NULL 대체  
설명: NULL이면 지정한 값으로 대체  
🔍 암기 포인트: “COALESCE = NULL 처리”

🃏 카드 35  
앞면: INSERT 문의 기능은?  
뒷면: 데이터 추가  
설명: 테이블에 새 행 삽입  
🔍 암기 포인트: “INSERT = 추가”

🃏 카드 36  
앞면: UPDATE 문의 기능은?  
뒷면: 데이터 수정  
설명: 기존 행의 값을 변경  
🔍 암기 포인트: “UPDATE = 수정”

🃏 카드 37  
앞면: DELETE 문의 기능은?  
뒷면: 데이터 삭제  
설명: 조건에 맞는 행 제거  
🔍 암기 포인트: “DELETE = 삭제”

🃏 카드 38  
앞면: COMMIT의 역할은?  
뒷면: 변경 내용 저장  
설명: 트랜잭션 완료  
🔍 암기 포인트: “COMMIT = 저장”

🃏 카드 39  
앞면: ROLLBACK의 역할은?  
뒷면: 변경 내용 취소  
설명: 트랜잭션 되돌리기  
🔍 암기 포인트: “ROLLBACK = 취소”

🃏 카드 40  
앞면: DDL 명령어의 종류는?  
뒷면: CREATE, ALTER, DROP  
설명: 테이블 구조 변경  
🔍 암기 포인트: “DDL = 구조 변경”
```

---

### 📘 대표 기출 문제 예시

🧪 문제 1  
다음 중 SELECT 문의 기능은?  
① 테이블 삭제  
② 데이터 조회  
③ 데이터 수정  
④ 트랜잭션 저장  
✅ 정답: ②  
🔍 암기 포인트: “SELECT = 꺼내기”

🧪 문제 2  
GROUP BY와 함께 사용되는 조건 필터링 절은?  
① WHERE  
② HAVING  
③ ORDER BY  
④ FROM  
✅ 정답: ②  
🔍 암기 포인트: “GROUP BY 이후 = HAVING”

🧪 문제 3  
윈도우 함수에서 순위를 건너뛰는 함수는?  
① DENSE_RANK  
② RANK  
③ ROW_NUMBER  
④ COUNT  
✅ 정답: ②  
🔍 암기 포인트: “RANK = 건너뜀”

🧪 문제 4  
다음 중 트랜잭션을 저장하는 명령은?  
① ROLLBACK  
② DELETE  
③ COMMIT  
④ SELECT  
✅ 정답: ③  
🔍 암기 포인트: “COMMIT = 저장”

🧪 문제 5  
서브쿼리에서 단일 값을 반환하는 유형은?  
① 인라인 뷰  
② 스칼라 서브쿼리  
③ 다중행 서브쿼리  
④ 다중열 서브쿼리  
✅ 정답: ②  
🔍 암기 포인트: “스칼라 = 하나의 값”

---



---

## 🛡️ Episode 3: 시스템 수호국 — 데이터의 질서를 지키는 자 (보완 확장판)

도시의 질서를 지키는 **시스템 수호국**은  
데이터의 안정성과 보안을 책임졌어요.  
그들은 보이지 않는 곳에서 도시의 기반을 지키며,  
모든 정보가 정확하고 일관되게 유지되도록 힘썼답니다.

---

### 🎯 왜 필요한가?

데이터는 도시의 생명줄이자 가장 민감한 자산이에요.  
- 잘못 다루면 손실, 오류, 보안 문제까지 생길 수 있어요.  
- 시스템 수호국은 **데이터의 무결성과 안정성**을 지키는 마지막 방어선입니다.

> 이들은 단순한 관리자들이 아니라, **데이터 도시의 헌법을 집행하는 수호자들**이에요.

---

### 🔍 수호국의 법령 요약

#### 🧠 트랜잭션의 4대 원칙 (ACID)

| 원칙 | 설명 |
|------|------|
| **Atomicity** | 작업은 전부 성공하거나 전부 실패해야 함 |
| **Consistency** | 데이터는 항상 일관된 상태 유지 |
| **Isolation** | 동시에 실행돼도 결과는 동일해야 함 |
| **Durability** | 커밋된 데이터는 영구 저장 |

> 시험에서는 트랜잭션 흐름, COMMIT/ROLLBACK 시점, 격리 수준이 자주 출제돼요.

---

#### 🔍 인덱스 감시탑

| 항목 | 설명 |
|------|------|
| **구조** | B-Tree 기반 |
| **장점** | 검색 속도 향상, 정렬 최적화 |
| **단점** | INSERT/UPDATE 시 성능 저하 가능성 |
| **종류** | 단일 인덱스, 복합 인덱스, 클러스터 인덱스 |

> 시험에서는 인덱스의 장단점, 사용 시기, 실행계획과의 연결이 중요해요.

---

#### 🪟 뷰(View) 창문

| 항목 | 설명 |
|------|------|
| **정의** | SELECT 결과를 저장한 가상 테이블 |
| **장점** | 보안 강화, 복잡한 쿼리 단순화, 재사용 |
| **제한사항** | 일부 뷰는 수정 불가 (읽기 전용) |
| **업데이트 가능 조건** | 단일 테이블 기반, 집계 함수 없음 등 |

> 시험에서는 뷰의 정의, 장단점, 수정 가능 여부가 자주 출제돼요.

---

#### 📋 제약조건 법령

| 제약조건 | 설명 |
|----------|------|
| **PRIMARY KEY** | 고유 식별자, 중복/NULL 불가 |
| **FOREIGN KEY** | 다른 테이블 참조, 참조 무결성 유지 |
| **UNIQUE** | 중복 불가, NULL 허용 |
| **NOT NULL** | 반드시 값이 있어야 함 |
| **CHECK** | 조건 만족 여부 검사 (예: 급여 > 0) |

> 시험에서는 제약조건의 특징 비교, 적용 시점, 오류 발생 조건이 자주 나와요.

---

### 🧩 무결성의 수호자들

| 유형 | 설명 |
|------|------|
| **도메인 무결성** | 속성 값이 정의된 범위 내에 있어야 함 |
| **엔터티 무결성** | 기본키는 NULL이거나 중복되면 안 됨 |
| **참조 무결성** | 외래키는 반드시 부모 테이블의 값과 일치해야 함 |

> 이들은 데이터 품질을 지키는 **헌법 수호자**들이에요.

---

### 📌 기억하기 쉬운 요약 정리

- **트랜잭션**: 작업 묶음  
- **ACID**: 안정성의 4대 원칙  
- **인덱스**: 검색 속도 향상  
- **뷰(View)**: 가상 테이블  
- **제약조건**: 데이터 규칙  
- **무결성**: 품질 보장



---

### 🃏 시스템 수호국 암기카드

```markdown
🃏 카드 41  
앞면: 트랜잭션이란?  
뒷면: 작업의 논리적 단위  
설명: 여러 작업을 하나로 묶어 처리  
🔍 암기 포인트: “트랜잭션 = 묶음 처리”

🃏 카드 42  
앞면: ACID 중 Atomicity란?  
뒷면: 전부 성공 또는 전부 실패  
설명: 중간 실패 시 전체 취소  
🔍 암기 포인트: “Atomic = 올 or Nothing”

🃏 카드 43  
앞면: ACID 중 Consistency란?  
뒷면: 데이터의 일관성 유지  
설명: 규칙 위반 없이 상태 유지  
🔍 암기 포인트: “Consistency = 규칙 지키기”

🃏 카드 44  
앞면: ACID 중 Isolation이란?  
뒷면: 동시에 실행돼도 결과 동일  
설명: 트랜잭션 간 간섭 방지  
🔍 암기 포인트: “Isolation = 독립 실행”

🃏 카드 45  
앞면: ACID 중 Durability란?  
뒷면: 커밋된 데이터는 영구 저장  
설명: 장애 발생해도 유지됨  
🔍 암기 포인트: “Durability = 저장 보장”

🃏 카드 46  
앞면: 인덱스의 주요 목적은?  
뒷면: 검색 속도 향상  
설명: B-Tree 구조로 빠른 탐색  
🔍 암기 포인트: “인덱스 = 검색 가속기”

🃏 카드 47  
앞면: 인덱스의 단점은?  
뒷면: 쓰기 성능 저하  
설명: INSERT/UPDATE 시 부하 발생  
🔍 암기 포인트: “인덱스 = 읽기 빠름, 쓰기 느림”

🃏 카드 48  
앞면: 뷰(View)란?  
뒷면: SELECT 결과를 저장한 가상 테이블  
설명: 실제 데이터는 저장하지 않음  
🔍 암기 포인트: “뷰 = 가상의 창문”

🃏 카드 49  
앞면: 뷰의 장점은?  
뒷면: 보안 강화, 쿼리 단순화  
설명: 복잡한 쿼리를 감추고 재사용 가능  
🔍 암기 포인트: “뷰 = 보안 + 재사용”

🃏 카드 50  
앞면: PRIMARY KEY의 특징은?  
뒷면: 중복/NULL 불가  
설명: 테이블의 고유 식별자  
🔍 암기 포인트: “PK = 고유 이름표”

🃏 카드 51  
앞면: FOREIGN KEY의 역할은?  
뒷면: 참조 무결성 유지  
설명: 다른 테이블의 PK를 참조  
🔍 암기 포인트: “FK = 연결 다리”

🃏 카드 52  
앞면: UNIQUE 제약조건이란?  
뒷면: 중복 불가, NULL 허용  
설명: 이메일 등 고유값에 사용  
🔍 암기 포인트: “UNIQUE = 중복 ❌, NULL 가능”

🃏 카드 53  
앞면: NOT NULL 제약조건이란?  
뒷면: 반드시 값이 있어야 함  
설명: 필수 입력 필드에 사용  
🔍 암기 포인트: “NOT NULL = 빈칸 금지”

🃏 카드 54  
앞면: CHECK 제약조건이란?  
뒷면: 조건 만족 여부 검사  
설명: 급여 > 0 등  
🔍 암기 포인트: “CHECK = 조건 필터”

🃏 카드 55  
앞면: 도메인 무결성이란?  
뒷면: 값이 정의된 범위 내에 있어야 함  
설명: 데이터 형식과 범위 제한  
🔍 암기 포인트: “도메인 = 값의 규칙”

🃏 카드 56  
앞면: 엔터티 무결성이란?  
뒷면: 기본키는 NULL/중복 불가  
설명: 고유 식별자 유지  
🔍 암기 포인트: “엔터티 = 고유성 유지”

🃏 카드 57  
앞면: 참조 무결성이란?  
뒷면: 외래키는 부모 테이블 값과 일치  
설명: 연결된 데이터의 일관성  
🔍 암기 포인트: “참조 = 연결된 값 일치”

🃏 카드 58  
앞면: COMMIT의 기능은?  
뒷면: 변경 내용 저장  
설명: 트랜잭션 완료  
🔍 암기 포인트: “COMMIT = 저장”

🃏 카드 59  
앞면: ROLLBACK의 기능은?  
뒷면: 변경 내용 취소  
설명: 트랜잭션 되돌리기  
🔍 암기 포인트: “ROLLBACK = 취소”

🃏 카드 60  
앞면: DDL 명령어는?  
뒷면: CREATE, ALTER, DROP  
설명: 테이블 구조 변경  
🔍 암기 포인트: “DDL = 구조 변경”
```
 
 
---

### 📘 대표 기출 문제 예시  
📘 Chapter 03. 시스템 수호국 — 데이터의 질서를 지키는 자

---

🧪 문제 1  
트랜잭션의 원자성(Atomicity)이란?  
① 작업을 순서대로 실행하는 것  
② 작업이 모두 성공하거나 모두 실패해야 함  
③ 작업 중 일부만 저장하는 것  
④ 작업을 병렬로 실행하는 것  
✅ 정답: ②  
💡 해설: 트랜잭션은 하나의 단위로 처리되며, 중간 실패 시 전체 취소됩니다.  
🔍 암기 포인트: “Atomic = 올 or Nothing”

---

🧪 문제 2  
인덱스를 사용하는 주요 목적은?  
① 데이터 삭제 속도 향상  
② 검색 속도 향상  
③ 데이터 암호화  
④ 트랜잭션 관리  
✅ 정답: ②  
💡 해설: 인덱스는 B-Tree 구조로 빠른 탐색을 가능하게 해줍니다.  
🔍 암기 포인트: “인덱스 = 검색 가속기”

---

🧪 문제 3  
뷰(View)의 특징으로 옳은 것은?  
① 데이터를 직접 저장한다  
② 여러 테이블을 삭제한다  
③ SELECT 결과를 저장한 가상 테이블이다  
④ 트랜잭션을 관리한다  
✅ 정답: ③  
💡 해설: 뷰는 실제 데이터를 저장하지 않고, SELECT 결과를 보여주는 창문 같은 역할을 합니다.  
🔍 암기 포인트: “뷰 = 가상의 창문”

---

🧪 문제 4  
다음 중 외래키(FK)의 역할은?  
① 테이블의 고유값을 지정한다  
② 다른 테이블과 연결한다  
③ 속성의 이름을 바꾼다  
④ 테이블을 삭제한다  
✅ 정답: ②  
💡 해설: 외래키는 참조 무결성을 유지하며, 다른 테이블의 PK를 참조합니다.  
🔍 암기 포인트: “FK = 연결 다리”

---

🧪 문제 5  
도메인 무결성(Domain Integrity)이란?  
① 기본키가 중복되지 않도록 하는 것  
② 외래키가 부모 테이블과 일치하는 것  
③ 속성 값이 정의된 범위 내에 있어야 하는 것  
④ 트랜잭션을 모두 성공시키는 것  
✅ 정답: ③  
💡 해설: 도메인 무결성은 속성 값이 지정된 형식과 범위 내에 있어야 함을 의미합니다.  
🔍 암기 포인트: “도메인 = 값의 규칙”

---

🧪 문제 6  
트랜잭션을 취소하고 이전 상태로 되돌리는 명령은?  
① COMMIT  
② ROLLBACK  
③ DELETE  
④ ALTER  
✅ 정답: ②  
💡 해설: ROLLBACK은 트랜잭션 중 변경된 내용을 취소하고 원래 상태로 되돌립니다.  
🔍 암기 포인트: “ROLLBACK = 취소”

---

🧪 문제 7  
다음 중 제약조건에 해당하지 않는 것은?  
① PRIMARY KEY  
② FOREIGN KEY  
③ SELECT  
④ CHECK  
✅ 정답: ③  
💡 해설: SELECT는 데이터를 조회하는 SQL 명령어이며, 제약조건이 아닙니다.  
🔍 암기 포인트: “제약조건 = PK, FK, UNIQUE, NOT NULL, CHECK”

---

🧪 문제 8  
UNIQUE 제약조건의 특징은?  
① 중복 허용, NULL 불가  
② 중복 불가, NULL 허용  
③ 중복 불가, NULL 불가  
④ 중복 허용, NULL 허용  
✅ 정답: ②  
💡 해설: UNIQUE는 중복을 허용하지 않지만, NULL은 허용합니다.  
🔍 암기 포인트: “UNIQUE = 중복 ❌, NULL 가능”

---

🧪 문제 9  
트랜잭션의 일관성(Consistency)이란?  
① 작업이 빠르게 끝나는 것  
② 데이터가 항상 유효한 상태를 유지하는 것  
③ 작업을 병렬로 실행하는 것  
④ 데이터를 암호화하는 것  
✅ 정답: ②  
💡 해설: 일관성은 트랜잭션 전후에 데이터가 규칙을 만족하는 상태를 유지하는 것을 의미합니다.  
🔍 암기 포인트: “Consistency = 규칙 지키기”

---

🧪 문제 10  
CHECK 제약조건의 용도는?  
① 테이블 삭제  
② 속성 값이 조건을 만족하는지 검사  
③ 속성 이름 변경  
④ 트랜잭션 저장  
✅ 정답: ②  
💡 해설: CHECK는 속성 값이 특정 조건을 만족하는지 확인하는 제약조건입니다.  
🔍 암기 포인트: “CHECK = 조건 필터”
```
 


---

### 🎓 마무리: SQLD는 이 도시의 시민증

이 도시를 이해하고, 설계하고, 탐험하고,  
그리고 **지킬 수 있는 사람만이**  
**SQLD 시민증(자격증)**을 받을 수 있어요.
 