<style>
pre, code {
  white-space: pre-wrap !important;
  word-break: break-word !important;
  overflow-x: hidden !important;
  display: block !important;
  max-width: 100% !important;
  box-sizing: border-box !important;
}
</style> 


---

```bash
[문제 1]  
모델링은 현실세계를 표현하는 것으로 이해할 수 있다. 다음 중 모델링의 특징으로 가장 부적절한 것은?

① 현실세계를 일정한 형식의 모델로 표현하는 추상화의 의미를 가짐  
② 시스템 구현만을 위해 진행하는 사전단계의 작업으로서 데이터베이스 구축을 위한 사전 작업의 의미만 가짐  
③ 복잡한 현실을 제한된 언어나 표기방법을 통해 쉽게 이해할 수 있는 단순화 의미를 가짐  
④ 현실세계를 일정한 형식으로 누구나 이해가 가능하도록 정확하게 현상을 기술하는 정확화 의미를 가짐  
```

**정답:** ②

**해설:**  
옛날에 마을 사람들이 복잡한 세상을 쉽게 설명하려고 그림을 그리기 시작했어요.  이 그림은 누구나 이해할 수 있게 만든 거예요.  그런데 어떤 사람이 말했어요. “이건 컴퓨터 만들려고 그리는 거야!”  마을 사람들은 말했어요. “아니야, 이건 세상을 쉽게 설명하려고 그리는 거야!”  그래서 그 사람의 말은 틀렸다고 했어요.

**보기 설명:**  
① 추상화: 복잡한 걸 간단하게 표현  
② 시스템만 위한 그림: 너무 좁게 생각함 (❌)  
③ 단순화: 이해하기 쉽게 표현  
④ 정확화: 누구나 알아볼 수 있게 표현

🧸 **쉬운 해설:**  
모델링은 세상을 쉽게 설명하는 그림이야.  
②번은 “그림은 오직 컴퓨터 만들려고 그리는 거야!”라고 말하는데, 너무 좁게 본 거야!

🧠 **기억법:**  
모델링의 3대 특징은 **추단정**  
→ 추상화, 단순화, 정확화  
❌ 시스템 구현만을 위한 작업은 아님!

**필요 암기카드:**  
- 🃏 카드 1: 모델링 = 현실을 추상화하여 표현하는 기술  
- 🃏 카드 19: 좋은 모델 = 완·중·재·통·의·업

---

```bash
[문제 2]  
다음 설명 중 데이터 모델링이 필요한 주요 이유로 가장 부적절한 것은?

① 업무규모를 구성하는 기초가 되는 정보를 대체 일정한 표기방법에 의해 표현함.  
② 분석된 결과물을 가지고 데이터베이스를 설계할 수 있는 기초 자료로 사용하기 위함.  
③ 데이터베이스를 구축하기 위한 용도를 위해 데이터모델링을 수행하고 업무에 대한 설명은 별도로 표기방법을 이용한다.  
④ 데이터모델링은 자료로서의 업무를 설명하고 분석하는 부분에 의미를 가지고 있다.  
```

**정답:** ③

**해설:**  
사람들이 일을 정리하려고 정보를 예쁘게 정리하는 표를 만들었어요.  이 표는 일을 설명하고, 분석도 할 수 있었죠.  그런데 누군가 말했어요. “일은 따로 설명하고, 표는 그냥 컴퓨터용이야!”  모두가 말했어요. “아니야, 이 표는 일을 설명하는 데도 쓰이는 거야!”  
그래서 그 말은 틀렸다고 했어요.

**보기 설명:**  
① 정보 표현: 표로 정보를 보여줘요  
② 설계 기초: 표를 보고 컴퓨터 설계해요  
③ 업무 설명은 별도: 일은 따로 설명해요 (❌)  
④ 업무 분석: 표로 일을 분석해요

🧸 **쉬운 해설:**  
데이터모델링은 일도 설명하는 표야.  
③번은 “일은 따로 설명하고 표는 그냥 컴퓨터용이야!”라고 말하는데, 그건 틀렸어!

🧠 **기억법:**  
데이터모델링은 **설명 + 분석 + 설계**  
→ 업무 설명을 빼면 틀린 설명!


**필요 암기카드:**  
- 🃏 카드 1: 모델링 = 현실을 추상화하여 표현하는 기술  
- 🃏 카드 19: 좋은 모델 = 완·중·재·통·의·업

---

```bash
[문제 3]  
다음 중 데이터모델링을 할 때 유의해야 할 사항으로 가장 부적절한 것은?

① 여러 장소의 데이터베이스에 같은 정보를 저장하지 않도록 하여 중복을 최소화한다.  
② 데이터의 정의를 데이터의 사용 프로세스와 분리하여 독립성을 높인다.  
③ 사용자가 처리하는 프로세스나 정보 등에 따라 매번 달라질 수 있도록 프로그램과 데이터베이스의 관계를 늘 높인다.  
④ 데이터 간의 상호 연관관계를 명확하게 정의하여 일관성 있게 데이터를 유지되도록 한다.  
```

**정답:** ③

**해설:**  
정보를 정리하는 마을이 있었어요.  
사람들은 정보를 깔끔하게 정리해서 헷갈리지 않게 만들었죠.  
그런데 어떤 사람이 말했어요. “정보는 매번 바뀌게 만들자!”  
모두가 말했어요. “그럼 너무 복잡해져서 아무도 못 써!”  
그래서 그 말은 틀렸다고 했어요.

**보기 설명:**  
① 중복 최소화: 같은 걸 여러 번 안 써요  
② 독립성 강화: 정보랑 사용법을 따로 해요  
③ 관계 늘리기: 너무 자주 바뀌게 해요 (❌)  
④ 일관성 유지: 항상 똑같이 유지해요

🧸 **쉬운 해설:**  
정보는 깔끔하게 정리해서 헷갈리지 않게 해야 해.  
③번은 “정보는 자꾸 바뀌게 만들자!”고 해서 틀렸어!

🧠 **기억법:**  
데이터모델링의 핵심은 **중독일**  
→ 중복 최소화, 독립성, 일관성 유지  
❌ 관계를 늘려서 복잡하게 만들면 안 돼!
 
**필요 암기카드:**  
- 🃏 카드 19: 좋은 모델 = 완·중·재·통·의·업  
- 🃏 카드 66: 도메인 무결성 = 값의 규칙  
- 🃏 카드 67: 엔터티 무결성 = 고유성 유지 
 

 
---
```bash
[문제 4]  
다음 중 아래 설명이 의미하는 데이터모델링의 유의점에 해당하는 특성은 무엇인가?

> 데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경되므로 유연성의 어려움을 가중시킬 수 있다. 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델은 데이터 혹은 프로세스의 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄일 수 있다.

① 중복 ② 비유연성 ③ 비일관성 ④ 일관성
```


**정답:** ②

**해설:**  
어떤 마을에서 정보를 정리하는 표를 만들었어요.  
그런데 표가 너무 딱딱하게 만들어져서, 일이 조금만 바뀌어도 표를 다시 만들어야 했어요.  
사람들은 말했어요. “이건 너무 유연하지 못해!”  
그래서 이 표는 ‘비유연성’이라는 특징을 가진다고 했어요.

**보기 설명:**  
① 중복: 같은 정보가 여러 번 나와요  
② 비유연성: 조금만 바뀌어도 다시 만들어야 해요  
③ 비일관성: 내용이 들쭉날쭉해요  
④ 일관성: 항상 똑같고 정돈돼 있어요  

🧸 **쉬운 해설:**  
②번은 “표가 너무 딱딱해서 조금만 바뀌어도 다시 만들어야 해!”라는 뜻이야.  
그래서 정답이야!

🧠 **기억법:**  
데이터모델링은 **유연성**이 중요!  
비유연성은 업무 변화에 약한 구조!

**필요 암기카드:**  
- 🃏 카드 19: 좋은 모델 = 완·중·재·통·의·업


---

```bash
[문제 5]  
다음 중 아래 데이터모델링 개념에 대한 설명에서 (가) , (나)에 들어갈 단어로 가장 적절한 것은?

> 전사적 데이터 모델링을 수행할 때 많이 하며, 추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링을 진행하는 것을 (가)  데이터 모델링이라고 한다. 이후 논리적 설계로 데이터베이스에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려한 데이터 모델링을 (나)데이터모델링이라고 한다.

① (가)=개념적, (나)=물리적  
② (가)=논리적, (나)=개념적  
③ (가)=논리적, (나)=물리적  
④ (가)=개념적, (나)=논리적
```

**정답:** ①

**해설:**  
먼저 마을 전체를 그리는 큰 그림을 그려요.  
그다음, 그림을 실제로 만들기 위해 저장소나 성능을 생각해요.  
처음은 개념적, 나중은 물리적이에요!

**보기 설명:**  
① 개념적: 큰 그림을 그려요  
② 논리적: 구조를 정리해요  
③ 물리적: 저장과 성능을 생각해요  
④ 논리적: 실제 설계에 가까워요  

🧸 **쉬운 해설:**  
①번은 “먼저 큰 그림 그리고, 그다음 저장소에 맞게 조정하는 거야!”라는 뜻이야!

🧠 **기억법:**  
모델링 단계는 **개→논→물** 순서!  
개념적 → 논리적 → 물리적

**필요 암기카드:**  
- 🃏 카드 20: 모델링 단계 = 개념 → 논리 → 물리


---
```bash
[문제 6]  
다음 중 ANSI-SPARC에서 정의한 3단계구조(three-level architecture)에서 아래 내용이 설명하는 스키마구조로 가장 적절한 것은?

> * 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현  
> * 모든 응용시스템이나 사용자들의 필요를 하나의 데이터로 통합한 전체적 DB를 기술한 것  
> * DB의 개체들, 속성들, 관계를 정의하고 데이터 그룹 간의 관계를 표현하는 스키마

① 외부스키마 (External Schema)  
② 개념스키마 (Conceptual Schema)  
③ 내부스키마 (Internal Schema)  
④ 논리스키마 (Logical Schema)
```

**정답:** ②

**해설:**  
모든 사람의 관점을 하나로 모은 그림을 ‘개념스키마’라고 해요.  
이건 전체 조직을 위한 큰 그림이에요.

**보기 설명:**  
① 외부스키마: 개인용 그림이에요  
② 개념스키마: 모두를 위한 큰 그림이에요  
③ 내부스키마: 저장소 중심 그림이에요  
④ 논리스키마: 실제 용어엔 없어요  

🧸 **쉬운 해설:**  
②번은 “모든 사람의 관점을 하나로 모은 그림”이야!

🧠 **기억법:**  
ANSI-SPARC 3단계: **외→개→내**  
외부(사용자) → 개념(전체) → 내부(저장)

1. ANSI-SPARC 3단계 - DB 시스템의 구조적 계층 설명 - 사용자 화면 → ERD → 저장 구조
2. 모델링 단계       - DB를 설계하는 절차 - 요구사항 분석 → ERD → 테이블/인덱스 설계

**필요 암기카드:**  
- 🃏 카드 20: 모델링 단계 = 개념 → 논리 → 물리


---

```bash
[문제 7]  
다음 중 고객과 주문의 ERD에 대한 설명으로 가장 부적절한 것은?

① 한 명의 고객은 여러 개의 제품을 주문할 수 있다. 주문은 할 수도 있고 안 할 수도 있다.  
② 하나의 주문은 반드시 한 명의 고객에 의해 주문된다.  
③ 주문의 데이터를 입력할 때는 반드시 고객데이터가 존재해야 한다.  
④ 고객의 데이터를 입력할 때는 주문데이터가 존재하는 고객만을 입력할 수 있다.
```
```mermaid
erDiagram
    CUSTOMER {
        int 고객번호 PK
        string 고객이름
    }
    ORDER {
        int 주문번호 PK
        int 고객번호 FK
        int 주문수량
    }

    CUSTOMER ||--o{ ORDER : "주문"
```

① 한 명의 고객은 여러 개의 제품을 주문할 수 있다. 주문은 할 수도 있고 안 할 수도 있다.
② 하나의 주문은 반드시 한 명의 고객에 의해 주문된다.
③ 주문의 데이터를 입력할 때는 반드시 고객데이터가 존재해야 한다.
④ 고객의 데이터를 입력할 때는 주문데이터가 존재하는 고객만을 입력할 수 있다.

**정답:** ④

**해설:**  
고객은 주문을 하지 않아도 존재할 수 있어요. 그런데 ④번은 “주문한 고객만 등록할 수 있어!”라고 말해요.  그건 틀린 말이에요!

**보기 설명:**  
① 주문은 선택적  
② 주문은 고객 필수  
③ 주문 시 고객 필요  
④ 고객 시 주문 필요 → ❌  

🧸 **쉬운 해설:**  
④번은 “고객은 주문한 사람만 등록돼!”라는 말인데, 그건 아니지~

🧠 **기억법:**  
고객은 주문 없어도 존재 가능!  
주문은 고객이 있어야 가능!

**필요 암기카드:**  
- 🃏 카드 17: 식별 관계 = 생명주기 공유  
- 🃏 카드 18: 비식별 관계 = 독립적 연결


---

```bash
[문제 8]  
다음 중 ERD에 대한 설명으로 가장 부적절한 것은?

① 1976년 피터첸(Peter Chen)에 의해 Entity-Relationship Model(E-R Model)이라는 표기기법이 탄생하였다.  
② 일반적으로 ERD를 작성할 때에는 엔터티들을 도형에 배치 → 관계 설정 → 관계명 기술 → 관계차수 기술 순으로 진행한다.  
③ ERD 작성의 목적은 분석된 업무에 대해 데이터 측면에서 모델을 명확하게 표현하기 위함이다.  
④ 가장 중요한 엔터티를 우선 배치하여 작성해 나가며, 애매한 엔터티들은 원칙과 규칙에 따라 배치하는 것이 일반적이다.
```

**정답:** ④

**해설:**  
ERD는 전체 흐름과 관계를 고려해서 배치해야 해요.  가장 중요한 것부터 무조건 배치하는 건 일반적인 방법이 아니에요.

**보기 설명:**  
① ERD 창시자  
② 작성 순서  
③ 목적: 데이터 표현  
④ 우선 배치: 무조건 중요한 것부터 배치한다는 건 아니에요 (❌)  

🧸 **쉬운 해설:**  
④번은 “중요한 것부터 막 배치해!”라는 말인데, 그건 ERD 방식이 아니야!

🧠 **기억법:**  
ERD 작성 순서: **도형 → 관계 → 이름 → 차수**  
중요도보다 구조와 흐름이 우선!

**필요 암기카드:**  
- 🃏 카드 1: 모델링 = 현실을 추상화하여 표현하는 기술  
- 🃏 카드 14: 엔터티 분류 = 유·개·사 / 기·중·행


###### ① **유·개·사** = **유형 / 개념 / 사건 엔터티**

| 축약 | 의미     | 설명 |
|------|----------|------|
| **유** | 유형 엔터티 | 실체가 있는 것 (예: 학생, 제품, 직원) |
| **개** | 개념 엔터티 | 실체는 없지만 관리 대상인 것 (예: 과목, 부서, 직급) |
| **사** | 사건 엔터티 | 활동이나 이벤트 (예: 수강신청, 주문, 입사기록) |

###### ② **기·중·행** = **기본 / 중심 / 행위 엔터티**

| 축약 | 의미     | 설명 |
|------|----------|------|
| **기** | 기본 엔터티 | 독립적으로 존재, 다른 엔터티에 의존하지 않음 (예: 회원, 상품) |
| **중** | 중심 엔터티 | 기본 엔터티 간 관계를 연결 (예: 주문, 수강신청) |
| **행** | 행위 엔터티 | 업무 처리 과정에서 발생하는 기록 (예: 결제내역, 출결기록) |

- **유·개·사**: “**무엇을 관리할까?**” → 실체, 개념, 사건
- **기·중·행**: “**어떻게 연결되고 기록될까?**” → 독립, 연결, 기록


---

```bash
[문제 9]  
다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?

> S병원은 여러 명의 환자가 존재하고 각 환자에 대한 이름, 주소 등을 관리하여야 한다. (단, 환자에 대한 엔터티의 특성을 살려 시나리오에 기술되어 있는 단어 중 단수형으로 대명사여야 함)

① 이름  
② 환자  
③ 나이  
④ 주소  
```

**정답:** ②

**해설:**  
병원에서는 ‘환자’를 관리하려고 해요.  ‘이름’, ‘주소’, ‘나이’는 환자에 대한 정보일 뿐, 관리 대상은 아니에요.  그래서 ‘환자’가 엔터티로 가장 적절해요.

**보기 설명:**  
① 이름: 환자의 정보예요  
② 환자: 관리 대상이에요  
③ 나이: 환자의 정보예요  
④ 주소: 환자의 정보예요  

🧸 **쉬운 해설:**  
②번은 “병원이 관리하려는 대상”이니까 엔터티야!

🧠 **기억법:**  
엔터티는 **누구를 관리할지**를 나타내는 단어!  
속성은 그 대상의 **정보**!

**필요 암기카드:**  
- 🃏 카드 1: 엔터티 = 관리할 대상  
- 🃏 카드 2: 속성 = 대상의 특징


---

```bash
[문제 10]  
다음 중 엔터티의 특징으로 가장 부적절한 것은?

① 속성이 없는 엔터티는 있을 수 없다. 엔터티는 반드시 속성을 가져야 한다.  
② 엔터티는 다른 엔터티와 관계가 있을 수 밖에 없다. 단독 엔터티는 없다.  
③ 객체지향적 디자인에서는 싱글턴 패턴처럼 단 하나의 인스턴스를 가지는 엔터티가 존재할 수 있다. 이와 유사히 엔터티는 단 1개의 인스턴스를 가질 수 있다.  
④ 데이터로 존재하고 업무에서 필요로 하면 해당 업무에 따라 엔터티로 성립될 수 있다.  
```

**정답:** ③

**해설:**  
엔터티는 보통 여러 개의 인스턴스를 가지며, 반복적으로 사용되는 데이터를 표현해요.  
③번은 객체지향 프로그래밍의 개념을 데이터모델링에 그대로 가져온 것으로, 부적절해요.

**보기 설명:**  
① 속성 필수: 엔터티는 정보를 담아야 해요  
② 관계 필수: 다른 엔터티와 연결돼 있어요  
③ 단일 인스턴스: 하나만 존재한다는 건 객체지향 개념이에요 (❌)  
④ 업무 필요 기반: 필요하면 엔터티로 만들 수 있어요  

🧸 **쉬운 해설:**  
③번은 “이건 하나만 있어도 돼!”라고 말하는데,  
데이터는 보통 여러 개가 있어야 하니까 틀린 거야!

🧠 **기억법:**  
엔터티는 **반복되는 데이터**를 표현하는 거야!  객체지향의 싱글턴 개념은 데이터모델링에 적용하면 안 돼!

**필요 암기카드:**  
- 🃏 카드 1: 엔터티 = 관리할 대상  
- 🃏 카드 61: PRIMARY KEY = 고유 이름표
 
---

```bash
[문제 11]  
다음 중 엔터티의 일반적인 특징으로 가장 부적절한 것은?

① 다른 엔터티와의 관계를 가지지 않는다.  
② 유일한 식별자에 의해 식별이 가능해야 한다.  
③ 엔터티는 업무 프로세스에 의해 이용되어야 한다.  
④ 엔터티는 반드시 속성을 포함해야 한다.
```

**정답:** ①

**해설:**  
엔터티는 다른 엔터티와 관계를 맺으며 업무 흐름을 구성해요.  
①번처럼 “관계가 없다”는 말은 엔터티의 기본 개념에 어긋나요.

**보기 설명:**  
① 관계 없음: ❌ 틀린 설명  
② 식별자 필요: 맞는 특징  
③ 업무 활용: 맞는 특징  
④ 속성 포함: 맞는 특징  

🧸 **쉬운 해설:**  
①번은 “엔터티는 혼자야!”라고 말하는데,  
데이터는 서로 연결돼야 하니까 틀렸어!

🧠 **기억법:**  
엔터티는 **속성 + 관계 + 식별자**가 기본!


**필요 암기카드:**  
- 🃏 카드 1: 엔터티 = 관리할 대상  
- 🃏 카드 61: PRIMARY KEY = 고유 이름표  
- 🃏 카드 62: FOREIGN KEY = 연결 다리

---

```bash
[문제 12]  
다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지며,  
사원, 부서, 고객, 상품, 지점 등이 예가 될 수 있는 엔터티로 가장 적절한 것은?

① 기본 엔터티 (Key 엔터티)  
② 중심 엔터티 (Main 엔터티)  
③ 행위 엔터티 (Active 엔터티)  
④ 개념 엔터티
```

**정답:** ①

**해설:**  
‘기본 엔터티’는 다른 엔터티에 의존하지 않고, 자신만의 고유한 주식별자를 갖는 독립적인 엔터티예요.  
사원, 부서, 고객 등은 모두 기본 엔터티의 대표적인 예입니다.

**보기 설명:**  
① 기본 엔터티: 독립적이고 고유 식별자 보유 (✅)  
② 중심 엔터티: 전체 모델의 중심이지만 식별자 상속 여부와는 무관  
③ 행위 엔터티: 이벤트나 활동 중심  
④ 개념 엔터티: 추상적 개념  

🧸 **쉬운 해설:**  
①번은 “나는 내 이름으로 불려요!”라고 말하는 엔터티야.  
다른 엔터티한테 의존하지 않아!

🧠 **기억법:**  
기본 엔터티 = **고유 식별자 + 독립적 존재**  
예: 고객, 사원, 부서, 상품 등

**필요 암기카드:**  
- 🃏 카드 14: 엔터티 분류 = 유·개·사 / 기·중·행  
- 🃏 카드 61: PRIMARY KEY = 고유 이름표

---

```bash
[문제 13]  
다음 중 엔터티의 이름을 부여하는 방법으로서 가장 부적절한 것은?

① 가능하면 약어를 사용하여 엔터티명을 부여한다.  
② 현업에서 사용하는 용어를 사용하여 업무와 관련성을 높인다.  
③ 엔터티명의 첫 글자는 반드시 한글로 표기한다.  
④ 엔터티명 생성 시 의미대로 간결하고 명확하도록 한다.
```

**정답:** ①

**해설:**  
엔터티명에 약어를 사용하면 의미가 불명확해지고, 커뮤니케이션에 혼란을 줄 수 있어요.  
가능하면 **약어 사용은 피하는 게 원칙**입니다.  
③번은 다소 어색한 표현이지만, 실제로는 일부 표준에서 한글 표기를 요구하는 경우도 있어 완전히 틀린 설명은 아닙니다.

**보기 설명:**  
① 약어 사용: ❌ 의미가 불명확해질 수 있음  
② 현업 용어: 업무와 연결돼서 좋음  
③ 한글 표기: 일부 표준에서는 요구되기도 함  
④ 간결 명확: 좋은 방식  

🧸 **쉬운 해설:**  
①번은 “엔터티 이름을 줄여서 쓰자!”는 말인데,  
줄이면 사람들이 무슨 뜻인지 몰라서 헷갈릴 수 있어!

🧠 **기억법:**  
엔터티명은 **풀어서 명확하게!**  
❌ 약어는 혼란의 원인!
 
**필요 암기카드:**  
- 🃏 카드 1: 엔터티 = 관리할 대상  
- 🃏 카드 19: 좋은 모델 = 완·중·재·통·의·업


---

```bash
[문제 14]  
업무에서 필요로 하는 인스턴스에서 관리하고자 하는 의미상  
더 이상 분리되지 않는 최소의 데이터 단위를 무엇이라 하는가?
```

**정답:** 속성

**해설:**  
속성은 엔터티를 구성하는 가장 작은 정보 단위예요.  
예를 들어 고객이라는 엔터티는 이름, 주소, 전화번호 같은 속성들로 구성돼요.  
이 속성들은 각각 하나의 정보 조각이에요.

🧸 **쉬운 해설:**  
속성은 “이름, 나이, 주소”처럼 하나하나의 정보야!

🧠 **기억법:**  
속성 = **더 이상 나눌 수 없는 정보 조각**

**필요 암기카드:**  
- 🃏 카드 2: 속성 = 대상의 특징  
- 🃏 카드 15: 속성 구조 = 단일 / 복합 / 다중값

---

```bash
[문제 15]  
다음 중 속성에 대한 설명으로 가장 부적절한 것은?

① 엔터티에 대한 자세하거나 구체적인 정보를 나타낸다.  
② 하나의 엔터티는 두 개 이상의 속성을 갖는다.  
③ 하나의 인스턴스에서 각각의 속성은 하나 이상의 속성값을 가질 수 있다.  
④ 속성은 독립적이다.
```

**정답:** ③

**해설:**  
속성은 하나의 인스턴스에 대해 하나의 값만 가져야 해요. ③번처럼 “하나 이상의 값을 가질 수 있다”는 설명은 부적절해요.  예를 들어, 한 사람의 이름은 하나여야지 여러 개일 수는 없어요.

**보기 설명:**  
① 정보 설명: 맞는 설명  
② 속성 여러 개: 맞음  
③ 값 여러 개: ❌ 틀림  
④ 독립적: 맞음  

🧸 **쉬운 해설:**  
③번은 “이름이 두 개 있어도 돼!”라고 말하는데,   한 사람은 이름 하나만 있어야지!

🧠 **기억법:**  
속성은 **하나의 값만** 가져야 해요!

**필요 암기카드:**  
- 🃏 카드 15: 속성 구조 = 단일 / 복합 / 다중값  
- 🃏 카드 5: 1NF = 셀 안에 값 하나만

---

```bash
[문제 16]  
다음 중 아래와 같은 사례에서 속성에 대한 설명으로 가장 부적절한 것은?

> 우리은행은 예금구분(보통예금, 정기예금 등)과 이율, 예치기간, 예금잔액을 관리한다고 할 때,  
> 예금구분은 보통예금, 정기예금이라는 값을 가질 수 있으며, 이는 1000이상의 숫자로 표현되지 않는다.  
> 이율 속성은 소수점 이하 5.0% 또는 3.0%와 같은 숫자로 표현되며, 예치기간 속성은 년단위로 표시한다.  
> 예금잔액 속성은 원 단위로 숫자가 표현된다.

① 일반속성으로 코드 엔터티를 별도로 구성하고 참조하는 것이 관리상 효과적이다.  
② 예치기간은 기본(BASIC) 속성이다.  
③ 이자와 이율과 같은 파생(DERIVED) 속성일 수 있다.  
④ 예금분류는 설계(DESIGNED) 속성이다.
```

**정답:** ③

**해설:**  
이율은 계산된 값이 아니라 직접 입력되는 값이기 때문에 파생 속성이라고 보기 어려워요.  
파생 속성은 예를 들어 ‘총금액 = 단가 × 수량’처럼 계산된 결과를 저장하는 속성이에요.

**보기 설명:**  
① 코드 참조: 맞음  
② 예치기간 기본속성: 맞음  
③ 파생 속성: ❌ 틀림  
④ 설계 속성: 맞음  

🧸 **쉬운 해설:**  
③번은 “이율은 계산해서 나오는 값이야!”라고 말하는데,  
사실은 그냥 입력하는 값이야!

🧠 **기억법:**  
파생 속성 = **계산해서 나오는 값**  
이율은 직접 입력하는 값 → 기본 속성!

**필요 암기카드:**  
- 🃏 카드 15: 속성 구조 = 단일 / 복합 / 다중값  
- 🃏 카드 3: 관계 = 연결선  
- 🃏 카드 66: 도메인 무결성 = 값의 규칙


---

```bash
[문제 17]  
다음 중 데이터를 조회할 때 빠른 성능을 낼 수 있도록 하기 위해  
원래 속성의 값을 계산하여 저장할 수 있도록 만든 속성으로 가장 적절한 것은?

① 파생속성 (Derived Attribute)  
② 기본속성 (Basic Attribute)  
③ 설계속성 (Designed Attribute)  
④ PK속성 (Primary Key Attribute)
```

**정답:** ①

**해설:**  
파생속성은 계산된 값을 저장해서 조회 속도를 높여요.  
예: ‘총금액 = 단가 × 수량’ 같은 계산 결과를 미리 저장해두는 거예요.

**보기 설명:**  
① 계산된 값 저장: 정답  
② 기본값: 그냥 있는 값  
③ 설계 속성: 설계 시 정의  
④ PK속성: 식별자 속성  

🧸 **쉬운 해설:**  
①번은 “미리 계산해서 저장해두는 정보”야!

🧠 **기억법:**  
파생속성 = **계산해서 미리 저장하는 값**

**필요 암기카드:**  
- 🃏 카드 15: 속성 구조 = 단일 / 복합 / 다중값  
- 🃏 카드 66: 도메인 무결성 = 값의 규칙




---

```bash
[문제 18]  
다음 중 아래 설명이 나타내는 데이터모델의 개념으로 가장 적절한 것은?

> 주문이라는 엔터티가 있을 때 단가라는 속성 값의 범위는 100에서 10,000 사이의 실수 값이며,  
> 제품명이라는 속성은 길이가 20자 이내의 문자열로 정의할 수 있다.

① 시스템카탈로그 (System Catalog)  
② 용어사전 (Word Dictionary)  
③ 속성사전 (Attribute Dictionary)  
④ 도메인 (Domain)
```

**정답:** ④

**해설:**  
도메인은 속성 값이 가질 수 있는 **범위나 형식**을 정의하는 개념이에요.  
예: 단가는 100~10,000 사이의 숫자, 제품명은 20자 이내의 문자열 등.

**보기 설명:**  
① 시스템카탈로그: DB 구조 정보 저장  
② 용어사전: 용어 정의  
③ 속성사전: 속성 목록  
④ 도메인: 값의 범위와 형식 정의 (✅)  

🧸 **쉬운 해설:**  
④번은 “이 값은 이 범위 안에서만 써야 해!”라는 뜻이야!

🧠 **기억법:**  
도메인 = **값의 허용 범위 + 형식**

**필요 암기카드:**  
- 🃏 카드 66: 도메인 무결성 = 값의 규칙  
- 🃏 카드 65: CHECK = 조건 필터

---

```bash
[문제 19]  
다음 중 데이터모델링을 할 때 속성의 명칭을 부여하는 방법으로 가장 부적절한 것은?

① 속성의 이름에 약어를 사용할 경우 그 의미를 명확하게 이해할 수 없고  
혼돈을 초래하여 커뮤니케이션의 혼란을 야기할 수 있으므로 지나친  
약어 사용은 가급적 제한하도록 한다.  
② 속성의 이름에는 서술식 용어는 사용하지 않도록 한다.  
③ 직원 엔터티의 이름, 고객 엔터티의 이름과 같이 각 엔터티별로 동일한  
속성명을 사용하여 데이터모델의 일관성을 가져가는 것이 좋다.  
④ 데이터모델링 대상에서 사용하는 용어도 있고 외부에서 사용하는 용어  
도 있어 중복이 있을 때, 가급적 해당 업무에서 자주 사용하는 이름을  
이용하도록 한다.
```

**정답:** ③

**해설:**  
각 엔터티에 동일한 속성명을 사용하는 것은 혼동을 줄 수 있어요.  
예를 들어 ‘이름’이라는 속성이 고객과 직원 모두에 있을 때, 구분이 어려워질 수 있어요.  
따라서 엔터티별로 구분되는 명칭을 사용하는 것이 좋습니다.

**보기 설명:**  
① 약어 제한: 맞음  
② 서술식 지양: 맞음  
③ 동일 속성명 반복 사용: ❌ 혼동 유발  
④ 자주 쓰는 용어 우선: 맞음  

🧸 **쉬운 해설:**  
③번은 “모든 엔터티에 이름이라는 속성을 똑같이 써도 돼!”라고 말하는데,  그러면 헷갈릴 수 있어!

🧠 **기억법:**  
속성명은 **명확하고 구분 가능하게!**  
❌ 모든 엔터티에 같은 이름 쓰면 혼란!

 
**필요 암기카드:**  
- 🃏 카드 2: 속성 = 대상의 특징  
- 🃏 카드 19: 좋은 모델 = 완·중·재·통·의·업
 

---

```bash
[문제 20]  
다음 중 데이터모델링의 관계에 대한 설명으로 가장 부적절한 것을 2개 고르시오.

① 관계는 존재에 의한 관계와 행위에 의한 관계로 구분될 수 있으나 ERD에서는 관계를 연결할 때, 존재와 행위를 구분하지 않고 단일화된 표기법을 사용한다.  
② UML(Unified Modeling Language)에는 클래스다이어그램의 관계 중  연관관계(Association)와 의존관계(Dependency)가 있고 이것은 실선과 점선의 표기법으로 다르게 표현이 된다.  
③ 관계는 존재에 의한 관계와 행위에 의한 관계로 구분될 수 있고 ERD 에서는 관계를 연결할 때, 존재와 행위를 구분하여 실선과 접선의 표기법으로 다르게 표현한다.  
④ UML(Unified Modeling Language)에는 클래스다이어그램의 관계 중  연관관계(Association)와 의존관계(Dependency)가 있고 있으나 구분하지 않고 단일화된 표기법을 사용한다.
```

**정답:** ③, ④

**해설:**  
ERD에서는 관계를 연결할 때 존재적 관계와 행위적 관계를 **구분하지 않고** 단일한 표기법(보통 실선)을 사용합니다.  
③번은 ERD에서 실선과 점선을 구분한다고 했는데, 이는 UML의 특징이지 ERD의 특징이 아니에요.  
④번은 UML에서 연관관계와 의존관계를 구분하지 않는다고 했는데, 실제로는 **구분해서 다른 표기법(실선과 점선)**을 사용합니다.

**보기 설명:**  
① ERD는 관계 구분 없이 단일 표기법 사용 → 맞음  
② UML은 관계를 실선/점선으로 구분 → 맞음  
③ ERD에서 실선/점선으로 구분한다 → ❌ 틀림  
④ UML에서 관계를 구분하지 않는다 → ❌ 틀림  

🧸 **쉬운 해설:**  
③번은 “ERD에서 관계를 실선과 점선으로 나눠서 그려!”라고 말하는데,  ERD는 그냥 실선 하나로 그려요.  
④번은 “UML은 관계를 구분 안 해!”라고 말하는데,  UML은 실선과 점선으로 확실히 구분해요!

🧠 **기억법:**  
- **ERD**는 관계를 **단일 실선**으로 표현  
- **UML**은 관계를 **실선(Association)** 과 **점선(Dependency)** 으로 구분  
❌ ERD에서 선을 구분하거나 UML에서 구분하지 않는다는 설명은 틀림!
 
**필요 암기카드:**  
- 🃏 카드 41: JOIN 유형 = INNER / LEFT / FULL  
- 🃏 카드 20: 모델링 단계 = 개념 → 논리 → 물리

---

```bash
[문제 21]  
다음 중 관계에 대한 설명으로 가장 부적절한 것은?

① 관계는 존재적 관계와 행위에 의한 관계로 나누어볼 수 있다.  
② 관계의 표기법은 관계명, 관계차수, 식별성의 3가지 개념을 사용한다.  
③ 부서와 사원 엔터티 간의 '소속' 관계는 존재적 관계의 사례이다.  
④ 주문과 배송 엔터티 간의 '배송근거' 관계는 행위에 의한 관계의 사례이다.
```

**정답:** ②

**해설:**  
관계의 표기법은 일반적으로 **관계명과 관계차수**를 사용하지만,  
‘식별성’은 관계의 속성이지 표기법의 구성 요소는 아니에요.  
②번은 표기법과 관계 속성을 혼동한 설명입니다.

**보기 설명:**  
① 관계 유형 구분: 맞음  
② 표기법에 식별성 포함: ❌ 틀림  
③ 존재적 관계 예시: 맞음  
④ 행위적 관계 예시: 맞음  

🧸 **쉬운 해설:**  
②번은 “관계 그릴 때 식별성도 같이 표시해!”라고 말하는데,  
그건 관계의 속성이지 그림 요소는 아니야!

🧠 **기억법:**  
관계 표기법 = **관계명 + 관계차수**  
❌ 식별성은 표기법이 아니라 관계의 속성!

**필요 암기카드:**  
- 🃏 카드 12: 관계의 차수 = 몇 명이 연결?  
- 🃏 카드 13: 관계의 참여도 = 꼭 연결돼야 하나?

---

```bash
[문제 22]  
다음 중 엔터티간의 관계에서 1:1, 1:M과 같이 관계의 기수성을 나타내는  
것으로 가장 적절한 것은?

① 관계명(Relationship Membership)  
② 관계차수(Relationship Degree/Cardinality)  
③ 관계선택사양(Relationship Optionality)  
④ 관계정의(Relationship Definition)
```

**정답:** ②

**해설:**  
관계차수(Cardinality)는 관계의 **기수성**, 즉 몇 개의 인스턴스가 연결되는지를 나타내요.  
예: 1:1, 1:N, N:M 같은 표현이 바로 관계차수입니다.

**보기 설명:**  
① 관계명: 관계의 이름  
② 관계차수: 인스턴스 수 표현 (✅)  
③ 선택사양: 필수/선택 여부  
④ 정의: 관계 설명  

🧸 **쉬운 해설:**  
②번은 “몇 명이 연결되는지 알려주는 숫자야!”  
예: 고객 1명은 주문 여러 개 가능 → 1:N

🧠 **기억법:**  
기수성 = **Cardinality = 관계차수**

**필요 암기카드:**  
- 🃏 카드 12: 관계의 차수 = 몇 명이 연결?


---

```bash
[문제 23]  
다음 중 두 개의 엔터티 사이에 정의한 관계를 체크하는 사항으로 가장 부적절한 것은?

① 두 개의 엔터티 사이에 관심 있는 연관규칙이 존재하는가?  
② 두 개의 엔터티 사이에 정보의 조합이 발생되는가?  
③ 업무기술서, 장표에 관계연결을 가능하게 하는 명사 (Noun)가 있는가?  
④ 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?
```

**정답:** ③

**해설:**  
관계를 도출할 때는 **동사(Verb)** 가 핵심이에요.  
명사(Noun)는 엔터티를 나타내고, 관계를 연결하는 건 동사입니다.  
③번은 관계 연결 요소로 명사를 제시했기 때문에 부적절합니다.

**보기 설명:**  
① 연관규칙 존재 여부: 맞음  
② 정보 조합 발생 여부: 맞음  
③ 명사로 관계 연결: ❌ 틀림  
④ 규칙 서술 여부: 맞음  

🧸 **쉬운 해설:**  
③번은 “명사로 관계를 연결해!”라고 말하는데,  
관계는 동사로 연결해야 돼!

🧠 **기억법:**  
관계 연결 키워드 = **동사(Verb)**  
❌ 명사는 엔터티 이름!

**필요 암기카드:**  
- 🃏 카드 13: 관계의 참여도 = 꼭 연결돼야 하나?  
- 🃏 카드 3: 관계 = 대상 간 연결
---

```bash
[문제 24]  
다음 중 두 개의 엔터티 사이에서 관계를 도출 할 때 체크 할 사항을  모두 고른 것은?

> 가. 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?  
> 나. 두 개의 엔터티 사이에 정보의 조합이 발생되는가?  
> 다. 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?  
> 라. 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb)가 있는가?

① 가. 다. 라  
② 가. 다. 라  
③ 가. 나. 다  
④ 가. 나. 다. 라
```

**정답:** ④

**해설:**  
관계를 도출할 때는 연관규칙, 정보 조합, 규칙 서술, 동사 표현 모두 중요해요.  
이 네 가지가 모두 체크 포인트입니다.

**보기 설명:**  
① 일부만 포함: 부족  
② 일부만 포함: 부족  
③ 라 누락: 부족  
④ 전체 포함: ✅ 정답  

🧸 **쉬운 해설:**  
④번은 “관계를 찾을 때 필요한 건 다 들어 있어!”  
규칙도 보고, 동사도 보고, 정보도 보고!

🧠 **기억법:**  
관계 도출 4요소 = **규칙 + 조합 + 설명 + 동사**

**필요 암기카드:**  
- 🃏 카드 13: 관계의 참여도 = 꼭 연결돼야 하나?  
- 🃏 카드 3: 관계 = 대상 간 연결


---

```bash
[문제 25]  
다음 중 아래에서 주식별자를 지정할 때 고려해야 할 사항을 묶은 것으로 가장 적절한 것은?

> 가. 주식별자에 의해 엔티티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.  
> 나. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.  
> 다. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.  
> 라. 주식별자가 지정이 되면 반드시 값이 들어와야 한다.

① 가. 나. 다  
② 가. 나. 라  
③ 나. 다. 라  
④ 가. 나. 다. 라
```

**정답:** ④

**해설:**  
주식별자는 유일성, 안정성, 필수성 모두 만족해야 해요.  
④번은 이 모든 조건을 포함한 완전한 설명입니다.

**보기 설명:**  
① 라 누락: 부족  
② 다 누락: 부족  
③ 가 누락: 부족  
④ 전체 포함: ✅ 정답  

🧸 **쉬운 해설:**  
④번은 “식별자는 꼭 있어야 하고, 안 바뀌고, 하나만 있어야 돼!”  
모든 조건을 다 갖췄어!

🧠 **기억법:**  
주식별자 4조건 = **유일성 + 최소성 + 안정성 + 필수성**

**필요 암기카드:**  
- 🃏 카드 61: PRIMARY KEY = 고유 이름표  
- 🃏 카드 60: 제약조건 = 생성 또는 수정 시 설정


 
---

```bash
[문제 26]  
다음 중 사원엔터티에서 식별자의 특성에 해당하지 않는 것은 무엇인가?

① 주식별자  
② 단일식별자  
③ 내부식별자  
④ 인조식별자
```
```mermaid
erDiagram
    부서 {
        int 부서번호  PK
        string 부서명
    }
    사원 {
        int    사번    PK
        int 부서번호 FK
        String 주민등록번호
    }

    부서 ||--o{사원 : 소속된다

``` 

**정답:** ④

**해설:**  
사번은 실제 업무에서 사용되는 자연식별자예요.  
인조식별자는 시스템에서 생성된 값인데, ④ 번은 그렇지 않기 때문에 해당되지 않아요.

**보기 설명:**  
① 주식별자: 맞음  
② 단일식별자: 맞음  
③ 내부식별자: 맞음  
④ 인조식별자: ❌ 틀림  

🧸 **쉬운 해설:**  
④번은 “사번은 시스템이 만든 번호야!”라고 말하는데,  
④번은 사람이 정한 번호니까 틀렸어!

🧠 **기억법:**  
인조식별자 = **시스템이 자동 생성한 값**  
④ 사번은 자연식별자!
 
**필요 암기카드:**  
- 🃏 카드 63: UNIQUE = 중복 ❌, NULL 가능  
- 🃏 카드 61: PRIMARY KEY = 고유 이름표

---

```bash
[문제 27]  
다음 중 식별자로 가장 부적절한 것은?
```
①  
```mermaid
erDiagram
    사원 {
        NUMBER(10)    사번번호    PK 
        NUMBER(13) 주민등록번호
    }
``` 

②  
```mermaid
erDiagram
    사원 {
        VARCHAR2(20) 이름    PK 
        NUMBER(10)   사원번호
    }
```  

③ 
```mermaid
erDiagram
    사원 {
        NUMBER(13) 주민등록번호    PK 
        NUMBER(10)    사번번호
    }
``` 

④ 

```mermaid
erDiagram
    사원 {
        VARCHAR2(10) 일련번호    PK 
        NUMBER(13) 주민등록번호      
        NUMBER(10)    사번번호
    }
``` 


**정답:** ②

**해설:**  
식별자는 반드시 **유일성**을 만족해야 해요.  
이름은 중복될 수 있기 때문에 식별자로 부적절합니다.  
예를 들어 ‘김민수’라는 이름을 가진 사람이 여러 명 있을 수 있어요.

**보기 설명:**  
① 사번번호: 유일함 → 적절  
② 이름: ❌ 중복 가능 → 부적절  
③ 주민등록번호: 유일함 → 적절  
④ 일련번호: 시스템 생성 가능 → 적절  

🧸 **쉬운 해설:**  
②번은 “이름으로 사람을 구분할 수 있어!”라고 말하는데,  
세상에 같은 이름 가진 사람 많잖아!

🧠 **기억법:**  
식별자는 **중복되면 안 돼!**  
이름은 절대 식별자로 쓰지 말기!

**필요 암기카드:**  
- 🃏 카드 61: PRIMARY KEY = 고유 이름표  
- 🃏 카드 63: UNIQUE = 중복 ❌, NULL 가능

---

```bash
[문제 28]  
다음 중 아래에서 엔터티 내에 주식별자를 도출하는 기준을 묶은 것으로  
가장 적절한 것은?

> 가. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.  
> 나. 명칭, 내역 등과 같이 이름으로 기술되는 것들을 주식별자로 지정한다.  
> 다. 복합으로 주식별자를 구성할 경우 너무 많은 속성을 포함하지 않도록 한다.  
> 라. 자주 수정되는 속성을 주식별자로 지정한다.

① 가, 나  
② 가, 다  
③ 다, 라  
④ 나, 라
```

**정답:** ②

**해설:**  
주식별자는 자주 사용하는 속성이면서, 너무 많은 속성을 포함하지 않아야 해요.  
‘명칭’이나 ‘자주 수정되는 속성’은 식별자로 부적절합니다.

**보기 설명:**  
① 나 포함: ❌ 이름은 중복 가능  
② 가, 다 포함: ✅ 적절  
③ 라 포함: ❌ 자주 바뀌면 안 됨  
④ 나, 라 포함: ❌ 둘 다 부적절  

🧸 **쉬운 해설:**  
②번은 “자주 쓰고, 너무 복잡하지 않은 걸로 골라!”  
이름이나 자주 바뀌는 건 식별자에 안 맞아!

🧠 **기억법:**  
식별자 도출 기준 = **자주 쓰는 + 안정적 + 간단한 속성**

**필요 암기카드:**  
- 🃏 카드 61: PRIMARY KEY = 고유 이름표  
- 🃏 카드 64: NOT NULL = 빈칸 금지

---

```bash
[문제 29]  
프로젝트를 전개할 때는 식별자관계와 비식별자관계를 선택하여 연결  
해야 하는 높은 수준의 데이터모델링 기술이 필요하다. 다음 중 비식별자  
관계를 선택하는 기준으로 가장 부적절한 것은?

① 관계의 강약을 분석하여 상호간에 연관성이 약할 경우 비식별자관계를 고려한다.  
② 자식테이블에서 독립적인 Primary Key의 구조를 가지기 원할 때 비식별자관계를 고려한다.  
③ 모든 관계가 식별자 관계로 연결되면 SQL Where절에서 비교하는 항목이 증가되어 조인에 참여하는 테이블에 따라 SQL문장이 길어져 SQL문의 복잡성이 증가되는 것을 방지하기 위해 비식별자관계를 고려한다.  
④ 부모엔터티의 주식별자를 자식엔터티에서 받아 손자엔터티까지 계속 흘려보내기 위해 비식별자관계를 고려한다.
```

**정답:** ④

**해설:**  
④번은 오히려 식별자 관계를 사용할 때의 특징이에요.  
비식별자 관계는 부모의 식별자를 자식이 **받지 않는** 구조입니다.  
식별자를 계속 흘려보내는 건 비식별자 관계와 반대예요.

**보기 설명:**  
① 연관성 약할 때: 맞음  
② 자식 PK 독립: 맞음  
③ SQL 복잡성 방지: 맞음  
④ 식별자 흘려보내기: ❌ 식별자 관계 특징  

🧸 **쉬운 해설:**  
④번은 “식별자를 계속 전달해!”라고 말하는데,  
비식별자는 전달 안 해도 되는 구조야!

🧠 **기억법:**  
비식별자 관계 = **식별자 전달 안 함 + 자식 독립적**

**필요 암기카드:**  
- 🃏 카드 18: 비식별 관계 = 독립적 연결  
- 🃏 카드 61: PRIMARY KEY = 고유 이름표

---

```bash
[문제 30]  
다음 중 비식별자 관계로 연결하는 것을 고려해야 하는 경우로 가장 부적절한 것은?

① 부모엔터티에 참조값이 없어도 자식엔터티의 인스턴스가 생성될 수 있는 경우  
② 부모엔터티의 인스턴스가 자식 엔터티와 같이 소멸되는 경우  
③ 여러 개의 엔터티를 하나로 통합하면서 각각의 엔터티가 갖고 있던 여러 개의 개별 관계가 통합되는 경우  
④ 자식쪽 엔터티의 주식별자를 부모엔터티와는 별도로 생성하는 것이 더 유리하다고 판단하는 경우
```

**정답:** ②

**해설:**  
②번은 식별자 관계의 특징이에요.  
부모와 자식이 함께 소멸되는 경우는 **강한 연관성**이 있기 때문에 식별자 관계로 연결하는 게 맞습니다.  
비식별자 관계는 자식이 독립적으로 존재할 수 있어야 해요.

**보기 설명:**  
① 자식 독립 생성: 맞음  
② 함께 소멸: ❌ 식별자 관계 특징  
③ 통합 시 관계 단순화: 맞음  
④ 자식 PK 독립 생성: 맞음  

🧸 **쉬운 해설:**  
②번은 “부모랑 자식이 같이 사라져!”라고 말하는데,  
그건 서로 너무 강하게 연결된 관계야!

🧠 **기억법:**  
비식별자 관계 = **자식 독립 + 부모 없어도 존재 가능**

**필요 암기카드:**  
- 🃏 카드 18: 비식별 관계 = 독립적 연결  
- 🃏 카드 62: FOREIGN KEY = 연결 다리