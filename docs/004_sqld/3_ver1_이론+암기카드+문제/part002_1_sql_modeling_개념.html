<!DOCTYPE html><html><head>
      <title>part002_1_sql_modeling_개념</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\sally03915\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.19\crossnote\dependencies\katex\katex.min.css">
      
      
      <script type="text/javascript" src="file:///c:\Users\sally03915\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.19\crossnote\dependencies\mermaid\mermaid.min.js" charset="UTF-8"></script>
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<style>
pre, code {
  white-space: pre-wrap !important;
  word-break: break-word !important;
  overflow-x: hidden !important;
  display: block !important;
  max-width: 100% !important;
  box-sizing: border-box !important;
}
</style> 
<hr>
<h3 id="-모델링-basic-3구간-분할">📁 모델링 BASIC (3구간 분할) </h3>
<table>
<thead>
<tr>
<th>구간</th>
<th>문제 번호</th>
<th>주제 범위</th>
<th>난이도</th>
</tr>
</thead>
<tbody>
<tr>
<td>1단계</td>
<td>001~020</td>
<td>모델링 개념, 엔터티·속성·관계의 기초</td>
<td>⭐ 초급~중급</td>
</tr>
<tr>
<td>2단계</td>
<td>021~036</td>
<td>관계 유형, 식별자, 성능 모델링 개요</td>
<td>⭐⭐ 중급~고급</td>
</tr>
<tr>
<td>3단계</td>
<td>037~052</td>
<td>정규화/반정규화 판단 및 실무 사례 분석</td>
<td>⭐⭐⭐ 고급~실무형</td>
</tr>
</tbody>
</table>
<blockquote>
<p>“기초 → 관계/식별자 → 정규화/실무”</p>
</blockquote>
<h4 id="-1단계-001020">✅ 1단계: 001~020 </h4>
<ul>
<li>모델링의 정의, 필요성, 추상화/정확화 개념을 익히고</li>
<li>엔터티, 속성, 관계의 기본 구조와 명명 규칙을 학습합니다.</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">1</span><span class="token punctuation">]</span>  
모델링은 현실세계를 표현하는 것으로 이해할 수 있다. 다음 중 모델링의 특징으로 가장 부적절한 것은?

① 현실세계를 일정한 형식의 모델로 표현하는 추상화의 의미를 가짐  
② 시스템 구현만을 위해 진행하는 사전단계의 작업으로서 데이터베이스 구축을 위한 사전 작업의 의미만 가짐  
③ 복잡한 현실을 제한된 언어나 표기방법을 통해 쉽게 이해할 수 있는 단순화 의미를 가짐  
④ 현실세계를 일정한 형식으로 누구나 이해가 가능하도록 정확하게 현상을 기술하는 정확화 의미를 가짐  
</code></pre><p><strong>정답:</strong> ②</p>
<p><strong>해설:</strong><br>
<strong>🧸 쉬운 해설</strong><br>
모델링은 세상을 쉽게 설명하는 그림이야.<br>
②번은 “그림은 오직 컴퓨터 만들려고 그리는 거야!”라고 말하는데, 너무 좁게 본 거야!</p>
<p><strong>📚 전문 해설</strong><br>
모델링은 현실 세계를 표현하는 작업으로,</p>
<ul>
<li><strong>추상화</strong>: 핵심만 뽑아 표현</li>
<li><strong>단순화</strong>: 이해하기 쉽게 구조화</li>
<li><strong>정확화</strong>: 누구나 이해할 수 있도록 명확하게 기술<br>
②번은 모델링을 단순히 시스템 구현을 위한 사전 작업으로 한정하고 있어 부적절합니다.</li>
</ul>
<p><strong>🔍 보기 설명</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>추상화</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>시스템 구현만을 위한 작업</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>단순화</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>정확화</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p><strong>🧠 기억법</strong><br>
모델링의 3대 특징 = <strong>추단정</strong> → 추상화, 단순화, 정확화</p>
<p><strong>🃏 암기카드</strong></p>
<ul>
<li>카드 1: 모델링 = 현실을 추상화하여 표현하는 기술</li>
<li>카드 19: 좋은 모델 = 완·중·재·통·의·업</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">2</span><span class="token punctuation">]</span>  
다음 설명 중 데이터 모델링이 필요한 주요 이유로 가장 부적절한 것은?

① 업무규모를 구성하는 기초가 되는 정보를 대체 일정한 표기방법에 의해 표현함.  
② 분석된 결과물을 가지고 데이터베이스를 설계할 수 있는 기초 자료로 사용하기 위함.  
③ 데이터베이스를 구축하기 위한 용도를 위해 데이터모델링을 수행하고 업무에 대한 설명은 별도로 표기방법을 이용한다.  
④ 데이터모델링은 자료로서의 업무를 설명하고 분석하는 부분에 의미를 가지고 있다.  
</code></pre><p><strong>정답:</strong> ③</p>
<p>**🧸 쉬운 해설<br>
데이터모델링은 일도 설명하는 표야.<br>
③번은 “일은 따로 설명하고 표는 컴퓨터용이야!”라고 말하는데, 그건 틀렸어!</p>
<h6 id="-전문-해설">📚 전문 해설 </h6>
<p>데이터 모델링은</p>
<ul>
<li>업무를 <strong>설명</strong>하고</li>
<li>업무를 <strong>분석</strong>하며</li>
<li>DB 설계의 <strong>기초 자료</strong>로 활용됩니다.<br>
③번은 업무 설명을 모델링과 분리한다고 하여 본질을 축소한 설명입니다.</li>
</ul>
<h6 id="-보기-설명">🔍 보기 설명 </h6>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>정보 표현</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>설계 기초</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>업무 설명은 별도</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>업무 분석</td>
<td>✅</td>
</tr>
</tbody>
</table>
<h6 id="-기억법">🧠 기억법 </h6>
<p>데이터모델링 = <strong>설명 + 분석 + 설계</strong></p>
<h6 id="-암기카드">🃏 암기카드 </h6>
<ul>
<li>카드 1: 모델링 = 현실을 추상화하여 표현하는 기술</li>
<li>카드 19: 좋은 모델 = 완·중·재·통·의·업</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">3</span><span class="token punctuation">]</span>  
다음 중 데이터모델링을 할 때 유의해야 할 사항으로 가장 부적절한 것은?

① 여러 장소의 데이터베이스에 같은 정보를 저장하지 않도록 하여 중복을 최소화한다.  
② 데이터의 정의를 데이터의 사용 프로세스와 분리하여 독립성을 높인다.  
③ 사용자가 처리하는 프로세스나 정보 등에 따라 매번 달라질 수 있도록 프로그램과 데이터베이스의 관계를 늘 높인다.  
④ 데이터 간의 상호 연관관계를 명확하게 정의하여 일관성 있게 데이터를 유지되도록 한다.  
</code></pre><p><strong>정답:</strong> ③</p>
<h6 id="-쉬운-해설">🧸 쉬운 해설 </h6>
<p>③번은 “정보는 자꾸 바뀌게 만들자!”고 해서 틀렸어!<br>
정보는 깔끔하게 정리해야 해.</p>
<h6 id="-전문-해설-1">📚 전문 해설 </h6>
<p>데이터 모델링의 핵심은</p>
<ul>
<li><strong>중복 최소화</strong></li>
<li><strong>독립성 확보</strong></li>
<li><strong>일관성 유지</strong><br>
③번은 관계를 자주 변경하도록 유도하여 유지보수성과 안정성을 해치는 부적절한 접근입니다.</li>
</ul>
<h6 id="-보기-설명-1">🔍 보기 설명 </h6>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>중복 최소화</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>독립성 강화</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>관계 늘리기</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>일관성 유지</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
데이터모델링의 핵심은 <strong>중독일</strong><br>
→ 중복 최소화, 독립성, 일관성 유지<br>
❌ 관계를 늘려서 복잡하게 만들면 안 돼!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 19: 좋은 모델 = 완·중·재·통·의·업</li>
<li>🃏 카드 66: 도메인 무결성 = 값의 규칙</li>
<li>🃏 카드 67: 엔터티 무결성 = 고유성 유지</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">4</span><span class="token punctuation">]</span>  
다음 중 아래 설명이 의미하는 데이터모델링의 유의점에 해당하는 특성은 무엇인가?

<span class="token operator">&gt;</span> 데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경되므로 유연성의 어려움을 가중시킬 수 있다. 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델은 데이터 혹은 프로세스의 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄일 수 있다.

① 중복 ② 비유연성 ③ 비일관성 ④ 일관성
</code></pre><p><strong>정답:</strong> ②</p>
<h6 id="-쉬운-해설-1">🧸 쉬운 해설 </h6>
<p>②번은 “표가 너무 딱딱해서 조금만 바뀌어도 다시 만들어야 해!”라는 뜻이야.</p>
<h6 id="-전문-해설-2">📚 전문 해설 </h6>
<p>비유연성은 데이터 모델이 업무 변화에 민감하게 반응하여 자주 수정이 필요한 상태를 의미합니다.<br>
유연한 모델은 데이터 정의와 사용 프로세스를 분리하여 변화에 강한 구조를 유지합니다.</p>
<p><strong>보기 설명:</strong><br>
① 중복: 같은 정보가 여러 번 나와요<br>
② 비유연성: 조금만 바뀌어도 다시 만들어야 해요<br>
③ 비일관성: 내용이 들쭉날쭉해요<br>
④ 일관성: 항상 똑같고 정돈돼 있어요</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
②번은 “표가 너무 딱딱해서 조금만 바뀌어도 다시 만들어야 해!”라는 뜻이야.<br>
그래서 정답이야!</p>
<p>🧠 <strong>기억법:</strong><br>
데이터모델링은 <strong>유연성</strong>이 중요!<br>
비유연성은 업무 변화에 약한 구조!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 19: 좋은 모델 = 완·중·재·통·의·업</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">5</span><span class="token punctuation">]</span>  
다음 중 아래 데이터모델링 개념에 대한 설명에서 <span class="token punctuation">(</span>가<span class="token punctuation">)</span> , <span class="token punctuation">(</span>나<span class="token punctuation">)</span>에 들어갈 단어로 가장 적절한 것은?

<span class="token operator">&gt;</span> 전사적 데이터 모델링을 수행할 때 많이 하며, 추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링을 진행하는 것을 <span class="token punctuation">(</span>가<span class="token punctuation">)</span>  데이터 모델링이라고 한다. 이후 논리적 설계로 데이터베이스에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려한 데이터 모델링을 <span class="token punctuation">(</span>나<span class="token punctuation">)</span>데이터모델링이라고 한다.

① <span class="token punctuation">(</span>가<span class="token punctuation">)</span><span class="token operator">=</span>개념적, <span class="token punctuation">(</span>나<span class="token punctuation">)</span><span class="token operator">=</span>물리적  
② <span class="token punctuation">(</span>가<span class="token punctuation">)</span><span class="token operator">=</span>논리적, <span class="token punctuation">(</span>나<span class="token punctuation">)</span><span class="token operator">=</span>개념적  
③ <span class="token punctuation">(</span>가<span class="token punctuation">)</span><span class="token operator">=</span>논리적, <span class="token punctuation">(</span>나<span class="token punctuation">)</span><span class="token operator">=</span>물리적  
④ <span class="token punctuation">(</span>가<span class="token punctuation">)</span><span class="token operator">=</span>개념적, <span class="token punctuation">(</span>나<span class="token punctuation">)</span><span class="token operator">=</span>논리적
</code></pre><p><strong>정답:</strong> ①</p>
<p><strong>🧸 쉬운 해설</strong><br>
①번은 “먼저 큰 그림 그리고, 그다음 저장소에 맞게 조정하는 거야!”라는 뜻이야! 먼저 마을 전체를 그리는 큰 그림을 그려요.  그다음, 그림을 실제로 만들기 위해 저장소나 성능을 생각해요.  처음은 개념적, 나중은 물리적이에요!</p>
<p><strong>📚 전문 해설</strong><br>
모델링 단계는</p>
<ul>
<li><strong>개념적 모델링</strong>: 추상화 수준이 높고 업무 중심</li>
<li><strong>논리적 모델링</strong>: 구조와 관계 정의</li>
<li><strong>물리적 모델링</strong>: 성능, 저장소 등 기술적 요소 고려<br>
①번은 이 순서를 정확히 반영한 설명입니다.</li>
</ul>
<p><strong>보기 설명:</strong><br>
① 개념적: 큰 그림을 그려요<br>
② 논리적: 구조를 정리해요<br>
③ 물리적: 저장과 성능을 생각해요<br>
④ 논리적: 실제 설계에 가까워요</p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>개념 → 물리</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>논리 → 개념</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>논리 → 물리</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>개념 → 논리</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧸 <strong>쉬운 해설:</strong><br>
①번은 “먼저 큰 그림 그리고, 그다음 저장소에 맞게 조정하는 거야!”라는 뜻이야!</p>
<p>🧠 <strong>기억법:</strong><br>
모델링 단계는 <strong>개→논→물</strong> 순서!<br>
개념적 → 논리적 → 물리적</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 20: 모델링 단계 = 개념 → 논리 → 물리</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">6</span><span class="token punctuation">]</span>  
다음 중 ANSI-SPARC에서 정의한 <span class="token number">3</span>단계구조<span class="token punctuation">(</span>three-level architecture<span class="token punctuation">)</span>에서 아래 내용이 설명하는 스키마구조로 가장 적절한 것은?

<span class="token operator">&gt;</span> * 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현  
<span class="token operator">&gt;</span> * 모든 응용시스템이나 사용자들의 필요를 하나의 데이터로 통합한 전체적 DB를 기술한 것  
<span class="token operator">&gt;</span> * DB의 개체들, 속성들, 관계를 정의하고 데이터 그룹 간의 관계를 표현하는 스키마

① 외부스키마 <span class="token punctuation">(</span>External Schema<span class="token punctuation">)</span>  
② 개념스키마 <span class="token punctuation">(</span>Conceptual Schema<span class="token punctuation">)</span>  
③ 내부스키마 <span class="token punctuation">(</span>Internal Schema<span class="token punctuation">)</span>  
④ 논리스키마 <span class="token punctuation">(</span>Logical Schema<span class="token punctuation">)</span>
</code></pre><p><strong>정답:</strong> ②</p>
<p><strong>🧸 쉬운 해설</strong><br>
모든 사람의 관점을 하나로 모은 그림을 ‘개념스키마’라고 해요.  이건 전체 조직을 위한 큰 그림이에요.</p>
<p>**📚 전문 해설<br>
ANSI-SPARC 3단계 구조에서</p>
<ul>
<li><strong>외부스키마</strong>: 사용자 관점</li>
<li><strong>개념스키마</strong>: 조직 전체 관점</li>
<li><strong>내부스키마</strong>: 저장소 중심<br>
②번은 조직 전체 관점을 표현하는 개념스키마에 해당합니다.</li>
</ul>
<p><strong>보기 설명:</strong><br>
① 외부스키마: 개인용 그림이에요<br>
② 개념스키마: 모두를 위한 큰 그림이에요<br>
③ 내부스키마: 저장소 중심 그림이에요<br>
④ 논리스키마: 실제 용어엔 없어요</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
②번은 “모든 사람의 관점을 하나로 모은 그림”이야!</p>
<p>🧠 <strong>기억법:</strong><br>
ANSI-SPARC 3단계: <strong>외→개→내</strong><br>
외부(사용자) → 개념(전체) → 내부(저장)</p>
<ol>
<li>ANSI-SPARC 3단계 - DB 시스템의 구조적 계층 설명 - 사용자 화면 → ERD → 저장 구조</li>
<li>모델링 단계       - DB를 설계하는 절차 - 요구사항 분석 → ERD → 테이블/인덱스 설계</li>
</ol>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 20: 모델링 단계 = 개념 → 논리 → 물리</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">7</span><span class="token punctuation">]</span>  
다음 중 고객과 주문의 ERD에 대한 설명으로 가장 부적절한 것은?

① 한 명의 고객은 여러 개의 제품을 주문할 수 있다. 주문은 할 수도 있고 안 할 수도 있다.  
② 하나의 주문은 반드시 한 명의 고객에 의해 주문된다.  
③ 주문의 데이터를 입력할 때는 반드시 고객데이터가 존재해야 한다.  
④ 고객의 데이터를 입력할 때는 주문데이터가 존재하는 고객만을 입력할 수 있다.
</code></pre><div class="mermaid">erDiagram
    CUSTOMER {
        int 고객번호 PK
        string 고객이름
    }
    ORDER {
        int 주문번호 PK
        int 고객번호 FK
        int 주문수량
    }

    CUSTOMER ||--o{ ORDER : "주문"
</div><p>① 한 명의 고객은 여러 개의 제품을 주문할 수 있다. 주문은 할 수도 있고 안 할 수도 있다.<br>
② 하나의 주문은 반드시 한 명의 고객에 의해 주문된다.<br>
③ 주문의 데이터를 입력할 때는 반드시 고객데이터가 존재해야 한다.<br>
④ 고객의 데이터를 입력할 때는 주문데이터가 존재하는 고객만을 입력할 수 있다.</p>
<p><strong>정답:</strong> ④</p>
<p><strong>🧸 쉬운 해설</strong><br>
④번은 “주문한 고객만 등록돼!”라는 말인데, 그건 아니지~ 고객은 주문하지 않아도 존재할 수 있어!</p>
<p>**📚 전문 해설<br>
ERD에서 고객과 주문은 1:N 관계입니다.</p>
<ul>
<li>고객은 주문을 하지 않아도 존재 가능</li>
<li>주문은 반드시 고객에 의해 발생<br>
④번은 고객 등록을 주문 여부에 따라 제한하고 있어 부적절합니다.</li>
</ul>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>주문은 선택적</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>주문은 고객 필수</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>주문 시 고객 필요</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>고객은 주문한 경우만 등록</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
고객은 주문 없어도 존재 가능!<br>
주문은 고객이 있어야 가능!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 17: 식별 관계 = 생명주기 공유</li>
<li>🃏 카드 18: 비식별 관계 = 독립적 연결</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">8</span><span class="token punctuation">]</span>  
다음 중 ERD에 대한 설명으로 가장 부적절한 것은?

① <span class="token number">1976</span>년 피터첸<span class="token punctuation">(</span>Peter Chen<span class="token punctuation">)</span>에 의해 Entity-Relationship Model<span class="token punctuation">(</span>E-R Model<span class="token punctuation">)</span>이라는 표기기법이 탄생하였다.  
② 일반적으로 ERD를 작성할 때에는 엔터티들을 도형에 배치 → 관계 설정 → 관계명 기술 → 관계차수 기술 순으로 진행한다.  
③ ERD 작성의 목적은 분석된 업무에 대해 데이터 측면에서 모델을 명확하게 표현하기 위함이다.  
④ 가장 중요한 엔터티를 우선 배치하여 작성해 나가며, 애매한 엔터티들은 원칙과 규칙에 따라 배치하는 것이 일반적이다.
</code></pre><p><strong>정답:</strong> ④</p>
<p><strong>🧸 쉬운 해설</strong><br>
ERD는 전체 흐름과 관계를 고려해서 배치해야 해요. ④번은 “중요한 것부터 막 배치해!”라는 말인데,  그건 ERD 방식이 아니야!</p>
<p><strong>📚 전문 해설</strong><br>
ERD는 전체 흐름과 관계를 고려하여 배치해야 하며, 중요도보다는 구조적 연결성과 업무 흐름이 우선입니다.   ④번은 무조건 중요 엔터티부터 배치한다는 오해를 줍니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>ERD 창시자</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>작성 순서</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>데이터 표현 목적</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>중요도 우선 배치</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
ERD 작성 순서: <strong>도형 → 관계 → 이름 → 차수</strong><br>
중요도보다 구조와 흐름이 우선!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 1: 모델링 = 현실을 추상화하여 표현하는 기술</li>
<li>🃏 카드 14: 엔터티 분류 = 유·개·사 / 기·중·행</li>
</ul>
<h6 id="1-유개사--유형--개념--사건-엔터티">① <strong>유·개·사</strong> = <strong>유형 / 개념 / 사건 엔터티</strong> </h6>
<table>
<thead>
<tr>
<th>축약</th>
<th>의미</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>유</strong></td>
<td>유형 엔터티</td>
<td>실체가 있는 것 (예: 학생, 제품, 직원)</td>
</tr>
<tr>
<td><strong>개</strong></td>
<td>개념 엔터티</td>
<td>실체는 없지만 관리 대상인 것 (예: 과목, 부서, 직급)</td>
</tr>
<tr>
<td><strong>사</strong></td>
<td>사건 엔터티</td>
<td>활동이나 이벤트 (예: 수강신청, 주문, 입사기록)</td>
</tr>
</tbody>
</table>
<h6 id="2-기중행--기본--중심--행위-엔터티">② <strong>기·중·행</strong> = <strong>기본 / 중심 / 행위 엔터티</strong> </h6>
<table>
<thead>
<tr>
<th>축약</th>
<th>의미</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>기</strong></td>
<td>기본 엔터티</td>
<td>독립적으로 존재, 다른 엔터티에 의존하지 않음 (예: 회원, 상품)</td>
</tr>
<tr>
<td><strong>중</strong></td>
<td>중심 엔터티</td>
<td>기본 엔터티 간 관계를 연결 (예: 주문, 수강신청)</td>
</tr>
<tr>
<td><strong>행</strong></td>
<td>행위 엔터티</td>
<td>업무 처리 과정에서 발생하는 기록 (예: 결제내역, 출결기록)</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>유·개·사</strong>: “<strong>무엇을 관리할까?</strong>” → 실체, 개념, 사건</li>
<li><strong>기·중·행</strong>: “<strong>어떻게 연결되고 기록될까?</strong>” → 독립, 연결, 기록</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">9</span><span class="token punctuation">]</span>  
다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?

<span class="token operator">&gt;</span> S병원은 여러 명의 환자가 존재하고 각 환자에 대한 이름, 주소 등을 관리하여야 한다. <span class="token punctuation">(</span>단, 환자에 대한 엔터티의 특성을 살려 시나리오에 기술되어 있는 단어 중 단수형으로 대명사여야 함<span class="token punctuation">)</span>

① 이름  
② 환자  
③ 나이  
④ 주소  
</code></pre><p><strong>정답:</strong> ②</p>
<p><strong>해설:</strong><br>
병원에서는 ‘환자’를 관리하려고 해요.  ‘이름’, ‘주소’, ‘나이’는 환자에 대한 정보일 뿐, 관리 대상은 아니에요.  그래서 ‘환자’가 엔터티로 가장 적절해요.</p>
<p><strong>📚 전문 해설</strong><br>
엔터티는 관리 대상이며, 속성은 그 대상의 특징입니다.<br>
‘환자’는 관리 대상이고, 이름·주소·나이 등은 속성입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>이름</td>
<td>❌ 환자정보</td>
</tr>
<tr>
<td>②</td>
<td>환자</td>
<td>✅ 관리대상</td>
</tr>
<tr>
<td>③</td>
<td>나이</td>
<td>❌ 환자정보</td>
</tr>
<tr>
<td>④</td>
<td>주소</td>
<td>❌ 환자정보</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
엔터티는 <strong>누구를 관리할지</strong>를 나타내는 단어!<br>
속성은 그 대상의 <strong>정보</strong>!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 1: 엔터티 = 관리할 대상</li>
<li>🃏 카드 2: 속성 = 대상의 특징</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">10</span><span class="token punctuation">]</span>  
다음 중 엔터티의 특징으로 가장 부적절한 것은?

① 속성이 없는 엔터티는 있을 수 없다. 엔터티는 반드시 속성을 가져야 한다.  
② 엔터티는 다른 엔터티와 관계가 있을 수 밖에 없다. 단독 엔터티는 없다.  
③ 객체지향적 디자인에서는 싱글턴 패턴처럼 단 하나의 인스턴스를 가지는 엔터티가 존재할 수 있다. 이와 유사히 엔터티는 단 <span class="token number">1</span>개의 인스턴스를 가질 수 있다.  
④ 데이터로 존재하고 업무에서 필요로 하면 해당 업무에 따라 엔터티로 성립될 수 있다.  
</code></pre><p><strong>정답:</strong> ③</p>
<p><strong>해설:</strong><br>
③번은 “이건 하나만 있어도 돼!”라고 말하는데, 데이터는 보통 여러 개가 있어야 하니까 틀린 거야!</p>
<p><strong>📚 전문 해설</strong><br>
엔터티는 반복적으로 사용되는 데이터를 표현합니다.  ③번은 객체지향의 싱글턴 개념을 데이터모델링에 적용한 것으로 부적절합니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>속성 필수</td>
<td>✅엔터티는 정보를 담아야</td>
</tr>
<tr>
<td>②</td>
<td>관계 필수</td>
<td>✅다른 엔터티와 연결</td>
</tr>
<tr>
<td>③</td>
<td>단일 인스턴스</td>
<td>❌ 하나만 존재한다는 건 객체지향 개념</td>
</tr>
<tr>
<td>④</td>
<td>업무 필요 기반</td>
<td>✅ 필요하면 엔터티로 만들 수 있어요</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
엔터티는 <strong>반복되는 데이터</strong>를 표현하는 거야!  객체지향의 싱글턴 개념은 데이터모델링에 적용하면 안 돼!<br>
❌ 싱글턴 개념은 모델링에 적용 불가</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 1: 엔터티 = 관리할 대상</li>
<li>🃏 카드 61: PRIMARY KEY = 고유 이름표</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">11</span><span class="token punctuation">]</span>  
다음 중 엔터티의 일반적인 특징으로 가장 부적절한 것은?

① 다른 엔터티와의 관계를 가지지 않는다.  
② 유일한 식별자에 의해 식별이 가능해야 한다.  
③ 엔터티는 업무 프로세스에 의해 이용되어야 한다.  
④ 엔터티는 반드시 속성을 포함해야 한다.
</code></pre><p><strong>정답:</strong> ①</p>
<p><strong>🧸 쉬운 해설:</strong><br>
①번은 “엔터티는 혼자야!”라고 말하는데, 데이터는 서로 연결돼야 하니까 틀렸어!</p>
<p><strong>📚 전문 해설:</strong><br>
엔터티는 일반적으로 다른 엔터티와 관계를 맺으며 업무 흐름을 구성합니다. ①번은 관계가 없다고 하여, 엔터티의 기본 개념에 어긋납니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>관계 없음</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>식별자 필요</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>업무 활용</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>속성 포함</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
엔터티는 <strong>속성 + 관계 + 식별자</strong>가 기본!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 1: 엔터티 = 관리할 대상</li>
<li>🃏 카드 61: PRIMARY KEY = 고유 이름표</li>
<li>🃏 카드 62: FOREIGN KEY = 연결 다리</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">12</span><span class="token punctuation">]</span>  
다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지며,  
사원, 부서, 고객, 상품, 지점 등이 예가 될 수 있는 엔터티로 가장 적절한 것은?

① 기본 엔터티 <span class="token punctuation">(</span>Key 엔터티<span class="token punctuation">)</span>  
② 중심 엔터티 <span class="token punctuation">(</span>Main 엔터티<span class="token punctuation">)</span>  
③ 행위 엔터티 <span class="token punctuation">(</span>Active 엔터티<span class="token punctuation">)</span>  
④ 개념 엔터티
</code></pre><p><strong>정답:</strong> ①</p>
<p><strong>🧸 쉬운 해설</strong><br>
①번은 “나는 내 이름으로 불려요!”라고 말하는 엔터티야.<br>
다른 엔터티한테 의존하지 않아!</p>
<p><strong>📚 전문 해설</strong><br>
기본 엔터티는 독립적으로 존재하며, 고유한 주식별자(PK)를 가집니다.<br>
사원, 부서, 고객 등은 다른 엔터티에 의존하지 않고 독립적으로 관리됩니다.</p>
<p><strong>🔍 보기 설명</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>기본 엔터티: 독립적이고 고유 식별자 보유</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>중심 엔터티: 전체 모델의 중심이지만 식별자 상속 여부와는 무관</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>행위 엔터티: 이벤트나 활동 중심</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>개념 엔터티: 추상적 개념</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
기본 엔터티 = <strong>고유 식별자 + 독립적 존재</strong><br>
예: 고객, 사원, 부서, 상품 등</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 14: 엔터티 분류 = 유·개·사 / 기·중·행</li>
<li>🃏 카드 61: PRIMARY KEY = 고유 이름표</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">13</span><span class="token punctuation">]</span>  
다음 중 엔터티의 이름을 부여하는 방법으로서 가장 부적절한 것은?

① 가능하면 약어를 사용하여 엔터티명을 부여한다.  
② 현업에서 사용하는 용어를 사용하여 업무와 관련성을 높인다.  
③ 엔터티명의 첫 글자는 반드시 한글로 표기한다.  
④ 엔터티명 생성 시 의미대로 간결하고 명확하도록 한다.
</code></pre><p><strong>정답:</strong> ①</p>
<p><strong>🧸 쉬운 해설</strong><br>
①번은 “엔터티 이름을 줄여서 쓰자!”는 말인데,<br>
줄이면 사람들이 무슨 뜻인지 몰라서 헷갈릴 수 있어!</p>
<p><strong>📚 전문 해설</strong><br>
엔터티명에 약어를 사용하면 의미가 불명확해지고, 커뮤니케이션에 혼란을 줄 수 있습니다.<br>
가능하면 약어 사용은 피하는 것이 원칙입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>약어 사용:  의미가 불명확해질 수 있음</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>현업 용어: 업무와 연결돼서 좋음</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>한글 표기: 일부 표준에서는 요구되기도 함</td>
<td>✅ (표준에 따라 다름)</td>
</tr>
<tr>
<td>④</td>
<td>간결 명확: 좋은 방식</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
엔터티명은 <strong>풀어서 명확하게!</strong><br>
❌ 약어는 혼란의 원인!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 1: 엔터티 = 관리할 대상</li>
<li>🃏 카드 19: 좋은 모델 = 완·중·재·통·의·업</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">14</span><span class="token punctuation">]</span>  
업무에서 필요로 하는 인스턴스에서 관리하고자 하는 의미상  
더 이상 분리되지 않는 최소의 데이터 단위를 무엇이라 하는가?
</code></pre><p><strong>정답:</strong> 속성</p>
<p><strong>🧸 쉬운 해설</strong><br>
속성은 “이름, 나이, 주소”처럼 하나하나의 정보야!</p>
<p><strong>📚 전문 해설</strong><br>
속성(Attribute)은 엔터티를 구성하는 가장 작은 정보 단위입니다.<br>
예: 고객이라는 엔터티는 이름, 주소, 전화번호 등의 속성으로 구성됩니다.</p>
<p>🧠 <strong>기억법:</strong><br>
속성 = <strong>더 이상 나눌 수 없는 정보 조각</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 2: 속성 = 대상의 특징</li>
<li>🃏 카드 15: 속성 구조 = 단일 / 복합 / 다중값</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">15</span><span class="token punctuation">]</span>  
다음 중 속성에 대한 설명으로 가장 부적절한 것은?

① 엔터티에 대한 자세하거나 구체적인 정보를 나타낸다.  
② 하나의 엔터티는 두 개 이상의 속성을 갖는다.  
③ 하나의 인스턴스에서 각각의 속성은 하나 이상의 속성값을 가질 수 있다.  
④ 속성은 독립적이다.
</code></pre><p><strong>정답:</strong> ③</p>
<p><strong>🧸 쉬운 해설</strong><br>
③번은 “이름이 두 개 있어도 돼!”라고 말하는데,<br>
한 사람은 이름 하나만 있어야지!</p>
<p><strong>📚 전문 해설</strong><br>
속성은 하나의 인스턴스에 대해 하나의 값만 가져야 합니다.<br>
③번은 하나의 속성이 여러 값을 가질 수 있다고 하여 1NF(제1정규형)에 위배됩니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>구체 정보</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>속성 여러 개</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>속성값 여러 개</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>속성은 독립적</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
속성은 <strong>하나의 값만</strong> 가져야 해요!  → 제1정규형(1NF) 위배 주의!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 15: 속성 구조 = 단일 / 복합 / 다중값</li>
<li>🃏 카드 5: 1NF = 셀 안에 값 하나만</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">16</span><span class="token punctuation">]</span>  
다음 중 아래와 같은 사례에서 속성에 대한 설명으로 가장 부적절한 것은?

<span class="token operator">&gt;</span> 우리은행은 예금구분<span class="token punctuation">(</span>보통예금, 정기예금 등<span class="token punctuation">)</span>과 이율, 예치기간, 예금잔액을 관리한다고 할 때,  
<span class="token operator">&gt;</span> 예금구분은 보통예금, 정기예금이라는 값을 가질 수 있으며, 이는 <span class="token number">1000</span>이상의 숫자로 표현되지 않는다.  
<span class="token operator">&gt;</span> 이율 속성은 소수점 이하 <span class="token number">5.0</span>% 또는 <span class="token number">3.0</span>%와 같은 숫자로 표현되며, 예치기간 속성은 년단위로 표시한다.  
<span class="token operator">&gt;</span> 예금잔액 속성은 원 단위로 숫자가 표현된다.

① 일반속성으로 코드 엔터티를 별도로 구성하고 참조하는 것이 관리상 효과적이다.  
② 예치기간은 기본<span class="token punctuation">(</span>BASIC<span class="token punctuation">)</span> 속성이다.  
③ 이자와 이율과 같은 파생<span class="token punctuation">(</span>DERIVED<span class="token punctuation">)</span> 속성일 수 있다.  
④ 예금분류는 설계<span class="token punctuation">(</span>DESIGNED<span class="token punctuation">)</span> 속성이다.
</code></pre><p><strong>정답:</strong> ③</p>
<p><strong>🧸 쉬운 해설</strong><br>
③번은 “이율은 계산해서 나오는 값이야!”라고 말하는데, 사실은 그냥 입력하는 값이야!<br>
이율은 계산된 값이 아니라 직접 입력되는 값이기 때문에 파생 속성이라고 보기 어려워요.<br>
파생 속성은 예를 들어 ‘총금액 = 단가 × 수량’처럼 계산된 결과를 저장하는 속성이에요.</p>
<p><strong>📚 전문 해설</strong><br>
파생 속성은 계산된 결과를 저장하는 속성입니다.<br>
이율은 직접 입력되는 값이므로 파생 속성이 아니라 기본 속성입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>코드 참조</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>예치기간 = 기본속성</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>이율 = 파생속성</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>예금분류 = 설계속성</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
파생 속성 = <strong>계산해서 나오는 값</strong><br>
이율은 직접 입력하는 값 → 기본 속성!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 15: 속성 구조 = 단일 / 복합 / 다중값</li>
<li>🃏 카드 3: 관계 = 연결선</li>
<li>🃏 카드 66: 도메인 무결성 = 값의 규칙</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">17</span><span class="token punctuation">]</span>  
다음 중 데이터를 조회할 때 빠른 성능을 낼 수 있도록 하기 위해  
원래 속성의 값을 계산하여 저장할 수 있도록 만든 속성으로 가장 적절한 것은?

① 파생속성 <span class="token punctuation">(</span>Derived Attribute<span class="token punctuation">)</span>  
② 기본속성 <span class="token punctuation">(</span>Basic Attribute<span class="token punctuation">)</span>  
③ 설계속성 <span class="token punctuation">(</span>Designed Attribute<span class="token punctuation">)</span>  
④ PK속성 <span class="token punctuation">(</span>Primary Key Attribute<span class="token punctuation">)</span>
</code></pre><p><strong>정답:</strong> ①</p>
<p><strong>🧸 쉬운 해설</strong><br>
①번은 “미리 계산해서 저장해두는 정보”야!</p>
<p><strong>📚 전문 해설</strong><br>
파생 속성은 계산된 값을 저장하여 조회 성능을 높이는 속성입니다.<br>
예: ‘총금액 = 단가 × 수량’ 같은 계산 결과를 미리 저장해두는 방식입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>계산된 값 저장</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>기본값: 그냥 있는 값</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>설계 속성: 설계 시 정의</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>PK속성: 식별자 속성</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
파생속성 = <strong>계산해서 미리 저장하는 값</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 15: 속성 구조 = 단일 / 복합 / 다중값</li>
<li>🃏 카드 66: 도메인 무결성 = 값의 규칙</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">18</span><span class="token punctuation">]</span>  
다음 중 아래 설명이 나타내는 데이터모델의 개념으로 가장 적절한 것은?

<span class="token operator">&gt;</span> 주문이라는 엔터티가 있을 때 단가라는 속성 값의 범위는 <span class="token number">100</span>에서 <span class="token number">10,000</span> 사이의 실수 값이며,  
<span class="token operator">&gt;</span> 제품명이라는 속성은 길이가 <span class="token number">20</span>자 이내의 문자열로 정의할 수 있다.

① 시스템카탈로그 <span class="token punctuation">(</span>System Catalog<span class="token punctuation">)</span>  
② 용어사전 <span class="token punctuation">(</span>Word Dictionary<span class="token punctuation">)</span>  
③ 속성사전 <span class="token punctuation">(</span>Attribute Dictionary<span class="token punctuation">)</span>  
④ 도메인 <span class="token punctuation">(</span>Domain<span class="token punctuation">)</span>
</code></pre><p><strong>정답:</strong> ④</p>
<p><strong>🧸 쉬운 해설</strong><br>
④번은 “이 값은 이 범위 안에서만 써야 해!”라는 뜻이야!</p>
<p><strong>📚 전문 해설</strong><br>
도메인은 속성 값이 가질 수 있는 <strong>범위나 형식</strong>을 정의하는 개념입니다.<br>
예: 단가는 100~10,000 사이의 숫자, 제품명은 20자 이내의 문자열 등.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>시스템카탈로그: DB 구조 정보 저장</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>용어 정의: 용어 정의</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>속성 목록: 속성 목록</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>도메인: 값의 범위와 형식 정의</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
도메인 = <strong>값의 허용 범위 + 형식</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 66: 도메인 무결성 = 값의 규칙</li>
<li>🃏 카드 65: CHECK = 조건 필터</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">19</span><span class="token punctuation">]</span>  
다음 중 데이터모델링을 할 때 속성의 명칭을 부여하는 방법으로 가장 부적절한 것은?

① 속성의 이름에 약어를 사용할 경우 그 의미를 명확하게 이해할 수 없고  혼돈을 초래하여 커뮤니케이션의 혼란을 야기할 수 있으므로 지나친  약어 사용은 가급적 제한하도록 한다.  
② 속성의 이름에는 서술식 용어는 사용하지 않도록 한다.  
③ 직원 엔터티의 이름, 고객 엔터티의 이름과 같이 각 엔터티별로 동일한  속성명을 사용하여 데이터모델의 일관성을 가져가는 것이 좋다.  
④ 데이터모델링 대상에서 사용하는 용어도 있고 외부에서 사용하는 용어도 있어 중복이 있을 때, 가급적 해당 업무에서 자주 사용하는 이름을  이용하도록 한다.
</code></pre><p><strong>정답:</strong> ③</p>
<p><strong>🧸 쉬운 해설</strong><br>
③번은 “모든 엔터티에 이름이라는 속성을 똑같이 써!”라는 말인데,<br>
그럼 헷갈릴 수 있어!</p>
<p><strong>📚 전문 해설</strong><br>
각 엔터티에 동일한 속성명을 사용하는 것은 혼동을 줄 수 있습니다.<br>
예: ‘이름’이라는 속성이 고객과 직원 모두에 있을 때, 구분이 어려워질 수 있습니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>약어 제한</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>서술식 지양</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>동일 속성명 반복 사용-혼동 유발</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>자주 쓰는 용어 우선</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
속성명은 <strong>명확하고 구분 가능하게!</strong><br>
❌ 모든 엔터티에 같은 이름 쓰면 혼란!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 2: 속성 = 대상의 특징</li>
<li>🃏 카드 19: 좋은 모델 = 완·중·재·통·의·업</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">20</span><span class="token punctuation">]</span>  
다음 중 데이터모델링의 관계에 대한 설명으로 가장 부적절한 것을 <span class="token number">2</span>개 고르시오.

① 관계는 존재에 의한 관계와 행위에 의한 관계로 구분될 수 있으나 ERD에서는 관계를 연결할 때, 존재와 행위를 구분하지 않고 단일화된 표기법을 사용한다.  
② UML<span class="token punctuation">(</span>Unified Modeling Language<span class="token punctuation">)</span>에는 클래스다이어그램의 관계 중  연관관계<span class="token punctuation">(</span>Association<span class="token punctuation">)</span>와 의존관계<span class="token punctuation">(</span>Dependency<span class="token punctuation">)</span>가 있고 이것은 실선과 점선의 표기법으로 다르게 표현이 된다.  
③ 관계는 존재에 의한 관계와 행위에 의한 관계로 구분될 수 있고 ERD 에서는 관계를 연결할 때, 존재와 행위를 구분하여 실선과 접선의 표기법으로 다르게 표현한다.  
④ UML<span class="token punctuation">(</span>Unified Modeling Language<span class="token punctuation">)</span>에는 클래스다이어그램의 관계 중  연관관계<span class="token punctuation">(</span>Association<span class="token punctuation">)</span>와 의존관계<span class="token punctuation">(</span>Dependency<span class="token punctuation">)</span>가 있고 있으나 구분하지 않고 단일화된 표기법을 사용한다.
</code></pre><p><strong>정답:</strong> ③, ④</p>
<p><strong>🧸 쉬운 해설</strong><br>
③번은 “ERD에서도 실선과 점선을 써!”라고 말하는데,<br>
ERD는 실선 하나로 표현해!</p>
<p><strong>📚 전문 해설</strong><br>
ERD에서는 관계를 연결할 때 존재적 관계와 행위적 관계를 <strong>구분하지 않고</strong> 단일한 표기법(보통 실선)을 사용합니다.<br>
③번은 ERD에서 실선과 점선을 구분한다고 했는데, 이는 UML의 특징이지 ERD의 특징이 아니에요.<br>
④번은 UML에서 연관관계와 의존관계를 구분하지 않는다고 했는데, 실제로는 **구분해서 다른 표기법(실선과 점선)**을 사용합니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>ERD = 실선 하나 (관계 구분 없이 단일 표기법 사용)</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>UML = 실선/점선 구분</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>ERD = 실선/점선 구분</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>UML = 방향성과 다중성 표현( UML에서 관계를 구분하지 않는다 )</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong></p>
<ul>
<li><strong>ERD</strong>는 관계를 <strong>단일 실선</strong>으로 표현</li>
<li><strong>UML</strong>은 관계를 <strong>실선(Association)</strong> 과 <strong>점선(Dependency)</strong> 으로 구분<br>
UML = 실선(연관), 점선(의존)<br>
❌ ERD에서 선을 구분하거나 UML에서 구분하지 않는다는 설명은 틀림!</li>
</ul>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 41: JOIN 유형 = INNER / LEFT / FULL</li>
<li>🃏 카드 20: 모델링 단계 = 개념 → 논리 → 물리</li>
</ul>

      </div>
      
      
    
    
    <script type="module">
// TODO: If ZenUML gets integrated into mermaid in the future,
//      we can remove the following lines.


var MERMAID_CONFIG = ({"startOnLoad":false});
if (typeof MERMAID_CONFIG !== 'undefined') {
  MERMAID_CONFIG.startOnLoad = false
  MERMAID_CONFIG.cloneCssStyles = false
  MERMAID_CONFIG.theme = "default"
}

mermaid.initialize(MERMAID_CONFIG || {})
if (typeof(window['Reveal']) !== 'undefined') {
  function mermaidRevealHelper(event) {
    var currentSlide = event.currentSlide
    var diagrams = currentSlide.querySelectorAll('.mermaid')
    for (var i = 0; i < diagrams.length; i++) {
      var diagram = diagrams[i]
      if (!diagram.hasAttribute('data-processed')) {
        mermaid.init(null, diagram, ()=> {
          Reveal.slide(event.indexh, event.indexv)
        })
      }
    }
  }
  Reveal.addEventListener('slidetransitionend', mermaidRevealHelper)
  Reveal.addEventListener('ready', mermaidRevealHelper)
  await mermaid.run({
    nodes: document.querySelectorAll('.mermaid')
  })
} else {
  await mermaid.run({
    nodes: document.querySelectorAll('.mermaid')
  })
}
</script>
    
    
    
  
    </body></html>