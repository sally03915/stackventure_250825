<!DOCTYPE html><html><head>
      <title>part004_4_sql_using_조건부집계</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\sally03915\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.19\crossnote\dependencies\katex\katex.min.css">
      
      
      <script type="text/javascript" src="file:///c:\Users\sally03915\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.19\crossnote\dependencies\mermaid\mermaid.min.js" charset="UTF-8"></script>
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<style>
pre, code {
  white-space: pre-wrap !important;
  word-break: break-word !important;
  overflow-x: hidden !important;
  display: block !important;
  max-width: 100% !important;
  box-sizing: border-box !important;
}
</style> 
<hr>
<h3 id="-sql-using">📁 SQL USING </h3>
<table>
<thead>
<tr>
<th>구간</th>
<th>문제 번호</th>
<th>주제</th>
<th>난이도</th>
</tr>
</thead>
<tbody>
<tr>
<td>1~15</td>
<td>065~079</td>
<td>관계 연산자, JOIN 실무, 집합 연산자</td>
<td>⭐⭐ 초~중급</td>
</tr>
<tr>
<td>16~30</td>
<td>080~094</td>
<td>INTERSECT, EXCEPT, 계층형 질의</td>
<td>⭐⭐⭐ 중~고급</td>
</tr>
<tr>
<td>31~45</td>
<td>095~109</td>
<td>집합 연산자, JOIN 조건, 서브쿼리 활용</td>
<td>⭐⭐⭐ 고급</td>
</tr>
<tr>
<td>46~63</td>
<td>110~127</td>
<td>실무형 SQL 로직, 집계, 조건부 연산</td>
<td>⭐⭐⭐⭐ 실무형</td>
</tr>
</tbody>
</table>
<h4 id="-4663번-110127-실무형-sql-로직-집계-조건부-연산">✅ 46~63번 (110~127): 실무형 SQL 로직, 집계, 조건부 연산 </h4>
<ul>
<li>조건부 집계, 서브쿼리 필터링, 복잡한 JOIN 조합을 실무 사례로 학습합니다.</li>
<li>SQL 성능, 정렬 우선순위, 집계 함수 조합까지 고급 SQL 로직을 익힙니다.</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">110</span><span class="token punctuation">]</span>  
자재발주 테이블에 SQL을 수행하여 아래와 같은 결과를 얻었다. 다음 중에 <span class="token punctuation">(</span>가<span class="token punctuation">)</span> 들어갈 문장으로 옳은 것은?
</code></pre><p>[테이블 1: 자재발주]</p>
<table>
<thead>
<tr>
<th>자재번호</th>
<th>발주처ID</th>
<th>발주일자</th>
<th>발주수량</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>001</td>
<td>20150102</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>20150103</td>
<td>200</td>
</tr>
<tr>
<td>2</td>
<td>001</td>
<td>20150102</td>
<td>200</td>
</tr>
<tr>
<td>2</td>
<td>002</td>
<td>20150102</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>001</td>
<td>20150103</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>002</td>
<td>20150103</td>
<td>200</td>
</tr>
</tbody>
</table>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token punctuation">[</span><span class="token keyword keyword-SQL">SQL</span><span class="token punctuation">]</span>
<span class="token keyword keyword-SELECT">SELECT</span> <span class="token keyword keyword-CASE">CASE</span> <span class="token keyword keyword-WHEN">WHEN</span> GROUPING<span class="token punctuation">(</span>자재번호<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword keyword-THEN">THEN</span> <span class="token string">'자재전체'</span>
        <span class="token keyword keyword-ELSE">ELSE</span> 자재번호 <span class="token keyword keyword-END">END</span> <span class="token keyword keyword-AS">AS</span> 자재번호
     <span class="token punctuation">,</span> <span class="token keyword keyword-CASE">CASE</span> <span class="token keyword keyword-WHEN">WHEN</span> GROUPING<span class="token punctuation">(</span>발주처ID<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword keyword-THEN">THEN</span> <span class="token string">'발주처전체'</span>
        <span class="token keyword keyword-ELSE">ELSE</span> 발주처ID <span class="token keyword keyword-END">END</span> <span class="token keyword keyword-AS">AS</span> 발주처ID
     <span class="token punctuation">,</span> <span class="token keyword keyword-CASE">CASE</span> <span class="token keyword keyword-WHEN">WHEN</span> GROUPING<span class="token punctuation">(</span>발주일자<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword keyword-THEN">THEN</span> <span class="token string">'발주일자전체'</span>
        <span class="token keyword keyword-ELSE">ELSE</span> 발주일자 <span class="token keyword keyword-END">END</span> <span class="token keyword keyword-AS">AS</span> 발주일자
     <span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>발주수량<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 발주수량합계
<span class="token keyword keyword-FROM">FROM</span> 자재발주
<span class="token punctuation">(</span>가<span class="token punctuation">)</span>
<span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> 자재번호<span class="token punctuation">,</span> 발주처ID<span class="token punctuation">,</span> 발주일자
</code></pre><p>[테이블 2: 결과]</p>
<table>
<thead>
<tr>
<th>자재번호</th>
<th>발주처ID</th>
<th>발주일자</th>
<th>발주수량합계</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>발주처전체</td>
<td>발주일자전체</td>
<td>300</td>
</tr>
<tr>
<td>2</td>
<td>발주처전체</td>
<td>발주일자전체</td>
<td>300</td>
</tr>
<tr>
<td>3</td>
<td>발주처전체</td>
<td>발주일자전체</td>
<td>300</td>
</tr>
<tr>
<td>자재전체</td>
<td>001</td>
<td>20150102</td>
<td>300</td>
</tr>
<tr>
<td>자재전체</td>
<td>001</td>
<td>20150103</td>
<td>300</td>
</tr>
<tr>
<td>자재전체</td>
<td>002</td>
<td>20150102</td>
<td>100</td>
</tr>
<tr>
<td>자재전체</td>
<td>002</td>
<td>20150103</td>
<td>200</td>
</tr>
</tbody>
</table>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code>① <span class="token keyword keyword-GROUP">GROUP</span> <span class="token keyword keyword-BY">BY</span> CUBE <span class="token punctuation">(</span>자재번호<span class="token punctuation">,</span> <span class="token punctuation">(</span>발주처ID<span class="token punctuation">,</span> 발주일자<span class="token punctuation">)</span><span class="token punctuation">)</span>
② <span class="token keyword keyword-GROUP">GROUP</span> <span class="token keyword keyword-BY">BY</span> CUBE <span class="token punctuation">(</span>자재번호<span class="token punctuation">,</span> 발주처ID<span class="token punctuation">,</span> 발주일자<span class="token punctuation">)</span>
③ <span class="token keyword keyword-GROUP">GROUP</span> <span class="token keyword keyword-BY">BY</span> GROUPING SETS <span class="token punctuation">(</span>자재번호<span class="token punctuation">,</span> 발주처ID<span class="token punctuation">,</span> 발주일자<span class="token punctuation">)</span>
④ <span class="token keyword keyword-GROUP">GROUP</span> <span class="token keyword keyword-BY">BY</span> GROUPING SETS <span class="token punctuation">(</span>자재번호<span class="token punctuation">,</span> <span class="token punctuation">(</span>발주처ID<span class="token punctuation">,</span> 발주일자<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><p><strong>✅ 정답:</strong> ④ GROUPING SETS (자재번호, (발주처ID, 발주일자))</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
자재번호별 전체 합계와 발주처ID+발주일자 조합별 합계를 따로 구해야 해요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>CUBE는 모든 조합을 집계하지만, 문제는 특정 조합만 요구</li>
<li>GROUPING SETS는 원하는 조합만 집계 가능</li>
<li>(자재번호), (발주처ID, 발주일자) → 정확한 조합</li>
</ul>
<h6 id="-전체-sql-정답-기준">✅ 전체 SQL (정답 기준) </h6>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> 
  <span class="token keyword keyword-CASE">CASE</span> <span class="token keyword keyword-WHEN">WHEN</span> GROUPING<span class="token punctuation">(</span>자재번호<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword keyword-THEN">THEN</span> <span class="token string">'자재전체'</span> <span class="token keyword keyword-ELSE">ELSE</span> 자재번호 <span class="token keyword keyword-END">END</span> <span class="token keyword keyword-AS">AS</span> 자재번호<span class="token punctuation">,</span>
  <span class="token keyword keyword-CASE">CASE</span> <span class="token keyword keyword-WHEN">WHEN</span> GROUPING<span class="token punctuation">(</span>발주처ID<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword keyword-THEN">THEN</span> <span class="token string">'발주처전체'</span> <span class="token keyword keyword-ELSE">ELSE</span> 발주처ID <span class="token keyword keyword-END">END</span> <span class="token keyword keyword-AS">AS</span> 발주처ID<span class="token punctuation">,</span>
  <span class="token keyword keyword-CASE">CASE</span> <span class="token keyword keyword-WHEN">WHEN</span> GROUPING<span class="token punctuation">(</span>발주일자<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword keyword-THEN">THEN</span> <span class="token string">'발주일자전체'</span> <span class="token keyword keyword-ELSE">ELSE</span> 발주일자 <span class="token keyword keyword-END">END</span> <span class="token keyword keyword-AS">AS</span> 발주일자<span class="token punctuation">,</span>
  <span class="token function">SUM</span><span class="token punctuation">(</span>발주수량<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 발주수량합계
<span class="token keyword keyword-FROM">FROM</span> 자재발주
<span class="token keyword keyword-GROUP">GROUP</span> <span class="token keyword keyword-BY">BY</span> GROUPING SETS <span class="token punctuation">(</span>
  <span class="token punctuation">(</span>자재번호<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span>발주처ID<span class="token punctuation">,</span> 발주일자<span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> 자재번호<span class="token punctuation">,</span> 발주처ID<span class="token punctuation">,</span> 발주일자<span class="token punctuation">;</span>
</code></pre><h6 id="-sql-처리-순서-한-줄씩-설명">🧠 SQL 처리 순서 한 줄씩 설명 </h6>
<h6 id="1️⃣-from-자재발주">1️⃣ <strong>FROM 자재발주</strong> </h6>
<ul>
<li>자재발주 테이블의 전체 데이터를 대상으로 시작합니다.</li>
</ul>
<h6 id="2️⃣-group-by-grouping-sets-자재번호-발주처id-발주일자">2️⃣ <strong>GROUP BY GROUPING SETS ((자재번호), (발주처ID, 발주일자))</strong> </h6>
<ul>
<li>두 가지 그룹핑 조합을 명시적으로 지정합니다:
<ul>
<li><strong>(자재번호)</strong> → 자재별 전체 발주량 합계</li>
<li><strong>(발주처ID, 발주일자)</strong> → 발주처와 일자 조합별 발주량 합계</li>
</ul>
</li>
<li>이 방식은 <strong>ROLLUP</strong>이나 <strong>CUBE</strong>처럼 모든 조합을 계산하지 않고, <strong>필요한 조합만 정확히 집계</strong>합니다.</li>
</ul>
<h6 id="3️⃣-sum발주수량">3️⃣ <strong>SUM(발주수량)</strong> </h6>
<ul>
<li>각 그룹에 대해 발주수량을 합산합니다.</li>
<li>예:
<ul>
<li>자재번호 1 → 100 + 200 = 300</li>
<li>발주처ID 001, 발주일자 20150102 → 100 + 200 = 300</li>
</ul>
</li>
</ul>
<h6 id="4️⃣-grouping컬럼-함수들">4️⃣ <strong>GROUPING(컬럼)</strong> 함수들 </h6>
<ul>
<li><strong>GROUPING(자재번호)</strong> = 1 → 자재번호가 NULL인 집계행 (즉, 자재전체)</li>
<li><strong>GROUPING(발주처ID)</strong> = 1 → 발주처ID가 NULL인 집계행 (즉, 발주처전체)</li>
<li><strong>GROUPING(발주일자)</strong> = 1 → 발주일자가 NULL인 집계행 (즉, 발주일자전체)</li>
</ul>
<p>➡ 이 값들을 이용해 <strong>CASE WHEN</strong>으로 라벨링합니다.</p>
<h6 id="5️⃣-select-">5️⃣ <strong>SELECT ...</strong> </h6>
<ul>
<li>각 그룹의 결과를 출력합니다.</li>
<li><strong>GROUPING</strong> 결과에 따라 '자재전체', '발주처전체', '발주일자전체' 등의 라벨이 붙습니다.</li>
</ul>
<h6 id="6️⃣-order-by-자재번호-발주처id-발주일자">6️⃣ <strong>ORDER BY 자재번호, 발주처ID, 발주일자</strong> </h6>
<ul>
<li>결과를 자재번호 → 발주처ID → 발주일자 순으로 정렬합니다.</li>
<li>NULL은 정렬상 가장 마지막 또는 처음에 위치할 수 있음 (DBMS에 따라 다름)</li>
</ul>
<h6 id="-핵심-요약">📌 핵심 요약 </h6>
<table>
<thead>
<tr>
<th>처리 단계</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>GROUPING SETS</strong></td>
<td>자재번호별 + (발주처ID, 발주일자)별 집계</td>
</tr>
<tr>
<td><strong>GROUPING()</strong></td>
<td>NULL 여부로 소계/합계 판단</td>
</tr>
<tr>
<td><strong>SUM()</strong></td>
<td>발주수량 합산</td>
</tr>
<tr>
<td><strong>CASE</strong></td>
<td>라벨링 처리</td>
</tr>
<tr>
<td><strong>ORDER BY</strong></td>
<td>정렬 기준 적용</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>중첩 CUBE → 과도한 집계</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>전체 조합 → 과도함</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>단일 컬럼만 집계</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>정확한 조합만 집계</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
GROUPING SETS = 원하는 조합만 집계</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 24: GROUP BY</li>
<li>🃏 카드 43: 윈도우 함수 예시</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">111</span><span class="token punctuation">]</span> 
다음 중 월별매출 테이블을 대상으로 아래 SQL을 수행한 결과인 것은?
</code></pre><p>[테이블 1: 제품 매출현황]</p>
<table>
<thead>
<tr>
<th>상품ID</th>
<th>일자</th>
<th>매출액</th>
</tr>
</thead>
<tbody>
<tr>
<td>P001</td>
<td>2014.10</td>
<td>1500</td>
</tr>
<tr>
<td>P001</td>
<td>2014.11</td>
<td>1600</td>
</tr>
<tr>
<td>P001</td>
<td>2014.12</td>
<td>2500</td>
</tr>
<tr>
<td>P002</td>
<td>2014.10</td>
<td>1000</td>
</tr>
<tr>
<td>P002</td>
<td>2014.11</td>
<td>2000</td>
</tr>
<tr>
<td>P002</td>
<td>2014.12</td>
<td>1500</td>
</tr>
<tr>
<td>P003</td>
<td>2014.10</td>
<td>2000</td>
</tr>
<tr>
<td>P003</td>
<td>2014.11</td>
<td>1000</td>
</tr>
<tr>
<td>P003</td>
<td>2014.12</td>
<td>1000</td>
</tr>
</tbody>
</table>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token punctuation">[</span><span class="token keyword keyword-SQL">SQL</span><span class="token punctuation">]</span>
<span class="token keyword keyword-SELECT">SELECT</span> 상품ID<span class="token punctuation">,</span> 월<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>매출액<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 매출액
<span class="token keyword keyword-FROM">FROM</span>  월별매출
<span class="token keyword keyword-WHERE">WHERE</span> 월 <span class="token operator">BETWEEN</span> <span class="token string">'2014.10'</span> <span class="token operator">AND</span> <span class="token string">'2014.12'</span>
<span class="token keyword keyword-GROUP">GROUP</span> <span class="token keyword keyword-BY">BY</span> GROUPING SETS<span class="token punctuation">(</span><span class="token punctuation">(</span>상품ID<span class="token punctuation">,</span> 월<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>①</p>
<table>
<thead>
<tr>
<th>상품ID</th>
<th>일자</th>
<th>매출액</th>
</tr>
</thead>
<tbody>
<tr>
<td>NULL</td>
<td>2014.10</td>
<td>4500</td>
</tr>
<tr>
<td>NULL</td>
<td>2014.11</td>
<td>4500</td>
</tr>
<tr>
<td>NULL</td>
<td>2014.12</td>
<td>5000</td>
</tr>
<tr>
<td>P001</td>
<td>NULL</td>
<td>5500</td>
</tr>
<tr>
<td>P002</td>
<td>NULL</td>
<td>4500</td>
</tr>
<tr>
<td>P003</td>
<td>NULL</td>
<td>4000</td>
</tr>
</tbody>
</table>
<p>②</p>
<table>
<thead>
<tr>
<th>상품ID</th>
<th>일자</th>
<th>매출액</th>
</tr>
</thead>
<tbody>
<tr>
<td>P001</td>
<td>2014.10</td>
<td>1500</td>
</tr>
<tr>
<td>P001</td>
<td>2014.11</td>
<td>1500</td>
</tr>
<tr>
<td>P001</td>
<td>2014.12</td>
<td>2500</td>
</tr>
<tr>
<td>P002</td>
<td>2014.10</td>
<td>1000</td>
</tr>
<tr>
<td>P002</td>
<td>2014.11</td>
<td>2000</td>
</tr>
<tr>
<td>P002</td>
<td>2014.12</td>
<td>1500</td>
</tr>
<tr>
<td>P003</td>
<td>2014.10</td>
<td>2000</td>
</tr>
<tr>
<td>P003</td>
<td>2014.11</td>
<td>1000</td>
</tr>
<tr>
<td>P003</td>
<td>2014.12</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>③</p>
<table>
<thead>
<tr>
<th>상품ID</th>
<th>일자</th>
<th>매출액</th>
</tr>
</thead>
<tbody>
<tr>
<td>NULL</td>
<td>2014.10</td>
<td>4500</td>
</tr>
<tr>
<td>NULL</td>
<td>2014.11</td>
<td>4500</td>
</tr>
<tr>
<td>NULL</td>
<td>2014.12</td>
<td>5000</td>
</tr>
<tr>
<td>P001</td>
<td>NULL</td>
<td>5500</td>
</tr>
<tr>
<td>P002</td>
<td>NULL</td>
<td>4500</td>
</tr>
<tr>
<td>P003</td>
<td>NULL</td>
<td>4000</td>
</tr>
<tr>
<td>NULL</td>
<td>NULL</td>
<td>14000</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>④</p>
<table>
<thead>
<tr>
<th>상품ID</th>
<th>일자</th>
<th>매출액</th>
</tr>
</thead>
<tbody>
<tr>
<td>P001</td>
<td>2014.10</td>
<td>1500</td>
</tr>
<tr>
<td>P002</td>
<td>2014.10</td>
<td>1000</td>
</tr>
<tr>
<td>P003</td>
<td>2014.10</td>
<td>2000</td>
</tr>
<tr>
<td>NULL</td>
<td>2014.10</td>
<td>4500</td>
</tr>
<tr>
<td>P001</td>
<td>2014.11</td>
<td>1500</td>
</tr>
<tr>
<td>P002</td>
<td>2014.11</td>
<td>2000</td>
</tr>
<tr>
<td>P003</td>
<td>2014.11</td>
<td>1000</td>
</tr>
<tr>
<td>NULL</td>
<td>2014.11</td>
<td>4500</td>
</tr>
<tr>
<td>P001</td>
<td>2014.12</td>
<td>2500</td>
</tr>
<tr>
<td>P002</td>
<td>2014.12</td>
<td>1500</td>
</tr>
<tr>
<td>P003</td>
<td>2014.12</td>
<td>1000</td>
</tr>
<tr>
<td>NULL</td>
<td>2014.12</td>
<td>5000</td>
</tr>
</tbody>
</table>
<p><strong>✅ 정답:</strong> ②</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
GROUPING SETS((상품ID, 월))은 상품ID와 월 조합만 집계해요. 소계나 합계는 포함되지 않아요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>GROUPING SETS((상품ID, 월)) → 단일 조합만 집계</li>
<li>NULL이 포함된 소계/합계는 생성되지 않음</li>
<li>결과는 상품ID별 월별 매출만 나옴</li>
</ul>
<h6 id="-전체-sql">✅ 전체 SQL </h6>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> 상품ID<span class="token punctuation">,</span> 월<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>매출액<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 매출액
<span class="token keyword keyword-FROM">FROM</span> 월별매출
<span class="token keyword keyword-WHERE">WHERE</span> 월 <span class="token operator">BETWEEN</span> <span class="token string">'2014.10'</span> <span class="token operator">AND</span> <span class="token string">'2014.12'</span>
<span class="token keyword keyword-GROUP">GROUP</span> <span class="token keyword keyword-BY">BY</span> GROUPING SETS<span class="token punctuation">(</span><span class="token punctuation">(</span>상품ID<span class="token punctuation">,</span> 월<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h6 id="-sql-처리-순서-설명">🧠 SQL 처리 순서 설명 </h6>
<h6 id="1️⃣-from-월별매출">1️⃣ <strong>FROM 월별매출</strong> </h6>
<ul>
<li>전체 테이블을 대상으로 시작합니다.</li>
<li>테이블에는 상품ID, 월, 매출액이 포함되어 있습니다.</li>
</ul>
<h6 id="2️⃣-where-월-between-201410-and-201412">2️⃣ <strong>WHERE 월 BETWEEN '2014.10' AND '2014.12'</strong> </h6>
<ul>
<li>조건에 따라 월이 2014년 10월부터 12월까지인 행만 선택됩니다.</li>
<li>필터링된 행:</li>
</ul>
<table>
<thead>
<tr>
<th>상품ID</th>
<th>월</th>
<th>매출액</th>
</tr>
</thead>
<tbody>
<tr>
<td>P001</td>
<td>2014.10</td>
<td>1500</td>
</tr>
<tr>
<td>P001</td>
<td>2014.11</td>
<td>1600</td>
</tr>
<tr>
<td>P001</td>
<td>2014.12</td>
<td>2500</td>
</tr>
<tr>
<td>P002</td>
<td>2014.10</td>
<td>1000</td>
</tr>
<tr>
<td>P002</td>
<td>2014.11</td>
<td>2000</td>
</tr>
<tr>
<td>P002</td>
<td>2014.12</td>
<td>1500</td>
</tr>
<tr>
<td>P003</td>
<td>2014.10</td>
<td>2000</td>
</tr>
<tr>
<td>P003</td>
<td>2014.11</td>
<td>1000</td>
</tr>
<tr>
<td>P003</td>
<td>2014.12</td>
<td>1000</td>
</tr>
</tbody>
</table>
<h6 id="3️⃣-group-by-grouping-sets상품id-월">3️⃣ <strong>GROUP BY GROUPING SETS((상품ID, 월))</strong> </h6>
<ul>
<li><strong>GROUPING SETS</strong>는 명시적으로 집계 조합을 지정합니다.</li>
<li>여기서는 **(상품ID, 월)**만 집계하므로:
<ul>
<li>상품ID별 월별 매출만 계산</li>
<li>소계(상품ID만), 월별 합계(월만), 전체 합계는 <strong>포함되지 않음</strong></li>
</ul>
</li>
</ul>
<h6 id="4️⃣-sum매출액">4️⃣ <strong>SUM(매출액)</strong> </h6>
<ul>
<li>각 <strong>(상품ID, 월)</strong> 조합에 대해 매출액을 합산합니다.</li>
<li>예:
<ul>
<li>P001, 2014.10 → 1500</li>
<li>P002, 2014.11 → 2000</li>
<li>P003, 2014.12 → 1000</li>
</ul>
</li>
</ul>
<h6 id="5️⃣-select-상품id-월-sum매출액">5️⃣ <strong>SELECT 상품ID, 월, SUM(매출액)</strong> </h6>
<ul>
<li>각 그룹의 결과를 출력합니다.</li>
<li>NULL이 포함된 행은 없으며, 모두 실제 상품ID와 월 값이 존재합니다.</li>
</ul>
<h6 id="-핵심-요약-1">📌 핵심 요약 </h6>
<table>
<thead>
<tr>
<th>처리 단계</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FROM</strong></td>
<td>월별매출 테이블 전체 조회</td>
</tr>
<tr>
<td><strong>WHERE</strong></td>
<td>2014.10 ~ 2014.12 필터링</td>
</tr>
<tr>
<td><strong>GROUPING SETS((상품ID, 월))</strong></td>
<td>상품ID + 월 조합만 집계</td>
</tr>
<tr>
<td><strong>SUM()</strong></td>
<td>매출액 합산</td>
</tr>
<tr>
<td><strong>SELECT</strong></td>
<td>결과 출력 (소계/합계 없음)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>소계 포함 → 과도함</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>정확한 조합만 출력</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>전체 합계 포함 → 과도함</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>소계 포함 → 과도함</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
GROUPING SETS = 지정된 조합만 집계</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 24: GROUP BY</li>
<li>🃏 카드 43: 윈도우 함수 예시</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">112</span><span class="token punctuation">]</span>  
다음 중 윈도우 함수<span class="token punctuation">(</span>Window Function, Analytic Function<span class="token punctuation">)</span>에 대한 설명으로 가장 부적절한 것은?

① Partition과 Group By 구문은 의미적으로 유사하다.
② Partition 구분이 없으면 전체 집합을 하나의 Partition으로 정의한 것과 동일하다.
③ 윈도우 함수 처리로 인해 결과 건수가 줄어든다.
④ 윈도우 함수 적용 범위는 Partition을 넘을 수 없다.
</code></pre><p><strong>✅ 정답:</strong> ③</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
윈도우 함수는 결과 건수를 줄이지 않아요! 기존 행 수를 유지하면서 계산만 추가해요.</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>윈도우 함수는 집계 결과를 각 행에 붙이는 방식</li>
<li>PARTITION은 그룹을 나누는 기준</li>
<li>결과 건수는 그대로 유지됨</li>
</ul>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>PARTITION과 GROUP BY 유사</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>PARTITION 없으면 전체</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>결과 건수 줄어든다 → 오류</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>PARTITION 범위 제한 설명</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
윈도우 함수 = 행 수 유지 + 계산 추가</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 43: 윈도우 함수 예시</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">113</span><span class="token punctuation">]</span>  
다음 중 아래와 같은 테이블에서 SQL을 실행할 때 결과로 가장 적절한 것은?
</code></pre><p>[테이블 1: 고객]</p>
<table>
<thead>
<tr>
<th>고객번호(PK)</th>
<th>고객명</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>홍길동</td>
</tr>
<tr>
<td>002</td>
<td>이순신</td>
</tr>
<tr>
<td>003</td>
<td>강감찬</td>
</tr>
<tr>
<td>004</td>
<td>이상화</td>
</tr>
<tr>
<td>005</td>
<td>이규혁</td>
</tr>
</tbody>
</table>
<p>[테이블 2: 월별매출]</p>
<table>
<thead>
<tr>
<th>월(PK)</th>
<th>고객번호(PK)</th>
<th>매출액</th>
</tr>
</thead>
<tbody>
<tr>
<td>201301</td>
<td>001</td>
<td>200</td>
</tr>
<tr>
<td>201301</td>
<td>002</td>
<td>300</td>
</tr>
<tr>
<td>201301</td>
<td>003</td>
<td>250</td>
</tr>
<tr>
<td>201301</td>
<td>004</td>
<td>300</td>
</tr>
<tr>
<td>201301</td>
<td>005</td>
<td>250</td>
</tr>
<tr>
<td>201302</td>
<td>001</td>
<td>150</td>
</tr>
<tr>
<td>201302</td>
<td>002</td>
<td>150</td>
</tr>
<tr>
<td>201302</td>
<td>004</td>
<td>200</td>
</tr>
<tr>
<td>201302</td>
<td>005</td>
<td>100</td>
</tr>
<tr>
<td>201303</td>
<td>002</td>
<td>100</td>
</tr>
<tr>
<td>201303</td>
<td>003</td>
<td>100</td>
</tr>
<tr>
<td>201303</td>
<td>004</td>
<td>200</td>
</tr>
<tr>
<td>201303</td>
<td>005</td>
<td>350</td>
</tr>
</tbody>
</table>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token punctuation">[</span><span class="token keyword keyword-SQL">SQL</span><span class="token punctuation">]</span>
<span class="token keyword keyword-SELECT">SELECT</span> 고객번호<span class="token punctuation">,</span> 고객명<span class="token punctuation">,</span> 매출액
      <span class="token punctuation">,</span> RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span><span class="token punctuation">(</span><span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> 매출액 <span class="token keyword keyword-DESC">DESC</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 순위
<span class="token keyword keyword-FROM">FROM</span> <span class="token punctuation">(</span>
    <span class="token keyword keyword-SELECT">SELECT</span> A<span class="token punctuation">.</span>고객번호
        <span class="token punctuation">,</span> <span class="token function">MAX</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>고객명<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 고객명
        <span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>매출액<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 매출액
    <span class="token keyword keyword-FROM">FROM</span> 고객 A <span class="token keyword keyword-INNER">INNER</span> <span class="token keyword keyword-JOIN">JOIN</span> 월별매출 B
    <span class="token keyword keyword-ON">ON</span> <span class="token punctuation">(</span>A<span class="token punctuation">.</span>고객번호 <span class="token operator">=</span> B<span class="token punctuation">.</span>고객번호<span class="token punctuation">)</span>
    <span class="token keyword keyword-GROUP">GROUP</span> <span class="token keyword keyword-BY">BY</span> A<span class="token punctuation">.</span>고객번호
    <span class="token punctuation">)</span>
<span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> RNK<span class="token punctuation">;</span>
</code></pre><p>①</p>
<table>
<thead>
<tr>
<th>고객번호</th>
<th>고객명</th>
<th>매출액</th>
<th>순위</th>
</tr>
</thead>
<tbody>
<tr>
<td>005</td>
<td>이규혁</td>
<td>700</td>
<td>1</td>
</tr>
<tr>
<td>004</td>
<td>이상화</td>
<td>700</td>
<td>1</td>
</tr>
<tr>
<td>002</td>
<td>이순신</td>
<td>550</td>
<td>3</td>
</tr>
<tr>
<td>001</td>
<td>홍길동</td>
<td>350</td>
<td>4</td>
</tr>
<tr>
<td>003</td>
<td>강감찬</td>
<td>350</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>②</p>
<table>
<thead>
<tr>
<th>고객번호</th>
<th>고객명</th>
<th>매출액</th>
<th>순위</th>
</tr>
</thead>
<tbody>
<tr>
<td>005</td>
<td>이규혁</td>
<td>700</td>
<td>1</td>
</tr>
<tr>
<td>004</td>
<td>이상화</td>
<td>700</td>
<td>2</td>
</tr>
<tr>
<td>002</td>
<td>이순신</td>
<td>550</td>
<td>3</td>
</tr>
<tr>
<td>001</td>
<td>홍길동</td>
<td>350</td>
<td>4</td>
</tr>
<tr>
<td>003</td>
<td>강감찬</td>
<td>350</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>③</p>
<table>
<thead>
<tr>
<th>고객번호</th>
<th>고객명</th>
<th>매출액</th>
<th>순위</th>
</tr>
</thead>
<tbody>
<tr>
<td>005</td>
<td>이규혁</td>
<td>700</td>
<td>1</td>
</tr>
<tr>
<td>004</td>
<td>이상화</td>
<td>700</td>
<td>1</td>
</tr>
<tr>
<td>002</td>
<td>이순신</td>
<td>550</td>
<td>2</td>
</tr>
<tr>
<td>001</td>
<td>홍길동</td>
<td>350</td>
<td>3</td>
</tr>
<tr>
<td>003</td>
<td>강감찬</td>
<td>350</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>④</p>
<table>
<thead>
<tr>
<th>고객번호</th>
<th>고객명</th>
<th>매출액</th>
<th>순위</th>
</tr>
</thead>
<tbody>
<tr>
<td>003</td>
<td>강감찬</td>
<td>350</td>
<td>1</td>
</tr>
<tr>
<td>001</td>
<td>홍길동</td>
<td>350</td>
<td>1</td>
</tr>
<tr>
<td>002</td>
<td>이순신</td>
<td>550</td>
<td>2</td>
</tr>
<tr>
<td>004</td>
<td>이상화</td>
<td>700</td>
<td>3</td>
</tr>
<tr>
<td>005</td>
<td>이규혁</td>
<td>700</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><strong>✅ 정답:</strong> ①</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
RANK는 동점자에게 같은 순위를 주고 다음 순위를 건너뛰어요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>SUM으로 고객별 매출 집계</li>
<li>RANK() OVER(ORDER BY 매출액 DESC) → 동점 처리</li>
<li>700점 2명 → 순위 1, 다음은 3</li>
</ul>
<h6 id="-전체-sql-1">✅ 전체 SQL </h6>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> 고객번호<span class="token punctuation">,</span> 고객명<span class="token punctuation">,</span> 매출액<span class="token punctuation">,</span>
       RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span><span class="token punctuation">(</span><span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> 매출액 <span class="token keyword keyword-DESC">DESC</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 순위
<span class="token keyword keyword-FROM">FROM</span> <span class="token punctuation">(</span>
    <span class="token keyword keyword-SELECT">SELECT</span> A<span class="token punctuation">.</span>고객번호<span class="token punctuation">,</span>
           <span class="token function">MAX</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>고객명<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 고객명<span class="token punctuation">,</span>
           <span class="token function">SUM</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>매출액<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 매출액
    <span class="token keyword keyword-FROM">FROM</span> 고객 A
    <span class="token keyword keyword-INNER">INNER</span> <span class="token keyword keyword-JOIN">JOIN</span> 월별매출 B <span class="token keyword keyword-ON">ON</span> A<span class="token punctuation">.</span>고객번호 <span class="token operator">=</span> B<span class="token punctuation">.</span>고객번호
    <span class="token keyword keyword-GROUP">GROUP</span> <span class="token keyword keyword-BY">BY</span> A<span class="token punctuation">.</span>고객번호
<span class="token punctuation">)</span>
<span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> 순위<span class="token punctuation">;</span>
</code></pre><h6 id="-sql-처리-순서-한-줄씩-설명-1">🧠 SQL 처리 순서 한 줄씩 설명 </h6>
<h6 id="1️⃣-from-고객-a-inner-join-월별매출-b-on-a고객번호--b고객번호">1️⃣ <strong>FROM 고객 A INNER JOIN 월별매출 B ON A.고객번호 = B.고객번호</strong> </h6>
<ul>
<li>고객 테이블과 월별매출 테이블을 고객번호 기준으로 연결합니다.</li>
<li>결과: 고객별 월별 매출 데이터가 결합된 행들</li>
</ul>
<h6 id="2️⃣-group-by-a고객번호">2️⃣ <strong>GROUP BY A.고객번호</strong> </h6>
<ul>
<li>고객번호별로 그룹화하여 집계 준비</li>
</ul>
<h6 id="3️⃣-sumb매출액-as-매출액">3️⃣ <strong>SUM(B.매출액) AS 매출액</strong> </h6>
<ul>
<li>각 고객에 대해 매출액을 합산합니다</li>
</ul>
<table>
<thead>
<tr>
<th>고객번호</th>
<th>매출액</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>200 + 150 = 350</td>
</tr>
<tr>
<td>002</td>
<td>300 + 150 + 100 = 550</td>
</tr>
<tr>
<td>003</td>
<td>250 + 100 = 350</td>
</tr>
<tr>
<td>004</td>
<td>300 + 200 + 200 = 700</td>
</tr>
<tr>
<td>005</td>
<td>250 + 100 + 350 = 700</td>
</tr>
</tbody>
</table>
<h6 id="4️⃣-maxa고객명-as-고객명">4️⃣ <strong>MAX(A.고객명) AS 고객명</strong> </h6>
<ul>
<li>고객명은 그룹화된 고객번호별로 하나만 선택</li>
<li>**MAX()**는 단일값을 반환하기 위한 집계 함수로 사용됨</li>
</ul>
<h6 id="5️⃣-rank-overorder-by-매출액-desc-as-순위">5️⃣ <strong>RANK() OVER(ORDER BY 매출액 DESC) AS 순위</strong> </h6>
<ul>
<li>매출액 기준으로 내림차순 정렬하여 순위를 매깁니다</li>
<li>**RANK()**는 동점자에게 같은 순위를 부여하고, 다음 순위를 건너뜁니다</li>
</ul>
<table>
<thead>
<tr>
<th>매출액</th>
<th>순위</th>
</tr>
</thead>
<tbody>
<tr>
<td>700</td>
<td>1</td>
</tr>
<tr>
<td>700</td>
<td>1</td>
</tr>
<tr>
<td>550</td>
<td>3</td>
</tr>
<tr>
<td>350</td>
<td>4</td>
</tr>
<tr>
<td>350</td>
<td>4</td>
</tr>
</tbody>
</table>
<h6 id="6️⃣-select-고객번호-고객명-매출액-순위">6️⃣ <strong>SELECT 고객번호, 고객명, 매출액, 순위</strong> </h6>
<ul>
<li>최종 출력: 고객번호, 고객명, 매출액, 순위</li>
</ul>
<h6 id="7️⃣-order-by-순위">7️⃣ <strong>ORDER BY 순위</strong> </h6>
<ul>
<li>순위 기준으로 정렬하여 결과를 출력</li>
</ul>
<h6 id="-핵심-요약-2">📌 핵심 요약 </h6>
<table>
<thead>
<tr>
<th>처리 단계</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>INNER JOIN</strong></td>
<td>고객과 매출 테이블 연결</td>
</tr>
<tr>
<td><strong>GROUP BY</strong></td>
<td>고객번호별 집계</td>
</tr>
<tr>
<td><strong>SUM()</strong></td>
<td>매출액 합산</td>
</tr>
<tr>
<td><strong>MAX()</strong></td>
<td>고객명 단일값 추출</td>
</tr>
<tr>
<td><strong>RANK()</strong></td>
<td>매출액 기준 순위 계산 (동점자 동일 순위, 다음 순위 건너뜀)</td>
</tr>
<tr>
<td><strong>ORDER BY</strong></td>
<td>순위 기준 정렬</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>RANK 처리 정확</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>순위 건너뛰지 않음 → 오류</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>순위 건너뛰기 없음 → 오류</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>순서 반대</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
RANK = 동점자 동일 순위, 다음 순위 건너뜀</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 43: 윈도우 함수 예시</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">114</span><span class="token punctuation">]</span>  
아래 데이터 모델에서 활동점수가 높은 고객을 게임상품ID별로 <span class="token number">10</span>등까지 선별하여 사은행사를 진행하려고 한다. 다음 SQL 중 가장 적절한 것은? <span class="token punctuation">(</span>단, 활동점수가 동일한 고객은 동일등수로 한다. 아래 결과 예제 참조<span class="token punctuation">)</span>
</code></pre><div class="mermaid">erDiagram
    게임상품 ||--o{ 고객활동 : "게임상품ID"
    고객 ||--o{ 고객활동 : "고객ID"

    게임상품 {
        NUMBER 게임상품ID PK
        VARCHAR 게임상품명
    }

    고객 {
        NUMBER 고객ID  PK
        VARCHAR 고객명
    }

    고객활동 {
        NUMBER 게임상품ID "FK PK"
        NUMBER 고객ID "FK PK"
        NUMBER 활동점수
    }
</div><p>[테이블: 결과 예제]</p>
<table>
<thead>
<tr>
<th>게임상품ID</th>
<th>고객ID</th>
<th>활동점수</th>
<th>등수(순위)</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>121</td>
<td>150</td>
<td>1</td>
</tr>
<tr>
<td>001</td>
<td>111</td>
<td>150</td>
<td>1</td>
</tr>
<tr>
<td>001</td>
<td>234</td>
<td>110</td>
<td>3</td>
</tr>
<tr>
<td>001</td>
<td>212</td>
<td>100</td>
<td>4</td>
</tr>
<tr>
<td>001</td>
<td>455</td>
<td>100</td>
<td>4</td>
</tr>
<tr>
<td>001</td>
<td>182</td>
<td>90</td>
<td>6</td>
</tr>
<tr>
<td>001</td>
<td>199</td>
<td>80</td>
<td>7</td>
</tr>
<tr>
<td>001</td>
<td>876</td>
<td>70</td>
<td>8</td>
</tr>
<tr>
<td>001</td>
<td>232</td>
<td>70</td>
<td>8</td>
</tr>
<tr>
<td>001</td>
<td>901</td>
<td>40</td>
<td>10</td>
</tr>
</tbody>
</table>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code>① <span class="token keyword keyword-SELECT">SELECT</span> 게임상품ID<span class="token punctuation">,</span> 고객ID<span class="token punctuation">,</span> 활동점수<span class="token punctuation">,</span> 순위
<span class="token keyword keyword-FROM">FROM</span> <span class="token punctuation">(</span><span class="token keyword keyword-SELECT">SELECT</span> DENSE_RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span><span class="token punctuation">(</span><span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> 활동점수 <span class="token keyword keyword-DESC">DESC</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 순위 <span class="token punctuation">,</span> 고객ID<span class="token punctuation">,</span> 게임상품ID<span class="token punctuation">,</span> 활동점수
    <span class="token keyword keyword-FROM">FROM</span> 고객활동<span class="token punctuation">)</span>
<span class="token keyword keyword-WHERE">WHERE</span> 순위 <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span>

② <span class="token keyword keyword-SELECT">SELECT</span> 게임상품ID<span class="token punctuation">,</span> 고객ID<span class="token punctuation">,</span> 활동점수<span class="token punctuation">,</span> 순위
<span class="token keyword keyword-FROM">FROM</span> <span class="token punctuation">(</span><span class="token keyword keyword-SELECT">SELECT</span> DENSE RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span><span class="token punctuation">(</span><span class="token keyword keyword-PARTITION">PARTITION</span> <span class="token keyword keyword-BY">BY</span> 게임상품ID <span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> 활동점수 <span class="token keyword keyword-DESC">DESC</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 순위
        <span class="token punctuation">,</span> 고객ID<span class="token punctuation">,</span> 게임상품ID<span class="token punctuation">,</span> 활동점수
    <span class="token keyword keyword-FROM">FROM</span> 고객활동<span class="token punctuation">)</span>
<span class="token keyword keyword-WHERE">WHERE</span> 순위 <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span>

③ <span class="token keyword keyword-SELECT">SELECT</span> 게임상품ID<span class="token punctuation">,</span> 고객ID<span class="token punctuation">,</span> 활동점수<span class="token punctuation">,</span> 순위
<span class="token keyword keyword-FROM">FROM</span> <span class="token punctuation">(</span><span class="token keyword keyword-SELECT">SELECT</span> RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span><span class="token punctuation">(</span><span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> 활동점수 <span class="token keyword keyword-DESC">DESC</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 순위 
            <span class="token punctuation">,</span> 고객ID<span class="token punctuation">,</span> 게임상품ID<span class="token punctuation">,</span> 활동점수 
      <span class="token keyword keyword-FROM">FROM</span> 고객활동<span class="token punctuation">)</span>
<span class="token keyword keyword-WHERE">WHERE</span> 순위 <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span>

④ <span class="token keyword keyword-SELECT">SELECT</span> 게임상품ID<span class="token punctuation">,</span> 고객ID<span class="token punctuation">,</span> 활동점수<span class="token punctuation">,</span> 순위
<span class="token keyword keyword-FROM">FROM</span> <span class="token punctuation">(</span><span class="token keyword keyword-SELECT">SELECT</span> RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span><span class="token punctuation">(</span><span class="token keyword keyword-PARTITION">PARTITION</span> <span class="token keyword keyword-BY">BY</span> 게임상품ID <span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> 활동점수 <span class="token keyword keyword-DESC">DESC</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 순위 
        <span class="token punctuation">,</span> 고객ID<span class="token punctuation">,</span> 게임상품ID<span class="token punctuation">,</span> 활동점수
    <span class="token keyword keyword-FROM">FROM</span> 고객활동<span class="token punctuation">)</span>
</code></pre><p><strong>✅ 정답:</strong> ④</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
게임상품ID별로 나눠서 RANK를 매겨야 하니까 PARTITION BY가 꼭 들어가야 해요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>RANK 또는 DENSE_RANK 사용</li>
<li>PARTITION BY 게임상품ID → 상품별 순위</li>
<li>WHERE 순위 ≤ 10 → 상위 10등 추출</li>
</ul>
<h6 id="-전체-sql-보기-4">✅ 전체 SQL (보기 ④) </h6>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> 게임상품ID<span class="token punctuation">,</span> 고객ID<span class="token punctuation">,</span> 활동점수<span class="token punctuation">,</span> 순위
<span class="token keyword keyword-FROM">FROM</span> <span class="token punctuation">(</span>
    <span class="token keyword keyword-SELECT">SELECT</span> RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span><span class="token punctuation">(</span><span class="token keyword keyword-PARTITION">PARTITION</span> <span class="token keyword keyword-BY">BY</span> 게임상품ID <span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> 활동점수 <span class="token keyword keyword-DESC">DESC</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 순위<span class="token punctuation">,</span>
           고객ID<span class="token punctuation">,</span> 게임상품ID<span class="token punctuation">,</span> 활동점수
    <span class="token keyword keyword-FROM">FROM</span> 고객활동
<span class="token punctuation">)</span>
<span class="token keyword keyword-WHERE">WHERE</span> 순위 <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><h6 id="-sql-처리-순서-한-줄씩-설명-2">🧠 SQL 처리 순서 한 줄씩 설명 </h6>
<h6 id="1️⃣-from-고객활동">1️⃣ <strong>FROM 고객활동</strong> </h6>
<ul>
<li>고객활동 테이블 전체를 대상으로 시작합니다.</li>
<li>각 행에는 게임상품ID, 고객ID, 활동점수가 포함되어 있습니다.</li>
</ul>
<h6 id="2️⃣-rank-overpartition-by-게임상품id-order-by-활동점수-desc-as-순위">2️⃣ <strong>RANK() OVER(PARTITION BY 게임상품ID ORDER BY 활동점수 DESC) AS 순위</strong> </h6>
<ul>
<li>윈도우 함수 **RANK()**를 사용해 <strong>게임상품ID별로 그룹을 나눈 뒤</strong>, 활동점수 기준으로 내림차순 정렬하여 순위를 매깁니다.</li>
<li><strong>PARTITION BY 게임상품ID</strong> → 게임상품별로 순위가 따로 계산됨</li>
<li>**RANK()**는 동점자에게 같은 순위를 부여하고, 다음 순위를 건너뜁니다</li>
</ul>
<h6 id="예시">예시: </h6>
<ul>
<li>상품ID 001:
<ul>
<li>활동점수 150 → 순위 1</li>
<li>활동점수 150 → 순위 1</li>
<li>활동점수 110 → 순위 3</li>
<li>활동점수 100 → 순위 4</li>
<li>활동점수 100 → 순위 4</li>
<li>활동점수 90 → 순위 6</li>
<li>…</li>
</ul>
</li>
</ul>
<h6 id="3️⃣-select-고객id-게임상품id-활동점수-순위">3️⃣ <strong>SELECT 고객ID, 게임상품ID, 활동점수, 순위</strong> </h6>
<ul>
<li>서브쿼리에서 각 고객의 순위가 계산된 결과를 출력합니다.</li>
</ul>
<h6 id="4️⃣-where-순위--10">4️⃣ <strong>WHERE 순위 &lt;= 10</strong> </h6>
<ul>
<li>순위가 10등 이하인 고객만 필터링합니다.</li>
<li>즉, 각 게임상품ID별로 <strong>상위 10등까지의 고객만 추출</strong></li>
</ul>
<h6 id="5️⃣-select-게임상품id-고객id-활동점수-순위">5️⃣ <strong>SELECT 게임상품ID, 고객ID, 활동점수, 순위</strong> </h6>
<ul>
<li>최종 출력: 게임상품ID별로 활동점수가 높은 고객 10명(동점자 포함)</li>
</ul>
<h6 id="-핵심-요약-3">📌 핵심 요약 </h6>
<table>
<thead>
<tr>
<th>처리 단계</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FROM 고객활동</strong></td>
<td>전체 활동 데이터 조회</td>
</tr>
<tr>
<td><strong>RANK() OVER(PARTITION BY 게임상품ID ORDER BY 활동점수 DESC)</strong></td>
<td>상품별 순위 계산</td>
</tr>
<tr>
<td><strong>WHERE 순위 &lt;= 10</strong></td>
<td>상위 10등까지 필터링</td>
</tr>
<tr>
<td><strong>SELECT</strong></td>
<td>결과 출력</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>전체 기준 순위 → 오류</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>DENSE_RANK 오타 있음</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>전체 기준 RANK → 오류</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>PARTITION BY + RANK → 정확</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
PARTITION BY = 그룹별 순위</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 43: 윈도우 함수 예시</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">115</span><span class="token punctuation">]</span>   
다음 중 추천내역 테이블에서 아래와 같은 SQL을 수행하였을 때의 결과로 가장 적절한 것은?
</code></pre><table>
<thead>
<tr>
<th>추천경로</th>
<th>추천인</th>
<th>피추천인</th>
<th>추천점수</th>
</tr>
</thead>
<tbody>
<tr>
<td>SNS</td>
<td>나한일</td>
<td>강감찬</td>
<td>75</td>
</tr>
<tr>
<td>SNS</td>
<td>이순신</td>
<td>강감찬</td>
<td>80</td>
</tr>
<tr>
<td>이벤트응모</td>
<td>홍길동</td>
<td>강감찬</td>
<td>88</td>
</tr>
<tr>
<td>이벤트응모</td>
<td>저절로</td>
<td>이순신</td>
<td>78</td>
</tr>
<tr>
<td>홈페이지</td>
<td>저절로</td>
<td>이대로</td>
<td>93</td>
</tr>
<tr>
<td>홈페이지</td>
<td>홍두깨</td>
<td>심청이</td>
<td>98</td>
</tr>
</tbody>
</table>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token punctuation">[</span><span class="token keyword keyword-SQL">SQL</span><span class="token punctuation">]</span>
<span class="token keyword keyword-SELECT">SELECT</span> 추천경로<span class="token punctuation">,</span> 추천인<span class="token punctuation">,</span> 피추천인<span class="token punctuation">,</span> 추천점수
<span class="token keyword keyword-FROM">FROM</span> <span class="token punctuation">(</span><span class="token keyword keyword-SELECT">SELECT</span> 추천경로<span class="token punctuation">,</span> 추천인<span class="token punctuation">,</span> 피추천인<span class="token punctuation">,</span> 추천점수 <span class="token punctuation">,</span> 
        ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span><span class="token punctuation">(</span><span class="token keyword keyword-PARTITION">PARTITION</span> <span class="token keyword keyword-BY">BY</span> 추천경로 <span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> 추천점수 <span class="token keyword keyword-DESC">DESC</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> RNUM
      <span class="token keyword keyword-FROM">FROM</span> 추천내역<span class="token punctuation">)</span>
<span class="token keyword keyword-WHERE">WHERE</span> RNUM <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><p>①</p>
<table>
<thead>
<tr>
<th>추천경로</th>
<th>추천인</th>
<th>피추천인</th>
<th>추천점수</th>
</tr>
</thead>
<tbody>
<tr>
<td>SNS</td>
<td>나한일</td>
<td>강감찬</td>
<td>75</td>
</tr>
<tr>
<td>SNS</td>
<td>이순신</td>
<td>강감찬</td>
<td>80</td>
</tr>
<tr>
<td>이벤트응모</td>
<td>홍길동</td>
<td>강감찬</td>
<td>88</td>
</tr>
<tr>
<td>이벤트응모</td>
<td>저절로</td>
<td>이순신</td>
<td>78</td>
</tr>
<tr>
<td>홈페이지</td>
<td>저절로</td>
<td>이대로</td>
<td>93</td>
</tr>
<tr>
<td>홈페이지</td>
<td>홍두깨</td>
<td>심청이</td>
<td>98</td>
</tr>
</tbody>
</table>
<p>②</p>
<table>
<thead>
<tr>
<th>추천경로</th>
<th>추천인</th>
<th>피추천인</th>
<th>추천점수</th>
</tr>
</thead>
<tbody>
<tr>
<td>홈페이지</td>
<td>홍두깨</td>
<td>심청이</td>
<td>98</td>
</tr>
</tbody>
</table>
<p>③</p>
<table>
<thead>
<tr>
<th>추천경로</th>
<th>추천인</th>
<th>피추천인</th>
<th>추천점수</th>
</tr>
</thead>
<tbody>
<tr>
<td>SNS</td>
<td>이순신</td>
<td>강감찬</td>
<td>80</td>
</tr>
<tr>
<td>이벤트응모</td>
<td>홍길동</td>
<td>강감찬</td>
<td>88</td>
</tr>
<tr>
<td>홈페이지</td>
<td>홍두깨</td>
<td>심청이</td>
<td>98</td>
</tr>
</tbody>
</table>
<p>④</p>
<table>
<thead>
<tr>
<th>추천경로</th>
<th>추천인</th>
<th>피추천인</th>
<th>추천점수</th>
</tr>
</thead>
<tbody>
<tr>
<td>SNS</td>
<td>나한일</td>
<td>강감찬</td>
<td>75</td>
</tr>
<tr>
<td>이벤트응모</td>
<td>저절로</td>
<td>이순신</td>
<td>78</td>
</tr>
<tr>
<td>홈페이지</td>
<td>저절로</td>
<td>이대로</td>
<td>93</td>
</tr>
</tbody>
</table>
<p><strong>✅ 정답:</strong> ③</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
ROW_NUMBER는 각 추천경로별로 점수 높은 순서대로 번호를 매겨요. RNUM = 1이면 최고점 1건만 남아요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>PARTITION BY 추천경로 → 추천경로별 그룹</li>
<li>ORDER BY 추천점수 DESC → 점수 높은 순</li>
<li>ROW_NUMBER = 1 → 각 그룹의 최고점 1건</li>
</ul>
<h6 id="-전체-sql-2">✅ 전체 SQL </h6>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> 추천경로<span class="token punctuation">,</span> 추천인<span class="token punctuation">,</span> 피추천인<span class="token punctuation">,</span> 추천점수
<span class="token keyword keyword-FROM">FROM</span> <span class="token punctuation">(</span>
  <span class="token keyword keyword-SELECT">SELECT</span> 추천경로<span class="token punctuation">,</span> 추천인<span class="token punctuation">,</span> 피추천인<span class="token punctuation">,</span> 추천점수<span class="token punctuation">,</span>
         ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span><span class="token punctuation">(</span><span class="token keyword keyword-PARTITION">PARTITION</span> <span class="token keyword keyword-BY">BY</span> 추천경로 <span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> 추천점수 <span class="token keyword keyword-DESC">DESC</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> RNUM
  <span class="token keyword keyword-FROM">FROM</span> 추천내역
<span class="token punctuation">)</span>
<span class="token keyword keyword-WHERE">WHERE</span> RNUM <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><h6 id="-sql-처리-순서-한-줄씩-설명-3">🧠 SQL 처리 순서 한 줄씩 설명 </h6>
<h6 id="1️⃣-from-추천내역">1️⃣ <strong>FROM 추천내역</strong> </h6>
<ul>
<li>추천내역 테이블 전체를 대상으로 시작합니다.</li>
<li>각 행에는 추천경로, 추천인, 피추천인, 추천점수가 포함되어 있습니다.</li>
</ul>
<h6 id="2️⃣-row_number-overpartition-by-추천경로-order-by-추천점수-desc-as-rnum">2️⃣ <strong>ROW_NUMBER() OVER(PARTITION BY 추천경로 ORDER BY 추천점수 DESC) AS RNUM</strong> </h6>
<ul>
<li>윈도우 함수 **ROW_NUMBER()**를 사용해 <strong>추천경로별로 그룹을 나눈 뒤</strong>, 추천점수 기준으로 내림차순 정렬하여 순위를 매깁니다.</li>
<li><strong>PARTITION BY 추천경로</strong> → 추천경로별로 순위가 따로 계산됨</li>
<li><strong>ORDER BY 추천점수 DESC</strong> → 점수가 높은 추천인이 순위 1</li>
</ul>
<h6 id="예시-1">예시: </h6>
<ul>
<li>SNS 그룹:
<ul>
<li>이순신 → 80 → RNUM = 1</li>
<li>나한일 → 75 → RNUM = 2</li>
</ul>
</li>
<li>이벤트응모 그룹:
<ul>
<li>홍길동 → 88 → RNUM = 1</li>
<li>저절로 → 78 → RNUM = 2</li>
</ul>
</li>
<li>홈페이지 그룹:
<ul>
<li>홍두깨 → 98 → RNUM = 1</li>
<li>저절로 → 93 → RNUM = 2</li>
</ul>
</li>
</ul>
<h6 id="3️⃣-select-추천경로-추천인-피추천인-추천점수-rnum">3️⃣ <strong>SELECT 추천경로, 추천인, 피추천인, 추천점수, RNUM</strong> </h6>
<ul>
<li>서브쿼리에서 각 추천경로별로 순위가 계산된 결과를 출력합니다.</li>
</ul>
<h6 id="4️⃣-where-rnum--1">4️⃣ <strong>WHERE RNUM = 1</strong> </h6>
<ul>
<li>순위가 1인 추천인만 필터링합니다.</li>
<li>즉, 각 추천경로별로 <strong>추천점수가 가장 높은 추천인 1명만 추출</strong></li>
</ul>
<h6 id="5️⃣-select-추천경로-추천인-피추천인-추천점수">5️⃣ <strong>SELECT 추천경로, 추천인, 피추천인, 추천점수</strong> </h6>
<ul>
<li>최종 출력: 추천경로별로 추천점수가 가장 높은 추천인 1명씩</li>
</ul>
<h6 id="-최종-출력-결과">✅ 최종 출력 결과 </h6>
<table>
<thead>
<tr>
<th>추천경로</th>
<th>추천인</th>
<th>피추천인</th>
<th>추천점수</th>
</tr>
</thead>
<tbody>
<tr>
<td>SNS</td>
<td>이순신</td>
<td>강감찬</td>
<td>80</td>
</tr>
<tr>
<td>이벤트응모</td>
<td>홍길동</td>
<td>강감찬</td>
<td>88</td>
</tr>
<tr>
<td>홈페이지</td>
<td>홍두깨</td>
<td>심청이</td>
<td>98</td>
</tr>
</tbody>
</table>
<p>➡ 보기 ③과 정확히 일치합니다.</p>
<h6 id="-핵심-요약-4">📌 핵심 요약 </h6>
<p>| 처리 단계 | 설명 |<br>
|--||<br>
| <strong>PARTITION BY 추천경로</strong> | 추천경로별 그룹화 |<br>
| <strong>ORDER BY 추천점수 DESC</strong> | 점수 높은 순 정렬 |<br>
| <strong>ROW_NUMBER()</strong> | 순위 매기기 (동점자 구분) |<br>
| <strong>WHERE RNUM = 1</strong> | 각 추천경로별 최고점 1건만 추출 |<br>
| <strong>SELECT</strong> | 결과 출력 |</p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>RNUM 조건 없음 → 전체 출력</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>홈페이지만 출력</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>각 추천경로별 최고점 1건</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>점수 낮은 행 포함</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
ROW_NUMBER = 순위 매기기 (1등만 남기려면 WHERE RNUM = 1)</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 43: 윈도우 함수 예시</li>
<li>🃏 카드 24: GROUP BY</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">116</span><span class="token punctuation">]</span> 
다음 중 아래의 SQL에 대한 설명으로 가장 적절한 것은?
</code></pre><pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token punctuation">[</span><span class="token keyword keyword-SQL">SQL</span><span class="token punctuation">]</span>
<span class="token keyword keyword-SELECT">SELECT</span> 상품분류코드
        <span class="token punctuation">,</span><span class="token function">AVG</span><span class="token punctuation">(</span>상품가격<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 상품가격
        <span class="token punctuation">,</span><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span><span class="token punctuation">(</span><span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> <span class="token function">AVG</span><span class="token punctuation">(</span>상품가격<span class="token punctuation">)</span>
                        RANGE <span class="token operator">BETWEEN</span> <span class="token number">10000</span> <span class="token keyword keyword-PRECEDING">PRECEDING</span>
                    <span class="token operator">AND</span> <span class="token number">10000</span> <span class="token keyword keyword-FOLLOWING">FOLLOWING</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 유사개수
<span class="token keyword keyword-FROM">FROM</span> 상품
<span class="token keyword keyword-GROUP">GROUP</span> <span class="token keyword keyword-BY">BY</span> 상품분류코드<span class="token punctuation">;</span>
</code></pre><pre data-role="codeBlock" data-info="" class="language-text"><code>① WINDOW FUNCTION을 GROUP BY 절과 함께 사용하였으므로 위의 SQL은 오류가 발생한다.
② WINDOW FUNCTION의 ORDER BY절에 AVG 집계 함수를 사용하였으므로 위의 SQL은 오류가 발생한다.
③ 유사개수 컬럼은 상품분류코드별 평균상품가격을 서로 비교하여 -10000 ~ +10000 사이에 존재하는 상품분류코드의 개수를 구한 것이다.
④ 유사개수 컬럼은 상품전체의 평균상품가격을 서로 비교하여 -10000 ~ +10000 사이에 존재하는 상품의 개수를 구한 것이다.
</code></pre><p><strong>✅ 정답:</strong> ③</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
AVG(상품가격)가 비슷한 상품분류코드끼리 몇 개인지 세는 거예요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>GROUP BY로 상품분류코드별 평균 가격 계산</li>
<li>RANGE BETWEEN ±10000 → 평균가격 기준 ±1만 이내</li>
<li>COUNT(*) OVER → 해당 범위 내 개수</li>
</ul>
<h6 id="-전체-sql-3">✅ 전체 SQL </h6>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> 상품분류코드<span class="token punctuation">,</span>
       <span class="token function">AVG</span><span class="token punctuation">(</span>상품가격<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 상품가격<span class="token punctuation">,</span>
       <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span><span class="token punctuation">(</span>
         <span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> <span class="token function">AVG</span><span class="token punctuation">(</span>상품가격<span class="token punctuation">)</span>
         RANGE <span class="token operator">BETWEEN</span> <span class="token number">10000</span> <span class="token keyword keyword-PRECEDING">PRECEDING</span> <span class="token operator">AND</span> <span class="token number">10000</span> <span class="token keyword keyword-FOLLOWING">FOLLOWING</span>
       <span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 유사개수
<span class="token keyword keyword-FROM">FROM</span> 상품
<span class="token keyword keyword-GROUP">GROUP</span> <span class="token keyword keyword-BY">BY</span> 상품분류코드<span class="token punctuation">;</span>
</code></pre><h6 id="-sql-처리-순서-한-줄씩-설명-4">🧠 SQL 처리 순서 한 줄씩 설명 </h6>
<h6 id="1️⃣-from-상품">1️⃣ <strong>FROM 상품</strong> </h6>
<ul>
<li>상품 테이블 전체를 대상으로 시작합니다.</li>
<li>각 행에는 상품분류코드, 상품가격 등이 포함되어 있습니다.</li>
</ul>
<h6 id="2️⃣-group-by-상품분류코드">2️⃣ <strong>GROUP BY 상품분류코드</strong> </h6>
<ul>
<li>상품분류코드별로 그룹화하여 집계 준비</li>
<li>각 그룹은 하나의 상품분류코드에 속한 상품들을 포함합니다</li>
</ul>
<h6 id="3️⃣-avg상품가격-as-상품가격">3️⃣ <strong>AVG(상품가격) AS 상품가격</strong> </h6>
<ul>
<li>각 상품분류코드 그룹에 대해 평균 상품가격을 계산합니다</li>
</ul>
<h6 id="4️⃣-count-over-as-유사개수">4️⃣ <strong>COUNT(*) OVER(...) AS 유사개수</strong> </h6>
<ul>
<li>윈도우 함수 **COUNT(*) OVER(...)**를 사용해 <strong>각 평균가격 기준으로 유사한 가격대의 그룹 수를 계산</strong>합니다</li>
</ul>
<p>########### 세부 구성:</p>
<ul>
<li><strong>ORDER BY AVG(상품가격)</strong> → 평균가격 기준으로 정렬</li>
<li><strong>RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING</strong> → 현재 평균가격에서 ±10,000 범위 내에 있는 그룹들을 포함</li>
<li><strong>COUNT(*)</strong> → 해당 범위 내 그룹의 개수를 셈</li>
</ul>
<h6 id="5️⃣-select-상품분류코드-avg상품가격-유사개수">5️⃣ <strong>SELECT 상품분류코드, AVG(상품가격), 유사개수</strong> </h6>
<ul>
<li>최종 출력: 각 상품분류코드별 평균가격과 그 주변 ±10,000 가격대에 위치한 분류코드의 개수</li>
</ul>
<h6 id="-최종-출력-예시-구조">✅ 최종 출력 예시 (구조) </h6>
<table>
<thead>
<tr>
<th>상품분류코드</th>
<th>상품가격</th>
<th>유사개수</th>
</tr>
</thead>
<tbody>
<tr>
<td>A01</td>
<td>12000</td>
<td>3</td>
</tr>
<tr>
<td>A02</td>
<td>18000</td>
<td>4</td>
</tr>
<tr>
<td>A03</td>
<td>25000</td>
<td>2</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>➡ 유사개수는 해당 평균가격 기준 ±10,000 범위 내에 있는 분류코드의 개수입니다</p>
<h6 id="-핵심-요약-5">📌 핵심 요약 </h6>
<p>| 처리 단계 | 설명 |<br>
|--||<br>
| <strong>GROUP BY</strong> | 상품분류코드별로 그룹화 |<br>
| <strong>AVG()</strong> | 각 그룹의 평균가격 계산 |<br>
| <strong>WINDOW FUNCTION</strong> | 평균가격 기준 ±10,000 범위 내 그룹 개수 계산 |<br>
| <strong>SELECT</strong> | 결과 출력: 분류코드, 평균가격, 유사개수 |</p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>GROUP BY와 윈도우 함수는 함께 사용 가능</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>AVG 사용 가능</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>정확한 설명</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>전체 평균 기준 아님</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
RANGE = 값의 범위<br>
ROWS = 행의 개수</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 43: 윈도우 함수 예시</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">117</span><span class="token punctuation">]</span> 
다음 중 <span class="token punctuation">[</span>사원<span class="token punctuation">]</span> 테이블에 대하여 아래와 같은 SQL을 수행하였을 때 예상되는 결과로 가장 적절한 것은?
</code></pre><p>[테이블: 사원]</p>
<table>
<thead>
<tr>
<th>사원ID</th>
<th>부서ID</th>
<th>사원이름</th>
<th>연봉</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>100</td>
<td>홍길동</td>
<td>2500</td>
</tr>
<tr>
<td>002</td>
<td>100</td>
<td>강감찬</td>
<td>3000</td>
</tr>
<tr>
<td>003</td>
<td>200</td>
<td>김유신</td>
<td>4500</td>
</tr>
<tr>
<td>004</td>
<td>200</td>
<td>김선달</td>
<td>3000</td>
</tr>
<tr>
<td>005</td>
<td>200</td>
<td>유학생</td>
<td>2500</td>
</tr>
<tr>
<td>006</td>
<td>300</td>
<td>변사또</td>
<td>4500</td>
</tr>
<tr>
<td>007</td>
<td>300</td>
<td>박문수</td>
<td>3000</td>
</tr>
</tbody>
</table>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token punctuation">[</span><span class="token keyword keyword-SQL">SQL</span><span class="token punctuation">]</span>
<span class="token keyword keyword-SELECT">SELECT</span> Y<span class="token punctuation">.</span>사원ID<span class="token punctuation">,</span> Y<span class="token punctuation">.</span>부서ID<span class="token punctuation">,</span> Y<span class="token punctuation">.</span>사원명<span class="token punctuation">,</span> Y<span class="token punctuation">.</span>연봉
<span class="token keyword keyword-FROM">FROM</span> <span class="token punctuation">(</span><span class="token keyword keyword-SELECT">SELECT</span> 사원ID<span class="token punctuation">,</span> <span class="token function">MAX</span><span class="token punctuation">(</span>연봉<span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span><span class="token punctuation">(</span><span class="token keyword keyword-PARTITION">PARTITION</span> <span class="token keyword keyword-BY">BY</span> 부서ID<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 최고연봉 
      <span class="token keyword keyword-FROM">FROM</span> 사원<span class="token punctuation">)</span> X<span class="token punctuation">,</span> 사원 Y
<span class="token keyword keyword-WHERE">WHERE</span> X<span class="token punctuation">.</span>사원ID <span class="token operator">=</span> Y<span class="token punctuation">.</span>사원ID
<span class="token operator">AND</span>   X<span class="token punctuation">.</span>최고연봉 <span class="token operator">=</span> Y<span class="token punctuation">.</span>연봉
</code></pre><p>①</p>
<table>
<thead>
<tr>
<th>사원ID</th>
<th>부서ID</th>
<th>사원이름</th>
<th>연봉</th>
</tr>
</thead>
<tbody>
<tr>
<td>002</td>
<td>100</td>
<td>강감찬</td>
<td>3000</td>
</tr>
<tr>
<td>003</td>
<td>200</td>
<td>김유신</td>
<td>4500</td>
</tr>
<tr>
<td>006</td>
<td>300</td>
<td>변사또</td>
<td>4500</td>
</tr>
</tbody>
</table>
<p>②</p>
<table>
<thead>
<tr>
<th>사원ID</th>
<th>부서ID</th>
<th>사원이름</th>
<th>연봉</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>100</td>
<td>홍길동</td>
<td>2500</td>
</tr>
<tr>
<td>005</td>
<td>200</td>
<td>유학생</td>
<td>2500</td>
</tr>
<tr>
<td>007</td>
<td>300</td>
<td>박문수</td>
<td>3000</td>
</tr>
</tbody>
</table>
<p>③</p>
<table>
<thead>
<tr>
<th>사원ID</th>
<th>부서ID</th>
<th>사원이름</th>
<th>연봉</th>
</tr>
</thead>
<tbody>
<tr>
<td>003</td>
<td>200</td>
<td>김유신</td>
<td>4500</td>
</tr>
<tr>
<td>006</td>
<td>300</td>
<td>변사또</td>
<td>4500</td>
</tr>
</tbody>
</table>
<p>④</p>
<table>
<thead>
<tr>
<th>사원ID</th>
<th>부서ID</th>
<th>사원이름</th>
<th>연봉</th>
</tr>
</thead>
<tbody>
<tr>
<td>004</td>
<td>200</td>
<td>김유신</td>
<td>4500</td>
</tr>
</tbody>
</table>
<p><strong>✅ 정답:</strong> ①</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
부서별로 연봉이 가장 높은 사원을 찾는 거예요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>MAX(연봉) OVER(PARTITION BY 부서ID) → 부서별 최고 연봉</li>
<li>WHERE절에서 연봉이 최고연봉과 같은 사원만 추출</li>
</ul>
<h6 id="-전체-sql-4">✅ 전체 SQL </h6>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> Y<span class="token punctuation">.</span>사원ID<span class="token punctuation">,</span> Y<span class="token punctuation">.</span>부서ID<span class="token punctuation">,</span> Y<span class="token punctuation">.</span>사원명<span class="token punctuation">,</span> Y<span class="token punctuation">.</span>연봉
<span class="token keyword keyword-FROM">FROM</span> <span class="token punctuation">(</span>
    <span class="token keyword keyword-SELECT">SELECT</span> 사원ID<span class="token punctuation">,</span>
           <span class="token function">MAX</span><span class="token punctuation">(</span>연봉<span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span><span class="token punctuation">(</span><span class="token keyword keyword-PARTITION">PARTITION</span> <span class="token keyword keyword-BY">BY</span> 부서ID<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> 최고연봉
    <span class="token keyword keyword-FROM">FROM</span> 사원
<span class="token punctuation">)</span> X<span class="token punctuation">,</span> 사원 Y
<span class="token keyword keyword-WHERE">WHERE</span> X<span class="token punctuation">.</span>사원ID <span class="token operator">=</span> Y<span class="token punctuation">.</span>사원ID
  <span class="token operator">AND</span> X<span class="token punctuation">.</span>최고연봉 <span class="token operator">=</span> Y<span class="token punctuation">.</span>연봉<span class="token punctuation">;</span>
</code></pre><h6 id="-sql-처리-순서-한-줄씩-설명-5">🧠 SQL 처리 순서 한 줄씩 설명 </h6>
<h6 id="1️⃣-from-사원">1️⃣ <strong>FROM 사원</strong> </h6>
<ul>
<li>사원 테이블 전체를 대상으로 시작합니다.</li>
<li>각 행에는 사원ID, 부서ID, 사원이름, 연봉이 포함되어 있습니다.</li>
</ul>
<h6 id="2️⃣-max연봉-overpartition-by-부서id-as-최고연봉">2️⃣ <strong>MAX(연봉) OVER(PARTITION BY 부서ID) AS 최고연봉</strong> </h6>
<ul>
<li>윈도우 함수 **MAX()**를 사용해 <strong>부서ID별로 그룹을 나눈 뒤</strong>, 각 사원의 행에 해당 부서의 최고 연봉을 붙입니다.</li>
<li>예:
<ul>
<li>부서 100 → 최고연봉 3000</li>
<li>부서 200 → 최고연봉 4500</li>
<li>부서 300 → 최고연봉 4500</li>
</ul>
</li>
</ul>
<h6 id="3️⃣-select-사원id-최고연봉-from--as-x">3️⃣ <strong>SELECT 사원ID, 최고연봉 FROM (...) AS X</strong> </h6>
<ul>
<li>각 사원ID에 대해 해당 부서의 최고연봉이 계산된 결과를 생성합니다.</li>
</ul>
<h6 id="4️⃣-join-사원-y-on-x사원id--y사원id">4️⃣ <strong>JOIN 사원 Y ON X.사원ID = Y.사원ID</strong> </h6>
<ul>
<li>X와 Y를 사원ID 기준으로 조인하여 사원정보를 다시 가져옵니다.</li>
</ul>
<h6 id="5️⃣-where-x최고연봉--y연봉">5️⃣ <strong>WHERE X.최고연봉 = Y.연봉</strong> </h6>
<ul>
<li>조인된 결과에서 <strong>사원의 연봉이 해당 부서의 최고연봉과 같은 경우만 필터링</strong>합니다.</li>
</ul>
<h6 id="6️⃣-select-y사원id-y부서id-y사원명-y연봉">6️⃣ <strong>SELECT Y.사원ID, Y.부서ID, Y.사원명, Y.연봉</strong> </h6>
<ul>
<li>최종 출력: 부서별 최고 연봉을 가진 사원들</li>
</ul>
<h6 id="-최종-출력-결과-1">✅ 최종 출력 결과 </h6>
<table>
<thead>
<tr>
<th>사원ID</th>
<th>부서ID</th>
<th>사원이름</th>
<th>연봉</th>
</tr>
</thead>
<tbody>
<tr>
<td>002</td>
<td>100</td>
<td>강감찬</td>
<td>3000</td>
</tr>
<tr>
<td>003</td>
<td>200</td>
<td>김유신</td>
<td>4500</td>
</tr>
<tr>
<td>006</td>
<td>300</td>
<td>변사또</td>
<td>4500</td>
</tr>
</tbody>
</table>
<p>➡ 보기 ①과 정확히 일치합니다.</p>
<h6 id="-핵심-요약-6">📌 핵심 요약 </h6>
<table>
<thead>
<tr>
<th>처리 단계</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>MAX() OVER(PARTITION BY 부서ID)</strong></td>
<td>부서별 최고 연봉 계산</td>
</tr>
<tr>
<td><strong>JOIN</strong></td>
<td>사원 정보와 최고연봉 연결</td>
</tr>
<tr>
<td><strong>WHERE</strong></td>
<td>연봉이 최고연봉과 같은 사원만 추출</td>
</tr>
<tr>
<td><strong>SELECT</strong></td>
<td>결과 출력: 사원ID, 부서ID, 사원이름, 연봉</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>정확한 결과</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>최저 연봉 사원</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>일부 부서 누락</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>사원명 오류</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
MAX OVER(PARTITION BY) = 그룹별 최대값</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 43: 윈도우 함수 예시</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">118</span><span class="token punctuation">]</span>
다음 중 아래 SQL의 실행 결과로 가장 적절한 것은?
</code></pre><pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-CREATE">CREATE</span> <span class="token keyword keyword-TABLE">TABLE</span> TBL
    <span class="token punctuation">(</span>ID VARCHAR2<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword keyword-START">START</span> VAL NUMBER<span class="token punctuation">,</span>
    <span class="token keyword keyword-END">END</span> VAL NUMBER<span class="token punctuation">)</span>

</code></pre><p>[테이블: TBL]</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>START VAL</th>
<th>END VAL</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>10</td>
<td>14</td>
</tr>
<tr>
<td>A</td>
<td>14</td>
<td>15</td>
</tr>
<tr>
<td>A</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>A</td>
<td>15</td>
<td>18</td>
</tr>
<tr>
<td>A</td>
<td>20</td>
<td>25</td>
</tr>
<tr>
<td>A</td>
<td>25</td>
<td></td>
</tr>
</tbody>
</table>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> ID<span class="token punctuation">,</span> <span class="token keyword keyword-START">START</span> VAL<span class="token punctuation">,</span> <span class="token keyword keyword-END">END</span> VAL
<span class="token keyword keyword-FROM">FROM</span> <span class="token punctuation">(</span>
    <span class="token keyword keyword-SELECT">SELECT</span> ID<span class="token punctuation">,</span> <span class="token keyword keyword-START">START</span> VAL<span class="token punctuation">,</span> NVL<span class="token punctuation">(</span><span class="token keyword keyword-END">END</span> VAL<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span> <span class="token keyword keyword-END">END</span> VAL<span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token keyword keyword-CASE">CASE</span> <span class="token keyword keyword-WHEN">WHEN</span> START_VAL <span class="token operator">=</span> LAG<span class="token punctuation">(</span><span class="token keyword keyword-END">END</span> VAL<span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span> <span class="token punctuation">(</span><span class="token keyword keyword-PARTITION">PARTITION</span> <span class="token keyword keyword-BY">BY</span> ID
                <span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> <span class="token keyword keyword-START">START</span> VAL<span class="token punctuation">,</span> NVL<span class="token punctuation">(</span><span class="token keyword keyword-END">END</span> VAL<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-THEN">THEN</span> <span class="token number">1</span>
            <span class="token keyword keyword-ELSE">ELSE</span> O
            <span class="token keyword keyword-END">END</span><span class="token punctuation">)</span> FLAG1
     <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-CASE">CASE</span> <span class="token keyword keyword-WHEN">WHEN</span> <span class="token keyword keyword-END">END</span> VAL LEAD<span class="token punctuation">(</span><span class="token keyword keyword-START">START</span> VAL<span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span> <span class="token punctuation">(</span><span class="token keyword keyword-PARTITION">PARTITION</span> <span class="token keyword keyword-BY">BY</span> ID
                <span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> <span class="token keyword keyword-START">START</span> VAL<span class="token punctuation">,</span> NVL<span class="token punctuation">(</span><span class="token keyword keyword-END">END</span> VAL<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-THEN">THEN</span> <span class="token number">1</span>
            <span class="token keyword keyword-ELSE">ELSE</span> <span class="token number">0</span>
            <span class="token keyword keyword-END">END</span><span class="token punctuation">)</span> FLAG2
    <span class="token keyword keyword-FROM">FROM</span> TBL<span class="token punctuation">)</span>
<span class="token keyword keyword-WHERE">WHERE</span> FLAG1 <span class="token operator">=</span> <span class="token number">0</span>  <span class="token operator">OR</span> FLAG2<span class="token operator">=</span><span class="token number">0</span>
</code></pre><p>①</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>START VAL</th>
<th>END VAL</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>10</td>
<td>14</td>
</tr>
<tr>
<td>A</td>
<td>15</td>
<td>18</td>
</tr>
<tr>
<td>A</td>
<td>20</td>
<td>25</td>
</tr>
<tr>
<td>A</td>
<td>25</td>
<td>99</td>
</tr>
</tbody>
</table>
<p>②</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>START VAL</th>
<th>END VAL</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>15</td>
<td>15</td>
</tr>
</tbody>
</table>
<p>③</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>START VAL</th>
<th>END VAL</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>10</td>
<td>14</td>
</tr>
<tr>
<td>A</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>A</td>
<td>20</td>
<td>99</td>
</tr>
</tbody>
</table>
<p>④</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>START VAL</th>
<th>END VAL</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>10</td>
<td>18</td>
</tr>
<tr>
<td>A</td>
<td>20</td>
<td>99</td>
</tr>
</tbody>
</table>
<p><strong>✅ 정답:</strong> ①</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
LAG와 LEAD로 앞뒤 값 비교해서 연속되지 않는 구간만 남겨요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>LAG(END_VAL) = 현재 START_VAL이면 FLAG1 = 1</li>
<li>LEAD(START_VAL) = 현재 END_VAL이면 FLAG2 = 1</li>
<li>FLAG1 = 0 또는 FLAG2 = 0 → 연속되지 않는 구간</li>
</ul>
<h6 id="-전체-sql-5">✅ 전체 SQL </h6>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> ID<span class="token punctuation">,</span> START_VAL<span class="token punctuation">,</span> END_VAL
<span class="token keyword keyword-FROM">FROM</span> <span class="token punctuation">(</span>
  <span class="token keyword keyword-SELECT">SELECT</span> ID<span class="token punctuation">,</span>
         START_VAL<span class="token punctuation">,</span>
         NVL<span class="token punctuation">(</span>END_VAL<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> END_VAL<span class="token punctuation">,</span>
         <span class="token keyword keyword-CASE">CASE</span> <span class="token keyword keyword-WHEN">WHEN</span> START_VAL <span class="token operator">=</span> LAG<span class="token punctuation">(</span>NVL<span class="token punctuation">(</span>END_VAL<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span> <span class="token punctuation">(</span>
                      <span class="token keyword keyword-PARTITION">PARTITION</span> <span class="token keyword keyword-BY">BY</span> ID
                      <span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> START_VAL<span class="token punctuation">,</span> NVL<span class="token punctuation">(</span>END_VAL<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span>
                  <span class="token punctuation">)</span> <span class="token keyword keyword-THEN">THEN</span> <span class="token number">1</span> <span class="token keyword keyword-ELSE">ELSE</span> <span class="token number">0</span> <span class="token keyword keyword-END">END</span> <span class="token keyword keyword-AS">AS</span> FLAG1<span class="token punctuation">,</span>
         <span class="token keyword keyword-CASE">CASE</span> <span class="token keyword keyword-WHEN">WHEN</span> NVL<span class="token punctuation">(</span>END_VAL<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span> <span class="token operator">=</span> LEAD<span class="token punctuation">(</span>START_VAL<span class="token punctuation">)</span> <span class="token keyword keyword-OVER">OVER</span> <span class="token punctuation">(</span>
                      <span class="token keyword keyword-PARTITION">PARTITION</span> <span class="token keyword keyword-BY">BY</span> ID
                      <span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> START_VAL<span class="token punctuation">,</span> NVL<span class="token punctuation">(</span>END_VAL<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span>
                  <span class="token punctuation">)</span> <span class="token keyword keyword-THEN">THEN</span> <span class="token number">1</span> <span class="token keyword keyword-ELSE">ELSE</span> <span class="token number">0</span> <span class="token keyword keyword-END">END</span> <span class="token keyword keyword-AS">AS</span> FLAG2
  <span class="token keyword keyword-FROM">FROM</span> TBL
<span class="token punctuation">)</span>
<span class="token keyword keyword-WHERE">WHERE</span> FLAG1 <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">OR</span> FLAG2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><h6 id="-sql-처리-순서-한-줄씩-설명-6">🧠 SQL 처리 순서 한 줄씩 설명 </h6>
<h6 id="1️⃣-from-tbl">1️⃣ <strong>FROM TBL</strong> </h6>
<ul>
<li>테이블 전체를 대상으로 시작합니다.</li>
<li>각 행에는 ID, START_VAL, END_VAL이 포함되어 있습니다.</li>
</ul>
<h6 id="2️⃣-nvlend_val-99">2️⃣ <strong>NVL(END_VAL, 99)</strong> </h6>
<ul>
<li>END_VAL이 NULL인 경우 99로 대체합니다.</li>
<li>예: 마지막 행의 END_VAL이 NULL → 99로 처리됨</li>
</ul>
<h6 id="3️⃣-lagnvlend_val-99-over-">3️⃣ <strong>LAG(NVL(END_VAL, 99)) OVER (...)</strong> </h6>
<ul>
<li>이전 행의 END_VAL을 현재 행의 START_VAL과 비교합니다.</li>
<li><strong>FLAG1 = 1</strong>이면 이전 END_VAL과 현재 START_VAL이 같음 → 연속됨</li>
<li><strong>FLAG1 = 0</strong>이면 연속되지 않음</li>
</ul>
<h6 id="4️⃣-leadstart_val-over-">4️⃣ <strong>LEAD(START_VAL) OVER (...)</strong> </h6>
<ul>
<li>다음 행의 START_VAL을 현재 행의 END_VAL과 비교합니다.</li>
<li><strong>FLAG2 = 1</strong>이면 다음 START_VAL과 현재 END_VAL이 같음 → 연속됨</li>
<li><strong>FLAG2 = 0</strong>이면 연속되지 않음</li>
</ul>
<h6 id="5️⃣-where-flag1--0-or-flag2--0">5️⃣ <strong>WHERE FLAG1 = 0 OR FLAG2 = 0</strong> </h6>
<ul>
<li>연속되지 않는 구간만 필터링합니다</li>
<li>즉, 앞뒤 연결이 끊긴 행만 남깁니다</li>
</ul>
<h6 id="6️⃣-select-id-start_val-end_val">6️⃣ <strong>SELECT ID, START_VAL, END_VAL</strong> </h6>
<ul>
<li>최종 출력: 연속되지 않는 구간의 시작과 끝</li>
</ul>
<h6 id="-최종-출력-결과-2">✅ 최종 출력 결과 </h6>
<table>
<thead>
<tr>
<th>ID</th>
<th>START_VAL</th>
<th>END_VAL</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>10</td>
<td>14</td>
</tr>
<tr>
<td>A</td>
<td>15</td>
<td>18</td>
</tr>
<tr>
<td>A</td>
<td>20</td>
<td>25</td>
</tr>
<tr>
<td>A</td>
<td>25</td>
<td>99</td>
</tr>
</tbody>
</table>
<p>➡ 보기 ①과 정확히 일치합니다.</p>
<h6 id="-핵심-요약-7">📌 핵심 요약 </h6>
<table>
<thead>
<tr>
<th>처리 단계</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>LAG()</strong></td>
<td>이전 END_VAL과 현재 START_VAL 비교</td>
</tr>
<tr>
<td><strong>LEAD()</strong></td>
<td>다음 START_VAL과 현재 END_VAL 비교</td>
</tr>
<tr>
<td><strong>NVL()</strong></td>
<td>NULL 값 보정</td>
</tr>
<tr>
<td><strong>FLAG1/FLAG2</strong></td>
<td>연속 여부 판단</td>
</tr>
<tr>
<td><strong>WHERE</strong></td>
<td>연속되지 않는 구간만 추출</td>
</tr>
<tr>
<td><strong>SELECT</strong></td>
<td>결과 출력: ID, 시작값, 끝값</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>연속되지 않는 구간만 출력</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>중간값만 출력</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>일부 누락</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>범위 병합 오류</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
LAG = 이전 행<br>
LEAD = 다음 행</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 43: 윈도우 함수 예시</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">119</span><span class="token punctuation">]</span> 
아래 설명 중 <span class="token punctuation">(</span>가<span class="token punctuation">)</span>, <span class="token punctuation">(</span>나<span class="token punctuation">)</span>에 해당하는 내용을 작성하시오.

DBMS에 생성된 <span class="token environment constant">USER</span>와 다양한 권한들 사이에서 중개 역할을 할 수 있도록 DBMS에서는 ROLE을 제공한다. 이러한 ROLE을 DBMS <span class="token environment constant">USER</span>에게 부여하기 위해서는 <span class="token punctuation">(</span>가<span class="token punctuation">)</span> 명령을 사용하며, ROLE을 회수하기 위해서는 <span class="token punctuation">(</span>나<span class="token punctuation">)</span> 명령을 사용한다.
</code></pre><p><strong>✅ 정답:</strong> 가 - GRANT, 나 - REVOKE</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
권한을 주려면 GRANT, 회수하려면 REVOKE!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>GRANT: 권한 부여</li>
<li>REVOKE: 권한 회수</li>
<li>ROLE은 권한 묶음</li>
</ul>
<p>🧠 <strong>기억법:</strong><br>
GRANT = 주다<br>
REVOKE = 뺏다</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 61: DCL = 권한 제어</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">120</span><span class="token punctuation">]</span>  
다음 중 B_User가 아래의 작업을 수행할 수 있도록 권한을 부여하는 DCL로 가장 적절한 것은?
</code></pre><pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-UPDATE">UPDATE</span> A_User<span class="token punctuation">.</span>TB_A
<span class="token keyword keyword-SET">SET</span>   coll<span class="token operator">=</span><span class="token string">'AAA'</span>
<span class="token keyword keyword-WHERE">WHERE</span> col2<span class="token operator">=</span><span class="token number">3</span>
</code></pre><p>① GRANT  SELECT, UPDATE TO B_User;<br>
② REVOKE SELECT ON A_User.TB_A FROM B_User;<br>
③ DENY   UPDATE ON A_User.TB_A TO   B_User;<br>
④ GRANT  SELECT, UPDATE ON A_User.TB_A TO B_User;</p>
<p><strong>✅ 정답:</strong> ④</p>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-GRANT">GRANT</span> <span class="token keyword keyword-SELECT">SELECT</span><span class="token punctuation">,</span> <span class="token keyword keyword-UPDATE">UPDATE</span> <span class="token keyword keyword-ON">ON</span> A_User<span class="token punctuation">.</span>TB_A <span class="token keyword keyword-TO">TO</span> B_User<span class="token punctuation">;</span>
</code></pre><p>🧸 <strong>쉬운 해설:</strong><br>
테이블에 SELECT와 UPDATE 권한을 주려면 GRANT로 명시해야 해요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>GRANT ... ON 테이블 TO 사용자</li>
<li>SELECT, UPDATE 권한 명시</li>
</ul>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>ON 절 누락</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>권한 회수</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>DENY는 일부 DBMS 전용</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>정확한 문법</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
GRANT ON 테이블 TO 사용자</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 61: DCL = 권한 제어</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">121</span><span class="token punctuation">]</span> 
아래의 <span class="token punctuation">(</span>가<span class="token punctuation">)</span>에 들어갈 내용을 쓰시오.

DBMS 사용자를 생성하면 기본적으로 많은 권한을 부여해야 한다. 많은 DBMS에서는 DBMS 관리자가 사용자별로 권한을 관리해야 하는 부담과 복잡함을 줄이기 위하여 다양한 권한을 그룹으로 묶어 관리할 수 있도록 사용자와 권한 사이에서 중개 역할을 수행하는 <span class="token punctuation">(</span>가<span class="token punctuation">)</span>을 제공한다. 
</code></pre><p><strong>✅ 정답:</strong> ROLE</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
ROLE은 권한 묶음이에요. 사용자에게 한 번에 여러 권한을 줄 수 있어요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>ROLE: 권한의 집합</li>
<li>GRANT/REVOKE로 사용자에게 부여/회수</li>
</ul>
<p>🧠 <strong>기억법:</strong><br>
ROLE = 권한 묶음</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 61: DCL = 권한 제어</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">122</span><span class="token punctuation">]</span>  
사용자 Lee가 릴레이션 R을 생성한 후, 아래와 같은 권한부여 SQL문들을 실행하였다. 그 이후에 기능이 실행 가능한 SQL을 <span class="token number">2</span>개 고르시오. <span class="token punctuation">(</span>단, A, B의 데이터 타입은 정수형이다<span class="token punctuation">)</span>
</code></pre><pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code>Lee: <span class="token keyword keyword-GRANT">GRANT</span> <span class="token keyword keyword-SELECT">SELECT</span><span class="token punctuation">,</span> <span class="token keyword keyword-INSERT">INSERT</span><span class="token punctuation">,</span> <span class="token keyword keyword-DELETE">DELETE</span> <span class="token keyword keyword-ON">ON</span> R <span class="token keyword keyword-TO">TO</span> Kim <span class="token keyword keyword-WITH">WITH</span> <span class="token keyword keyword-GRANT">GRANT</span> <span class="token keyword keyword-OPTION">OPTION</span><span class="token punctuation">;</span>
Kim: <span class="token keyword keyword-GRANT">GRANT</span> <span class="token keyword keyword-SELECT">SELECT</span><span class="token punctuation">,</span> <span class="token keyword keyword-INSERT">INSERT</span><span class="token punctuation">,</span> <span class="token keyword keyword-DELETE">DELETE</span> <span class="token keyword keyword-ON">ON</span> R <span class="token keyword keyword-TO">TO</span> Park<span class="token punctuation">;</span>
Lee: <span class="token keyword keyword-REVOKE">REVOKE</span> <span class="token keyword keyword-DELETE">DELETE</span> <span class="token keyword keyword-ON">ON</span> R <span class="token keyword keyword-FROM">FROM</span> Kim<span class="token punctuation">;</span>
Lee: <span class="token keyword keyword-REVOKE">REVOKE</span> <span class="token keyword keyword-INSERT">INSERT</span> <span class="token keyword keyword-ON">ON</span> R <span class="token keyword keyword-FROM">FROM</span> Kim <span class="token keyword keyword-CASCADE">CASCADE</span><span class="token punctuation">;</span>
</code></pre><p>① Park: SELECT * FROM R WHERE A = 400;<br>
② Park: INSERT INTO R VALUES (400, 600);<br>
③ Park: DELETE FROM R WHERE B = 800;<br>
④ Kim : INSERT INTO R VALUES (500, 600);</p>
<p><strong>✅ 정답:</strong> ①, ③</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
CASCADE로 INSERT 권한은 Park까지 회수되지만 DELETE는 회수되지 않았어요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>Kim은 GRANT OPTION으로 Park에게 권한 위임 가능</li>
<li>DELETE 권한은 회수되지 않았으므로 Park은 DELETE 가능</li>
<li>INSERT는 CASCADE로 회수됨 → Park은 INSERT 불가</li>
<li>SELECT는 회수되지 않음 → Park은 SELECT 가능</li>
</ul>
<h6 id="-권한-부여-및-회수-흐름">✅ 권한 부여 및 회수 흐름 </h6>
<h6 id="1️⃣-lee-grant-select-insert-delete-on-r-to-kim-with-grant-option">1️⃣ <strong>Lee: GRANT SELECT, INSERT, DELETE ON R TO Kim WITH GRANT OPTION;</strong> </h6>
<ul>
<li>사용자 Lee가 Kim에게 SELECT, INSERT, DELETE 권한을 부여함</li>
<li><strong>WITH GRANT OPTION</strong> → Kim은 다른 사용자에게 권한을 위임할 수 있음</li>
</ul>
<h6 id="2️⃣-kim-grant-select-insert-delete-on-r-to-park">2️⃣ <strong>Kim: GRANT SELECT, INSERT, DELETE ON R TO Park;</strong> </h6>
<ul>
<li>Kim이 Park에게 권한을 위임함</li>
<li>Park은 SELECT, INSERT, DELETE 권한을 갖게 됨</li>
</ul>
<h6 id="3️⃣-lee-revoke-delete-on-r-from-kim">3️⃣ <strong>Lee: REVOKE DELETE ON R FROM Kim;</strong> </h6>
<ul>
<li>Kim의 DELETE 권한이 회수됨</li>
<li>하지만 <strong>CASCADE</strong>가 없으므로 Park의 DELETE 권한은 <strong>유지됨</strong></li>
</ul>
<h6 id="4️⃣-lee-revoke-insert-on-r-from-kim-cascade">4️⃣ <strong>Lee: REVOKE INSERT ON R FROM Kim CASCADE;</strong> </h6>
<ul>
<li>Kim의 INSERT 권한이 회수됨</li>
<li><strong>CASCADE</strong> → Kim이 위임한 Park의 INSERT 권한도 <strong>함께 회수됨</strong></li>
</ul>
<h6 id="-각-보기별-실행-가능-여부">✅ 각 보기별 실행 가능 여부 </h6>
<h6 id="1-park-select--from-r-where-a--400---가능">① <strong>Park: SELECT * FROM R WHERE A = 400;</strong> → ✅ 가능 </h6>
<ul>
<li>SELECT 권한은 회수되지 않았음</li>
<li>Park은 SELECT 가능</li>
</ul>
<h6 id="2-park-insert-into-r-values-400-600---불가능">② <strong>Park: INSERT INTO R VALUES (400, 600);</strong> → ❌ 불가능 </h6>
<ul>
<li>INSERT 권한은 <strong>CASCADE</strong>로 회수됨</li>
<li>Park은 INSERT 불가능</li>
</ul>
<h6 id="3-park-delete-from-r-where-b--800---가능">③ <strong>Park: DELETE FROM R WHERE B = 800;</strong> → ✅ 가능 </h6>
<ul>
<li>DELETE 권한은 Kim에게서만 회수됨</li>
<li>Park은 DELETE 권한 유지</li>
</ul>
<h6 id="4-kim-insert-into-r-values-500-600---불가능">④ <strong>Kim: INSERT INTO R VALUES (500, 600);</strong> → ❌ 불가능 </h6>
<ul>
<li>Kim의 INSERT 권한은 회수됨</li>
<li>INSERT 불가능</li>
</ul>
<h6 id="-최종-정답">✅ 최종 정답 </h6>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>실행 가능 여부</th>
<th>이유</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>✅ 가능</td>
<td>SELECT 권한 유지</td>
</tr>
<tr>
<td>②</td>
<td>❌ 불가능</td>
<td>INSERT 권한 CASCADE 회수</td>
</tr>
<tr>
<td>③</td>
<td>✅ 가능</td>
<td>DELETE 권한 유지</td>
</tr>
<tr>
<td>④</td>
<td>❌ 불가능</td>
<td>Kim의 INSERT 권한 회수됨</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
WITH GRANT OPTION → 권한 위임 가능<br>
CASCADE → 위임된 권한까지 회수</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 61: DCL = 권한 제어</li>
<li>🃏 카드 62: GRANT / REVOKE</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">123</span><span class="token punctuation">]</span>   
다음 중 PL/SQL에 대한 설명으로 가장 부적절한 것은?

① 변수와 상수 등을 사용하여 일반 SQL 문장을 실행할 때 WHERE절의 조건 등으로 대입할 수 있다.
② Procedure, User Defined Function, Trigger 객체를 PL/SQL로 작성할 수 있다.
③ PL/SQL로 작성된 Procedure, User Defined Function은 전체가 하나의 트랜젝션으로 처리되어야 한다.
④ Procedure 내부에 작성된 절차적 코드는 PL/SQL엔진이 처리하고 일반적인 SQL 문장은 SQL실행기가 처리한다.
</code></pre><p><strong>✅ 정답:</strong> ③</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
PL/SQL은 트랜잭션을 나눠서 처리할 수 있어요. 전체가 하나의 트랜잭션일 필요는 없어요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>PL/SQL은 절차적 SQL</li>
<li>트랜잭션은 COMMIT, ROLLBACK으로 제어 가능</li>
<li>하나의 프로시저 안에서도 여러 트랜잭션 가능</li>
</ul>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>변수 활용 가능</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>객체 작성 가능</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>트랜잭션 단일화 → 오류</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>SQL은 SQL엔진, 절차는 PL/SQL엔진</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
PL/SQL = SQL + 절차적 로직<br>
트랜잭션은 자유롭게 제어 가능</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 63: PL/SQL 구조</li>
<li>🃏 카드 64: 트랜잭션 제어</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">124</span><span class="token punctuation">]</span> 
아래는 임시부서<span class="token punctuation">(</span>TMP_DEPT<span class="token punctuation">)</span> 테이블로부터 부서<span class="token punctuation">(</span>DEPT<span class="token punctuation">)</span> 테이블에 데이터를 입력하는 PL/SQL 이다. 부서 테이블에 데이터를 입력하기 전에 부서 테이블의 모든 데이터를 ROLLBACK이 불가능 하도록 삭제하려고 한다. 다음 중 <span class="token punctuation">(</span>가<span class="token punctuation">)</span>에 들어갈 내용으로 옳은 것은?
</code></pre><pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token punctuation">[</span>PL<span class="token operator">/</span><span class="token keyword keyword-SQL">SQL</span><span class="token punctuation">]</span>
<span class="token keyword keyword-create">create</span> <span class="token operator">or</span> <span class="token keyword keyword-replace">replace</span> <span class="token keyword keyword-procedure">procedure</span> insert_dept_authid <span class="token keyword keyword-current_user">current_user</span>
<span class="token keyword keyword-as">as</span>
<span class="token keyword keyword-begin">begin</span>
<span class="token punctuation">(</span>가<span class="token punctuation">)</span>
<span class="token keyword keyword-INSERT">INSERT</span> <span class="token comment">/*+ APPEND */</span> <span class="token keyword keyword-INTO">INTO</span> DEPT <span class="token punctuation">(</span>DEPTNO<span class="token punctuation">,</span> DNAME<span class="token punctuation">,</span> LOC<span class="token punctuation">)</span>
<span class="token keyword keyword-SELECT">SELECT</span> DEPTNO<span class="token punctuation">,</span> DNAME<span class="token punctuation">,</span> LOC
<span class="token keyword keyword-FROM">FROM</span> TMP_DEPT<span class="token punctuation">;</span>
<span class="token keyword keyword-commit">commit</span><span class="token punctuation">;</span>
<span class="token keyword keyword-end">end</span><span class="token punctuation">;</span>
<span class="token operator">/</span>
</code></pre><p>①TRUNCATE TABLE DEPT:<br>
② DELETE FROM DEPT:<br>
③ execute immediate 'TRUNCATE TABLE DEPT';<br>
④ execute 'TRUNCATE TABLE DEPT':</p>
<p><strong>✅ 정답:</strong> ③ execute immediate 'TRUNCATE TABLE DEPT';</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
TRUNCATE는 ROLLBACK이 안 돼요. PL/SQL에서는 execute immediate로 실행해야 해요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>TRUNCATE: DDL → ROLLBACK 불가</li>
<li>PL/SQL에서 DDL 실행 시 execute immediate 사용</li>
<li>DELETE는 ROLLBACK 가능</li>
</ul>
<h6 id="-전체-plsql-흐름">✅ 전체 PL/SQL 흐름 </h6>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-CREATE">CREATE</span> <span class="token operator">OR</span> <span class="token keyword keyword-REPLACE">REPLACE</span> <span class="token keyword keyword-PROCEDURE">PROCEDURE</span> insert_dept_authid <span class="token keyword keyword-CURRENT_USER">CURRENT_USER</span>
<span class="token keyword keyword-AS">AS</span>
<span class="token keyword keyword-BEGIN">BEGIN</span>
  <span class="token keyword keyword-EXECUTE">EXECUTE</span> IMMEDIATE <span class="token string">'TRUNCATE TABLE DEPT'</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-INSERT">INSERT</span> <span class="token comment">/*+ APPEND */</span> <span class="token keyword keyword-INTO">INTO</span> DEPT <span class="token punctuation">(</span>DEPTNO<span class="token punctuation">,</span> DNAME<span class="token punctuation">,</span> LOC<span class="token punctuation">)</span>
  <span class="token keyword keyword-SELECT">SELECT</span> DEPTNO<span class="token punctuation">,</span> DNAME<span class="token punctuation">,</span> LOC
  <span class="token keyword keyword-FROM">FROM</span> TMP_DEPT<span class="token punctuation">;</span>
  <span class="token keyword keyword-COMMIT">COMMIT</span><span class="token punctuation">;</span>
<span class="token keyword keyword-END">END</span><span class="token punctuation">;</span>
<span class="token operator">/</span>
</code></pre><h6 id="-sql-처리-순서-한-줄씩-설명-7">🧠 SQL 처리 순서 한 줄씩 설명 </h6>
<h6 id="1️⃣-execute-immediate-truncate-table-dept">1️⃣ <strong>EXECUTE IMMEDIATE 'TRUNCATE TABLE DEPT';</strong> </h6>
<ul>
<li><strong>TRUNCATE</strong>는 DDL 문장이므로 PL/SQL에서는 직접 실행할 수 없습니다</li>
<li>따라서 <strong>EXECUTE IMMEDIATE</strong>를 사용해 동적 SQL로 실행해야 합니다</li>
<li><strong>TRUNCATE</strong>는 ROLLBACK이 불가능하며, 테이블의 모든 데이터를 빠르게 삭제합니다</li>
</ul>
<h6 id="2️⃣-insert--append--into-dept--select--from-tmp_dept">2️⃣ *<em>INSERT /*+ APPEND <em>/ INTO DEPT (...) SELECT ... FROM TMP_DEPT;</em></em> </h6>
<ul>
<li><strong>APPEND</strong> 힌트는 Direct Path Insert를 유도하여 성능을 높입니다</li>
<li>TMP_DEPT 테이블의 데이터를 DEPT 테이블에 삽입합니다</li>
</ul>
<h6 id="3️⃣-commit">3️⃣ <strong>COMMIT;</strong> </h6>
<ul>
<li>삽입된 데이터를 영구 저장합니다</li>
<li><strong>TRUNCATE</strong>는 이미 ROLLBACK이 불가능하므로, COMMIT은 삽입된 데이터에만 적용됩니다</li>
</ul>
<h6 id="-각-보기-설명">✅ 각 보기 설명 </h6>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>① <strong>TRUNCATE TABLE DEPT:</strong></td>
<td>문법 오류 (<strong>:</strong> 사용 불가)</td>
<td>❌</td>
</tr>
<tr>
<td>② <strong>DELETE FROM DEPT;</strong></td>
<td>DELETE는 ROLLBACK 가능 → 조건 불충족</td>
<td>❌</td>
</tr>
<tr>
<td>③ <strong>EXECUTE IMMEDIATE 'TRUNCATE TABLE DEPT';</strong></td>
<td>정확한 문법, DDL 실행 방식</td>
<td>✅</td>
</tr>
<tr>
<td>④ <strong>EXECUTE 'TRUNCATE TABLE DEPT';</strong></td>
<td><strong>IMMEDIATE</strong> 누락 → 문법 오류</td>
<td>❌</td>
</tr>
</tbody>
</table>
<h6 id="-핵심-요약-8">📌 핵심 요약 </h6>
<table>
<thead>
<tr>
<th>처리 단계</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>EXECUTE IMMEDIATE</strong></td>
<td>PL/SQL에서 DDL 실행</td>
</tr>
<tr>
<td><strong>TRUNCATE</strong></td>
<td>빠른 삭제, ROLLBACK 불가</td>
</tr>
<tr>
<td><strong>INSERT + APPEND</strong></td>
<td>성능 최적화된 데이터 삽입</td>
</tr>
<tr>
<td><strong>COMMIT</strong></td>
<td>삽입된 데이터 저장</td>
</tr>
</tbody>
</table>
<p>✅ 보기 ③은 PL/SQL에서 DDL을 안전하게 실행하고, ROLLBACK이 불가능한 삭제를 수행하는 정확한 방식입니다.</p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>문법 오류</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>DELETE는 ROLLBACK 가능</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>정확한 문법</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>execute 누락</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
DDL in PL/SQL → execute immediate</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 63: PL/SQL 구조</li>
<li>🃏 카드 64: 트랜잭션 제어</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">125</span><span class="token punctuation">]</span>   
다음 중 절차형 SQL 모듈에 대한 설명으로 가장 부적절한 것은?

① 저장형 프로시져는 SQL을 로직과 함께 데이터베이스 내에 저장해 놓은 명령문의 집합을 의미한다.
② 저장형 함수<span class="token punctuation">(</span>사용자 정의 함수<span class="token punctuation">)</span>는 단독적으로 실행되기 보다는 다른 SQL문을 통하여 호출되고 그 결과를 리턴하는 SQL의 보조적인 역할을 한다.
③ 트리거는 특정한 테이블에 INSERT, UPDATE, DELETE와 같은 DML문이 수행되었을 때 데이터베이스에서 자동으로 동작하도록 작성된 프로그램이다.
④ 데이터의 무결성과 일관성을 위해서 사용자 정의 함수를 사용한다.
</code></pre><p><strong>✅ 정답:</strong> ④</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
무결성과 일관성은 트리거나 제약조건으로 관리하는 게 일반적이에요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>사용자 정의 함수는 보조적 역할</li>
<li>무결성은 CHECK, FOREIGN KEY, TRIGGER 등으로 관리</li>
<li>함수는 계산, 포맷, 반환 목적</li>
</ul>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>프로시저 정의 정확</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>함수는 보조적 역할</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>트리거 정의 정확</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>무결성 설명 오류</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
무결성 = 제약조건 + 트리거</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 65: 절차형 SQL</li>
<li>🃏 카드 66: 트리거</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">126</span><span class="token punctuation">]</span> 
다음 중 Trigger에 대한 설명으로 가장 부적절한 것은?

① Trigger는 데이터베이스에 의해서 자동으로 호출되고 수행된다.
② Trigger는 특정 테이블에 대해서 INSERT, UPDATE, DELETE 문이 수행되었을 때 호출되도록 정의할 수 있다.
③ Trigger는 TCL을 이용하여 트랜젝션을 제어할 수 있다.
④ Trigger는 데이터베이스에 로그인하는 작업에도 정의할 수 있다.
</code></pre><p><strong>✅ 정답:</strong> ③</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
Trigger에서는 COMMIT, ROLLBACK 같은 TCL을 사용할 수 없어요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>Trigger는 자동 실행</li>
<li>DML 이벤트에 반응</li>
<li>TCL 사용 불가 → 트랜잭션 제어는 외부에서 수행</li>
</ul>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>자동 호출 설명</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>DML 이벤트 설명</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>TCL 사용 가능 → 오류</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>로그인 트리거 가능</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
Trigger = 자동 실행, TCL 불가</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 66: 트리거</li>
<li>🃏 카드 64: 트랜잭션 제어</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">127</span><span class="token punctuation">]</span> 
다음 중 특정한 테이블에 INSERT, UPDATE, DELETE와 같은 DML문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 저장 프로그램으로 가장 적절한 것은?<span class="token punctuation">(</span>단, 사용자가 직접 호출하여 사용하는 것이 아니고 데이터베이스에 서 자동적으로 수행하게 된다.<span class="token punctuation">)</span>

① PROCEDURE
② <span class="token environment constant">USER</span> DEFINED FUNCTION
③ PACKAGE
④ TRIGGER
</code></pre><p><strong>✅ 정답:</strong> ④ TRIGGER</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
사용자가 직접 호출하지 않아도 자동으로 실행되는 건 트리거예요!</p>
<p>📚 <strong>전문 해설:</strong></p>
<ul>
<li>PROCEDURE: 직접 호출</li>
<li>FUNCTION: 호출 후 값 반환</li>
<li>PACKAGE: 묶음</li>
<li>TRIGGER: 자동 실행</li>
</ul>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>직접 호출 필요</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>직접 호출 필요</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>묶음 기능</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>자동 실행</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
TRIGGER = 자동 반응 프로그램</p>
<p>🃏 관련 암기카드</p>
<ul>
<li>🃏 카드 66: 트리거</li>
<li>🃏 카드 65: 절차형 SQL</li>
</ul>

      </div>
      
      
    
    
    <script type="module">
// TODO: If ZenUML gets integrated into mermaid in the future,
//      we can remove the following lines.


var MERMAID_CONFIG = ({"startOnLoad":false});
if (typeof MERMAID_CONFIG !== 'undefined') {
  MERMAID_CONFIG.startOnLoad = false
  MERMAID_CONFIG.cloneCssStyles = false
  MERMAID_CONFIG.theme = "default"
}

mermaid.initialize(MERMAID_CONFIG || {})
if (typeof(window['Reveal']) !== 'undefined') {
  function mermaidRevealHelper(event) {
    var currentSlide = event.currentSlide
    var diagrams = currentSlide.querySelectorAll('.mermaid')
    for (var i = 0; i < diagrams.length; i++) {
      var diagram = diagrams[i]
      if (!diagram.hasAttribute('data-processed')) {
        mermaid.init(null, diagram, ()=> {
          Reveal.slide(event.indexh, event.indexv)
        })
      }
    }
  }
  Reveal.addEventListener('slidetransitionend', mermaidRevealHelper)
  Reveal.addEventListener('ready', mermaidRevealHelper)
  await mermaid.run({
    nodes: document.querySelectorAll('.mermaid')
  })
} else {
  await mermaid.run({
    nodes: document.querySelectorAll('.mermaid')
  })
}
</script>
    
    
    
  
    </body></html>