<!DOCTYPE html><html><head>
      <title>part002_2_sql_modeling_관계</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\sally03915\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.19\crossnote\dependencies\katex\katex.min.css">
      
      
      <script type="text/javascript" src="file:///c:\Users\sally03915\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.19\crossnote\dependencies\mermaid\mermaid.min.js" charset="UTF-8"></script>
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<style>
pre, code {
  white-space: pre-wrap !important;
  word-break: break-word !important;
  overflow-x: hidden !important;
  display: block !important;
  max-width: 100% !important;
  box-sizing: border-box !important;
}
</style> 
<hr>
<h3 id="-모델링-basic-3구간-분할">📁 모델링 BASIC (3구간 분할) </h3>
<table>
<thead>
<tr>
<th>구간</th>
<th>문제 번호</th>
<th>주제 범위</th>
<th>난이도</th>
</tr>
</thead>
<tbody>
<tr>
<td>1단계</td>
<td>001~020</td>
<td>모델링 개념, 엔터티·속성·관계의 기초</td>
<td>⭐ 초급~중급</td>
</tr>
<tr>
<td>2단계</td>
<td>021~036</td>
<td>관계 유형, 식별자, 성능 모델링 개요</td>
<td>⭐⭐ 중급~고급</td>
</tr>
<tr>
<td>3단계</td>
<td>037~052</td>
<td>정규화/반정규화 판단 및 실무 사례 분석</td>
<td>⭐⭐⭐ 고급~실무형</td>
</tr>
</tbody>
</table>
<blockquote>
<p>“기초 → 관계/식별자 → 정규화/실무”</p>
</blockquote>
<h4 id="-2단계-021036">✅ 2단계: 021~036 </h4>
<ul>
<li>관계의 차수, 방향성, 식별자/비식별자 관계를 구분하고</li>
<li>성능을 고려한 모델링 흐름과 트랜잭션 유형을 이해합니다.</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">21</span><span class="token punctuation">]</span>  
다음 중 관계에 대한 설명으로 가장 부적절한 것은?

① 관계는 존재적 관계와 행위에 의한 관계로 나누어볼 수 있다.  
② 관계의 표기법은 관계명, 관계차수, 식별성의 <span class="token number">3</span>가지 개념을 사용한다.  
③ 부서와 사원 엔터티 간의 <span class="token string">'소속'</span> 관계는 존재적 관계의 사례이다.  
④ 주문과 배송 엔터티 간의 <span class="token string">'배송근거'</span> 관계는 행위에 의한 관계의 사례이다.
</code></pre><p><strong>정답:</strong> ②</p>
<p><strong>🧸쉬운 해설:</strong><br>
②번은 “관계 그릴 때 식별성도 같이 표시해!”라고 말하는데,<br>
그건 관계의 속성이지 그림 요소는 아니야!</p>
<p><strong>📚 전문 해설</strong><br>
관계의 표기법은 일반적으로 <strong>관계명과 관계차수</strong>를 사용하지만,<br>
‘식별성’은 관계의 속성이지 표기법의 구성 요소는 아니에요.<br>
②번은 표기법과 관계 속성을 혼동한 설명입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>관계 유형 구분 (존재적/행위적)</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>표기법에 식별성 포함</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>'소속' 관계 = 존재적 관계</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>'배송근거' 관계 = 행위적 관계</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
관계 표기법 = <strong>관계명 + 관계차수</strong><br>
❌ 식별성은 표기법이 아니라 관계의 속성!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 12: 관계의 차수 = 몇 명이 연결?</li>
<li>🃏 카드 13: 관계의 참여도 = 꼭 연결돼야 하나?</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">22</span><span class="token punctuation">]</span>  
다음 중 엔터티간의 관계에서 <span class="token number">1</span>:1, <span class="token number">1</span>:M과 같이 관계의 기수성을 나타내는  
것으로 가장 적절한 것은?

① 관계명<span class="token punctuation">(</span>Relationship Membership<span class="token punctuation">)</span>  
② 관계차수<span class="token punctuation">(</span>Relationship Degree/Cardinality<span class="token punctuation">)</span>  
③ 관계선택사양<span class="token punctuation">(</span>Relationship Optionality<span class="token punctuation">)</span>  
④ 관계정의<span class="token punctuation">(</span>Relationship Definition<span class="token punctuation">)</span>
</code></pre><p><strong>정답:</strong> ②</p>
<p><strong>🧸 쉬운 해설:</strong><br>
②번은 “몇 명이 연결되는지 알려주는 숫자야!”<br>
예: 고객 1명은 주문 여러 개 가능 → 1:N</p>
<p><strong>📚 전문 해설</strong><br>
관계차수(Cardinality)는 관계의 <strong>기수성</strong>, 즉 몇 개의 인스턴스가 연결되는지를 나타내요.<br>
예: 1:1, 1:N, N:M 같은 표현이 바로 관계차수입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>관계명: 관계의 이름</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>관계차수: 인스턴스 수 표현</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>선택사양: 필수/선택 여부</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>정의: 관계 설명</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p><strong>🧠 기억법:</strong><br>
기수성 = <strong>Cardinality = 관계차수</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 12: 관계의 차수 = 몇 명이 연결?</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">23</span><span class="token punctuation">]</span>  
다음 중 두 개의 엔터티 사이에 정의한 관계를 체크하는 사항으로 가장 부적절한 것은?

① 두 개의 엔터티 사이에 관심 있는 연관규칙이 존재하는가?  
② 두 개의 엔터티 사이에 정보의 조합이 발생되는가?  
③ 업무기술서, 장표에 관계연결을 가능하게 하는 명사 <span class="token punctuation">(</span>Noun<span class="token punctuation">)</span>가 있는가?  
④ 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?
</code></pre><p><strong>정답:</strong> ③</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
③번은 “명사로 관계를 연결해!”라고 말하는데,<br>
관계는 동사로 연결해야 돼!</p>
<p><strong>📚 전문 해설</strong><br>
관계를 도출할 때는 <strong>동사(Verb)</strong> 가 핵심이에요.<br>
명사(Noun)는 엔터티를 나타내고, 관계를 연결하는 건 동사입니다.<br>
③번은 관계 연결 요소로 명사를 제시했기 때문에 부적절합니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>연관규칙 존재 여부</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>정보 조합 발생 여부</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>명사로 관계 연결</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>규칙 서술 여부</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
관계 연결 키워드 = <strong>동사(Verb)</strong><br>
❌ 명사는 엔터티 이름!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 13: 관계의 참여도 = 꼭 연결돼야 하나?</li>
<li>🃏 카드 3: 관계 = 대상 간 연결</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">24</span><span class="token punctuation">]</span>  
다음 중 두 개의 엔터티 사이에서 관계를 도출 할 때 체크 할 사항을  모두 고른 것은?

<span class="token operator">&gt;</span> 가. 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?  
<span class="token operator">&gt;</span> 나. 두 개의 엔터티 사이에 정보의 조합이 발생되는가?  
<span class="token operator">&gt;</span> 다. 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?  
<span class="token operator">&gt;</span> 라. 업무기술서, 장표에 관계연결을 가능하게 하는 동사<span class="token punctuation">(</span>Verb<span class="token punctuation">)</span>가 있는가?

① 가. 다. 라  
② 가. 다. 라  
③ 가. 나. 다  
④ 가. 나. 다. 라
</code></pre><p><strong>정답:</strong> ④</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
④번은 “관계를 찾을 때 필요한 건 다 들어 있어!”<br>
규칙도 보고, 동사도 보고, 정보도 보고!</p>
<p><strong>📚 전문 해설</strong><br>
관계를 도출할 때는 연관규칙, 정보 조합, 규칙 서술, 동사 표현 모두 중요해요.<br>
이 네 가지가 모두 체크 포인트입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>일부만 포함</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>일부만 포함</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>라 누락</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>전체 포함</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
관계 도출 4요소 = <strong>규칙 + 조합 + 설명 + 동사</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 13: 관계의 참여도 = 꼭 연결돼야 하나?</li>
<li>🃏 카드 3: 관계 = 대상 간 연결</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">25</span><span class="token punctuation">]</span>  
다음 중 아래에서 주식별자를 지정할 때 고려해야 할 사항을 묶은 것으로 가장 적절한 것은?

<span class="token operator">&gt;</span> 가. 주식별자에 의해 엔티티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.  
<span class="token operator">&gt;</span> 나. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.  
<span class="token operator">&gt;</span> 다. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.  
<span class="token operator">&gt;</span> 라. 주식별자가 지정이 되면 반드시 값이 들어와야 한다.

① 가. 나. 다  
② 가. 나. 라  
③ 나. 다. 라  
④ 가. 나. 다. 라
</code></pre><p><strong>정답:</strong> ④</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
④번은 “식별자는 꼭 있어야 하고, 안 바뀌고, 하나만 있어야 돼!”<br>
모든 조건을 다 갖췄어!</p>
<p><strong>📚 전문 해설</strong><br>
주식별자는 유일성, 안정성, 필수성 모두 만족해야 해요.<br>
④번은 이 모든 조건을 포함한 완전한 설명입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>라 누락</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>다 누락</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>가 누락</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>전체 포함</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
주식별자 4조건 = <strong>유일성 + 최소성 + 안정성 + 필수성</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 61: PRIMARY KEY = 고유 이름표</li>
<li>🃏 카드 60: 제약조건 = 생성 또는 수정 시 설정</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">26</span><span class="token punctuation">]</span>  
다음 중 사원엔터티에서 식별자의 특성에 해당하지 않는 것은 무엇인가?

① 주식별자  
② 단일식별자  
③ 내부식별자  
④ 인조식별자
</code></pre><div class="mermaid">erDiagram
    부서 {
        int 부서번호  PK
        string 부서명
    }
    사원 {
        int    사번    PK
        int 부서번호 FK
        String 주민등록번호
    }

    부서 ||--o{사원 : 소속된다

</div><p><strong>정답:</strong> ④</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
④번은 “사번은 시스템이 만든 번호야!”라고 말하는데,<br>
④번은 사람이 정한 번호니까 틀렸어!</p>
<p><strong>📚 전문 해설</strong><br>
사번은 실제 업무에서 사용되는 자연식별자예요.<br>
인조식별자는 시스템에서 생성된 값인데, ④ 번은 그렇지 않기 때문에 해당되지 않아요.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>주식별자</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>단일식별자</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>내부식별자</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>인조식별자</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
인조식별자 = <strong>시스템이 자동 생성한 값</strong><br>
④ 사번은 자연식별자!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>카드 61: PRIMARY KEY = 고유 이름표</li>
<li>카드 63: UNIQUE = 중복 ❌, NULL 가능</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">27</span><span class="token punctuation">]</span>  
다음 중 식별자로 가장 부적절한 것은?
</code></pre><p>①</p>
<div class="mermaid">erDiagram
    사원 {
        NUMBER(10)    사번번호    PK 
        NUMBER(13) 주민등록번호
    }
</div><p>②</p>
<div class="mermaid">erDiagram
    사원 {
        VARCHAR2(20) 이름    PK 
        NUMBER(10)   사원번호
    }
</div><p>③</p>
<div class="mermaid">erDiagram
    사원 {
        NUMBER(13) 주민등록번호    PK 
        NUMBER(10)    사번번호
    }
</div><p>④</p>
<div class="mermaid">erDiagram
    사원 {
        VARCHAR2(10) 일련번호    PK 
        NUMBER(13) 주민등록번호      
        NUMBER(10)    사번번호
    }
</div><p><strong>정답:</strong> ②</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
②번은 “이름으로 사람을 구분할 수 있어!”라고 말하는데,<br>
세상에 같은 이름 가진 사람 많잖아!</p>
<p><strong>📚 전문 해설:</strong><br>
식별자는 반드시 <strong>유일성</strong>을 만족해야 해요.<br>
이름은 중복될 수 있기 때문에 식별자로 부적절합니다.<br>
예를 들어 ‘김민수’라는 이름을 가진 사람이 여러 명 있을 수 있어요.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>사번번호: 유일함</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>이름: 중복 가능</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>주민등록번호: 유일함</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>일련번호: 시스템 생성 가능</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
식별자는 <strong>중복되면 안 돼!</strong><br>
이름은 절대 식별자로 쓰지 말기!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 61: PRIMARY KEY = 고유 이름표</li>
<li>🃏 카드 63: UNIQUE = 중복 ❌, NULL 가능</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">28</span><span class="token punctuation">]</span>  
다음 중 아래에서 엔터티 내에 주식별자를 도출하는 기준을 묶은 것으로  
가장 적절한 것은?

<span class="token operator">&gt;</span> 가. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.  
<span class="token operator">&gt;</span> 나. 명칭, 내역 등과 같이 이름으로 기술되는 것들을 주식별자로 지정한다.  
<span class="token operator">&gt;</span> 다. 복합으로 주식별자를 구성할 경우 너무 많은 속성을 포함하지 않도록 한다.  
<span class="token operator">&gt;</span> 라. 자주 수정되는 속성을 주식별자로 지정한다.

① 가, 나  
② 가, 다  
③ 다, 라  
④ 나, 라
</code></pre><p><strong>정답:</strong> ②</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
②번은 “자주 쓰고, 너무 복잡하지 않은 걸로 골라!”<br>
이름이나 자주 바뀌는 건 식별자에 안 맞아!</p>
<p><strong>📚 전문 해설</strong><br>
주식별자는 자주 사용하는 속성이면서, 너무 많은 속성을 포함하지 않아야 해요.<br>
‘명칭’이나 ‘자주 수정되는 속성’은 식별자로 부적절합니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>나 포함: 이름 → ❌</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>가, 다 포함</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>라 포함: 자주 수정 → ❌</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>나, 라 포함</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
식별자 도출 기준 = <strong>자주 쓰는 + 안정적 + 간단한 속성</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 61: PRIMARY KEY = 고유 이름표</li>
<li>🃏 카드 64: NOT NULL = 빈칸 금지</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">29</span><span class="token punctuation">]</span>  
프로젝트를 전개할 때는 식별자관계와 비식별자관계를 선택하여 연결  
해야 하는 높은 수준의 데이터모델링 기술이 필요하다. 다음 중 비식별자  
관계를 선택하는 기준으로 가장 부적절한 것은?

① 관계의 강약을 분석하여 상호간에 연관성이 약할 경우 비식별자관계를 고려한다.  
② 자식테이블에서 독립적인 Primary Key의 구조를 가지기 원할 때 비식별자관계를 고려한다.  
③ 모든 관계가 식별자 관계로 연결되면 SQL Where절에서 비교하는 항목이 증가되어 조인에 참여하는 테이블에 따라 SQL문장이 길어져 SQL문의 복잡성이 증가되는 것을 방지하기 위해 비식별자관계를 고려한다.  
④ 부모엔터티의 주식별자를 자식엔터티에서 받아 손자엔터티까지 계속 흘려보내기 위해 비식별자관계를 고려한다.
</code></pre><p><strong>정답:</strong> ④</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
④번은 “식별자를 계속 전달해!”라고 말하는데,<br>
비식별자는 전달 안 해도 되는 구조야!</p>
<p><strong>📚 전문 해설</strong><br>
④번은 오히려 식별자 관계를 사용할 때의 특징이에요.<br>
비식별자 관계는 부모의 식별자를 자식이 <strong>받지 않는</strong> 구조입니다.<br>
식별자를 계속 흘려보내는 건 비식별자 관계와 반대예요.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>연관성 약할 때</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>자식 PK 독립</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>SQL 복잡성 방지</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>식별자 흘려보내기</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
비식별자 관계 = <strong>식별자 전달 안 함 + 자식 독립적</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 18: 비식별 관계 = 독립적 연결</li>
<li>🃏 카드 61: PRIMARY KEY = 고유 이름표</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">30</span><span class="token punctuation">]</span>  
다음 중 비식별자 관계로 연결하는 것을 고려해야 하는 경우로 가장 부적절한 것은?

① 부모엔터티에 참조값이 없어도 자식엔터티의 인스턴스가 생성될 수 있는 경우  
② 부모엔터티의 인스턴스가 자식 엔터티와 같이 소멸되는 경우  
③ 여러 개의 엔터티를 하나로 통합하면서 각각의 엔터티가 갖고 있던 여러 개의 개별 관계가 통합되는 경우  
④ 자식쪽 엔터티의 주식별자를 부모엔터티와는 별도로 생성하는 것이 더 유리하다고 판단하는 경우
</code></pre><p><strong>정답:</strong> ②</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
②번은 “부모랑 자식이 같이 사라져!”라고 말하는데,<br>
그건 서로 너무 강하게 연결된 관계야!</p>
<p><strong>📚 전문 해설</strong><br>
②번은 식별자 관계의 특징이에요.<br>
부모와 자식이 함께 소멸되는 경우는 <strong>강한 연관성</strong>이 있기 때문에 식별자 관계로 연결하는 게 맞습니다.<br>
비식별자 관계는 자식이 독립적으로 존재할 수 있어야 해요.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>자식 독립 생성</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>함께 소멸</td>
<td>❌ 식별자 관계 특징</td>
</tr>
<tr>
<td>③</td>
<td>관계 단순화</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>자식 PK 독립 생성</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
비식별자 관계 = <strong>자식 독립 + 부모 없어도 존재 가능</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 18: 비식별 관계 = 독립적 연결</li>
<li>🃏 카드 62: FOREIGN KEY = 연결 다리</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">31</span><span class="token punctuation">]</span>  
다음 중 성능 데이터모델링에 대한 설명으로 가장 부적절한 것은?

① 성능이 저하된 결과를 대상으로 데이터모델 보다는 문제발생 시점의 SQL을 중심으로 집중하여 튜닝을 한다.  
② 데이터의 증가가 빠를수록 성능저하에 따른 성능개선비용은 증가한다  
③ 데이터모델은 성능을 튜닝하면서 변경이 될 수 있는 특징이 있다.  
④ 분석/설계 단계에서 성능을 고려한 데이터모델링을 수행할 경우 성능저하에 따른 Rework비용을 최소화 할 수 있는 기회를 가지게 된다.
</code></pre><p><strong>정답:</strong> ①</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
①번은 “문제 생기면 SQL만 고치면 돼!”라고 말하는데,<br>
모델 자체가 문제일 수도 있어!</p>
<p><strong>📚 전문 해설:</strong><br>
성능 문제는 단순히 SQL 튜닝만으로 해결되지 않아요.<br>
데이터모델 자체가 성능에 영향을 주기 때문에 모델링 단계에서부터 고려해야 해요.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>SQL만 튜닝</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>데이터 증가 → 비용 증가</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>모델 변경 가능</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>설계단계에서 성능 고려</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
성능 튜닝은 <strong>SQL + 모델링</strong> 함께 고려해야 함!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 65: 성능 모델링 흐름 = 정규화 → 반정규화</li>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">32</span><span class="token punctuation">]</span>  
아래 설명을 읽고 다음 <span class="token punctuation">(</span>가<span class="token punctuation">)</span>에 들어갈 단어를 작성하시오.

<span class="token operator">&gt;</span> 첫번째, 데이터모델링을 할 때 정규화를 정확하게 수행한다.  
<span class="token operator">&gt;</span> 두번째, 데이터베이스 용량산정을 수행한다.  
<span class="token operator">&gt;</span> 세번째, 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.  
<span class="token operator">&gt;</span> 네번째, 용량과 트랜잭션의 유형에 따라 <span class="token punctuation">[</span>  가  <span class="token punctuation">]</span>를 수행한다.  
<span class="token operator">&gt;</span> 다섯번째, 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.
</code></pre><p><strong>정답:</strong> 반정규화</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
“정리 먼저 하고, 필요하면 다시 합쳐서 빠르게 만들자!”<br>
그게 반정규화야!</p>
<p><strong>📚 전문 해설:</strong><br>
정규화를 먼저 수행한 후, 성능이나 트랜잭션 특성에 따라 반정규화를 적용해요.<br>
반정규화는 성능 개선을 위한 전략입니다.</p>
<p><strong>🧠 기억법:</strong><br>
정규화 → 반정규화 = <strong>정리 후 성능 최적화</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
<li>🃏 카드 65: 성능 모델링 흐름 = 정규화 → 반정규화</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">33</span><span class="token punctuation">]</span>  
다음 중 아래에서 성능을 고려한 데이터 모델링의 순서로 가장 적절한 것은?

① 가-나-다-라-마-바  
② 가-나-다-라-바-마  
③ 가-다-라-바-나-마  
④ 가-다-라-나-바-마
</code></pre><blockquote>
<p>가. 데이터 모델링을 할 때 정규화를 정확하게 수행한다.<br>
나. 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.<br>
다. 데이터베이스 용량산정을 수행한다.<br>
라. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.<br>
마. 성능관점에서 데이터 모델을 검증한다.<br>
바. 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.</p>
</blockquote>
<p><strong>정답:</strong> ④</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
④번은 “먼저 정리하고, 양과 흐름 보고, 다시 조정해서 성능 체크!”<br>
실제 프로젝트에서도 이렇게 해!</p>
<p><strong>📚 전문 해설:</strong><br>
정규화 → 용량산정 → 트랜잭션 파악 → 반정규화 → 구조 조정 → 성능 검증<br>
이 순서가 가장 논리적이고 실무에 적합합니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>순서 오류</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>순서 오류</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>순서 오류</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>논리적 순서</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
모델링 순서 = <strong>정→용→트→반→조→검</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 65: 성능 모델링 흐름 = 정규화 → 반정규화</li>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">34</span><span class="token punctuation">]</span>  
다음 중 성능데이터 모델링을 할 때 고려사항으로 가장 부적절한 것은?

① 데이터 모델링의 정규화는 항상 조회 성능저하를 나타내므로 반정규화 관점에서만 성능을 고려하여 설계하도록 한다.  
② 용량산정은 전체적인 데이터베이스에 발생되는 트랜잭션의 유형과 양을 분석하는 자료가 되므로 성능데이터 모델링을 할 때 중요한 작업이 될 수 있다.  
③ 물리적인 데이터 모델링을 할 때 PK/FK의 칼럼의 순서조정, FK인덱스 생성 등은 성능 향상을 위한 데이터 모델링 작업에 중요한 요소가 된다.  
④ 이력데이터는 시간에 따라 반복적으로 발생이 되기 때문에 대량 데이터일 가능성이 높아 특별히 성능을 고려하여 칼럼 등을 추가하도록 설계해야 한다.
</code></pre><p><strong>정답:</strong> ①</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
①번은 “무조건 반정규화 해야 성능 좋아져!”라고 말하는데,<br>
그건 상황에 따라 달라!</p>
<p><strong>📚 전문 해설:</strong><br>
정규화는 반드시 성능을 저하시키는 것이 아니며,<br>
반정규화는 필요할 때만 적용해야 해요.<br>
①번은 지나치게 반정규화만 강조해서 부적절합니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>반정규화만 강조</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>용량산정 중요성</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>물리적 설계 요소</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>이력데이터 고려</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
정규화 ≠ 성능 저하<br>
반정규화는 <strong>선택적 전략</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 65: 성능 모델링 흐름 = 정규화 → 반정규화</li>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">35</span><span class="token punctuation">]</span>  
아래와 같은 보관금원장 엔터티에서 관서에 대한 정보가 반정규화 되어 있기 때문에 관서정보를 조회할 때 성능저하가 발생하고 있다. 이 엔터티에 대해 몇 차 정규화가 필요한 지와 분리된 스키마 구조를 가장 바르게 짝지은 것은?

함수종속성<span class="token punctuation">(</span>FD<span class="token punctuation">)</span>:  
<span class="token punctuation">(</span>관서번호, 납부자번호<span class="token punctuation">)</span> → <span class="token punctuation">(</span>직급명, 통신번호<span class="token punctuation">)</span>  
<span class="token punctuation">(</span>관서번호<span class="token punctuation">)</span> → <span class="token punctuation">(</span>관리점번호, 관서명, 상태, 관서등록일자<span class="token punctuation">)</span>
</code></pre><table>
<thead>
<tr>
<th>사원</th>
</tr>
</thead>
<tbody>
<tr>
<td>관서번호 <br> 납부자번호</td>
</tr>
<tr>
<td>관리점번호 <br> 관서명 <br>상태 <br>관서등록일자<br>직급명<br>통신번호</td>
</tr>
</tbody>
</table>
<p>① 2차 정규화 - 정규화테이블(<u>관서번호, 납부자번호</u>, 관리점번호, 관서명, 상태, 관서등록일자)<br>
② 3차 정규화 - 정규화테이블(<u>관서번호, 납부자번호</u>, 관리점번호, 관서명,상태, 관서등록일자)<br>
③ 2차 정규화 - 정규화테이블(<u>관서번호</u>, 관리점번호, 관서명, 상태, 관서등록일자)<br>
④ 3차 정규화 - 정규화테이블(<u>관서번호</u>, 관리점번호, 관서명, 상태, 관서등록일자)</p>
<p><strong>정답:</strong> ③</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
③번은 “관서번호만으로 정리되는 정보는 따로 떼자!”<br>
그게 2차 정규화야!</p>
<p><strong>📚 전문 해설:</strong><br>
관서번호에만 종속된 속성들을 분리해야 하므로 2차 정규화가 필요해요.<br>
③번은 정확히 그 구조를 반영한 정답입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>복합키 유지</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>정규화 단계 과도</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>부분 종속 제거</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>단계 과도</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
2차 정규화 = <strong>부분 종속 제거</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 67: 2차 정규화 = 부분 종속 제거</li>
<li>🃏 카드 68: 정규화 판단 기준 = 함수 종속성 분석</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">36</span><span class="token punctuation">]</span>  
다음 중 아래 <span class="token string">'일자별매각물건'</span> 엔터티에 대한 설명으로 가장 적절한 것은?

- 일자별매각물건: 약 <span class="token number">100</span>만 건  
- 매각일자별매각내역: 약 <span class="token number">2</span>만 건
</code></pre><div class="mermaid">erDiagram
    매각물건 {
        int 매각물건번호 PK
        int 감정가액
        date 등록일자
        string 등록자
    }

    일자별매각물건 { 
        int 매각물건번호(FK)  PK
        date **매각일자**    PK      
        string **매각시각**
        string **매각장소**
        int 최저매각가격
        int 물건상태코드
    }

    매각일자별매각내역 {
        date 매각일자  pk
        int 총매각금액
        int 충유찰금액
        int 총매각물건수
        int 유찰물건수
    }
    
    매각물건 ||--o{ 일자별매각물건 : 반정규화된속성들
    일자별매각물건 ||--|| 매각일자별매각내역 : 매각기일-양방향
</div><ul>
<li>일자별매각물건: 약 100만 건</li>
<li>매각일자별매각내역: 약 2만 건</li>
<li><strong>반정규화된 속성들</strong></li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>① 1차 정규화가 필요한 엔터티로서 매각기일과 일자별매각물건으로 1:M
관계가 될 수 있다.
② 1차 정규화가 필요한 엔터티로서 매각기일과 일자별매각물건으로 1:1
관계가 될 수 있다.
③ 2차 정규화가 필요한 엔터티로서 매각기일과 일자별매각물건으로 1:M
관계가 될 수 있다.
④ 2차 정규화가 필요한 엔터티로서 매각기일과 일자별매각물건으로 1:1
관계가 될 수 있다.
</code></pre><p><strong>정답:</strong> ③</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
③번은 “하나의 날짜에 여러 물건이 팔려!”<br>
그래서 1:M이고, 반복 정보는 정리해야 해!</p>
<p><strong>📚 전문 해설:</strong><br>
매각기일과 매각물건은 1:M 관계이며,<br>
반복되는 속성이 존재하므로 2차 정규화가 필요합니다.<br>
2차 정규화는 부분 함수 종속을 제거하는 과정입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>1차 정규화 언급 → 부족</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>1:1 관계 → 구조 불일치</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>2차 정규화 + 1:M 관계 → 정확</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>2차 정규화 + 1:1 관계 → 관계 오류</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
2차 정규화 = <strong>반복 속성 정리 + 관계 파악</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 67: 2차 정규화 = 부분 종속 제거</li>
<li>🃏 카드 68: 정규화 판단 기준 = 함수 종속성 분석</li>
</ul>

      </div>
      
      
    
    
    <script type="module">
// TODO: If ZenUML gets integrated into mermaid in the future,
//      we can remove the following lines.


var MERMAID_CONFIG = ({"startOnLoad":false});
if (typeof MERMAID_CONFIG !== 'undefined') {
  MERMAID_CONFIG.startOnLoad = false
  MERMAID_CONFIG.cloneCssStyles = false
  MERMAID_CONFIG.theme = "default"
}

mermaid.initialize(MERMAID_CONFIG || {})
if (typeof(window['Reveal']) !== 'undefined') {
  function mermaidRevealHelper(event) {
    var currentSlide = event.currentSlide
    var diagrams = currentSlide.querySelectorAll('.mermaid')
    for (var i = 0; i < diagrams.length; i++) {
      var diagram = diagrams[i]
      if (!diagram.hasAttribute('data-processed')) {
        mermaid.init(null, diagram, ()=> {
          Reveal.slide(event.indexh, event.indexv)
        })
      }
    }
  }
  Reveal.addEventListener('slidetransitionend', mermaidRevealHelper)
  Reveal.addEventListener('ready', mermaidRevealHelper)
  await mermaid.run({
    nodes: document.querySelectorAll('.mermaid')
  })
} else {
  await mermaid.run({
    nodes: document.querySelectorAll('.mermaid')
  })
}
</script>
    
    
    
  
    </body></html>