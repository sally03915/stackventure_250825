<!DOCTYPE html><html><head>
      <title>part002_3_sql_modeling_정규화</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\sally03915\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.19\crossnote\dependencies\katex\katex.min.css">
      
      
      <script type="text/javascript" src="file:///c:\Users\sally03915\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.19\crossnote\dependencies\mermaid\mermaid.min.js" charset="UTF-8"></script>
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<style>
pre, code {
  white-space: pre-wrap !important;
  word-break: break-word !important;
  overflow-x: hidden !important;
  display: block !important;
  max-width: 100% !important;
  box-sizing: border-box !important;
}
</style> 
<hr>
<h3 id="-모델링-basic-3구간-분할">📁 모델링 BASIC (3구간 분할) </h3>
<table>
<thead>
<tr>
<th>구간</th>
<th>문제 번호</th>
<th>주제 범위</th>
<th>난이도</th>
</tr>
</thead>
<tbody>
<tr>
<td>1단계</td>
<td>001~020</td>
<td>모델링 개념, 엔터티·속성·관계의 기초</td>
<td>⭐ 초급~중급</td>
</tr>
<tr>
<td>2단계</td>
<td>021~036</td>
<td>관계 유형, 식별자, 성능 모델링 개요</td>
<td>⭐⭐ 중급~고급</td>
</tr>
<tr>
<td>3단계</td>
<td>037~052</td>
<td>정규화/반정규화 판단 및 실무 사례 분석</td>
<td>⭐⭐⭐ 고급~실무형</td>
</tr>
</tbody>
</table>
<blockquote>
<p>“기초 → 관계/식별자 → 정규화/실무”</p>
</blockquote>
<h4 id="-3단계-037052">✅ 3단계: 037~052 </h4>
<ul>
<li>정규화 단계별 판단 기준과 반복 속성 구조를 분석하고</li>
<li>반정규화 적용 시점과 실무 사례 중심의 설계 전략을 익힙니다.</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">37</span><span class="token punctuation">]</span>  
아래의 데이터 모델처럼 동일한 유형의 속성이 칼럼단위로 반복되는 경우가 실제 프로젝트를 하면서 많이 발생 될 수 있다. 다음 중 아래와 같이 전제조건이 있을 때 테이블에서 나타날 수 있는 현상으로 가장 적절한 것은?


전제조건: 
유형기능분류코드에 해당하는 속성들은 분포도가 양호 하며, 
SQL Where절에서 각각의 값이 상수값으로 조건 입력될 수 있는 특징을 가진다.
</code></pre><table>
<thead>
<tr>
<th>모델</th>
</tr>
</thead>
<tbody>
<tr>
<td>모델코드 (pk)</td>
</tr>
<tr>
<td>모델명   <br> 제품류코드 <br>  물품가    <br> 출하가    <br> <strong>A유형기능분류코드1</strong> <br> <strong>B유형기능분류코드2</strong> <br> <strong>C유형기능분류코드3</strong> <br> <strong>D유형기능분류코드4</strong> <br> <strong>E유형기능분류코드5</strong> <br> <strong>F유형기능분류코드6</strong> <br> <strong>G유형기능분류코드7</strong> <br> <strong>H유형기능분류코드8</strong> <br> <strong>I유형기능분류코드9</strong>  <br> 바코드  <br> 가로  <br> 세로  <br> 높이  <br> 모델구분</td>
</tr>
</tbody>
</table>
<pre data-role="codeBlock" data-info="" class="language-text"><code>①  조회 조건이 유형기능분류코드에 따라 반복되는 그룹이 칼럼단위로 되어 있으므로 제 1정규형이라고 할 수 있다.
② 유형기능분류코드에 대해 Where절에 조건으로 들어오는 값이 있으므로 PK와 이에 대한 Index만 있으면 SQL 문장은 빠르게 수행될 수 있다고 할 수 있다.
③ 유형기능분류코드가 일반속성 안에서 반복적으로 속성이 구분되어 있기 때문에 이전을 수행해야 하는 제 2정규형이라 할 수 있다.
④ 유형기능분류코드 각각에 대하여 개별로 Index를 모두 생성할 경우 입력, 수정, 삭제 때 성능이 저하되므로 제1차 정규화를 수행한 후 인덱스를 적용하는 것이 좋다.
</code></pre><p><strong>정답:</strong> ④</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
④번은 “너무 많은 인덱스는 느려져!”<br>
먼저 정리하고 인덱스 걸자!</p>
<p><strong>📚 전문 해설:</strong><br>
반복 속성에 대해 인덱스를 모두 생성하면<br>
입력/수정/삭제 시 성능 저하가 발생할 수 있어요.<br>
정규화를 먼저 수행한 후 인덱스를 적용하는 것이 좋습니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>반복 속성 유지 → 정규화 미흡</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>PK 인덱스만으로 충분하다고 판단</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>2차 정규화 언급 → 구조상 과도</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>정규화 후 인덱스 적용 → 정확</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
정규화 → 인덱스<br>
❌ 반복 속성에 무작정 인덱스 금지!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 67: 2차 정규화 = 부분 종속 제거</li>
<li>🃏 카드 68: 정규화 판단 기준 = 함수 종속성 분석</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">38</span><span class="token punctuation">]</span>  
다음 중 아래 <span class="token string">'일재고'</span> 엔터티에 대한 설명으로 가장 적절한 것은?
</code></pre><p>[  일재고 ]</p>
<div class="mermaid">erDiagram
    일재고 {
        string 물류센터코드  PK
        date 재고일자       PK
        int 월초재고수량
        int 장기재고_1개월수량
        int 장기재고_2개월수량
        int 장기재고_3개월수량
        int 장기재고_1개월주문수량
        int 장기재고_2개월주문수량
        int 장기재고_3개월주문수량
        float 장기재고_1개월금액
        float 장기재고_2개월금액
        float 장기재고_3개월금액
        float 장기재고_1개월주문금액
        float 장기재고_2개월주문금액
        float 장기재고_3개월주문금액
    }
</div><pre data-role="codeBlock" data-info="" class="language-text"><code>① 1차 정규화가 필요한 엔터티로서 일재고와 일재고상세로 1:M의 관계가 될 수 있다.
② 1차 정규화가 필요한 엔터티로서 일재고와 일재고상세로 1:1의 관계가 될 수 있다.
③ 2차 정규화가 필요한 엔터티로서 일재고와 일재고상세로 1:M의 관계가 될 수 있다.
④ 2차 정규화가 필요한 엔터티로서 일재고와 일재고상세로 1:1의 관계가 될 수 있다.
</code></pre><p><strong>정답:</strong> ①</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
①번은 “재고가 여러 달 걸쳐 반복돼!”<br>
그래서 상세로 나눠야 해!</p>
<p><strong>📚 전문 해설:</strong><br>
속성이 반복되고, 상세 정보로 분리 가능하므로<br>
1차 정규화가 필요하며, 일재고와 상세는 1:M 관계입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>반복 속성 → 행 분리 + 1:M 관계</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>1:1 관계 → 구조 불일치</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>2차 정규화 언급 → 과도</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>2차 정규화 + 1:1 관계 → 오류</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
1차 정규화 = <strong>반복 속성 → 행으로 분리</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
<li>🃏 카드 67: 2차 정규화 = 부분 종속 제거</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">39</span><span class="token punctuation">]</span>  
다음 중 아래와 같이 수강지도 엔터티를 만들었을 때 이에 해당하는 정규형과 정규화의 대상으로 가장 바르게 짝지어진 것은?

 
함수종속성<span class="token punctuation">(</span>FD<span class="token punctuation">)</span>  
<span class="token number">1</span>. 학번 <span class="token operator">||</span> 과목번호 → 성적  
<span class="token number">2</span>. 학번 → 지도교수명  
<span class="token number">3</span>. 학번 → 학과명
</code></pre><table>
<thead>
<tr>
<th>수강지도</th>
</tr>
</thead>
<tbody>
<tr>
<td>학번 <br> 과목코드</td>
</tr>
<tr>
<td>성적   <br> 지도교수명 <br>  학과명</td>
</tr>
</tbody>
</table>
<pre data-role="codeBlock" data-info="" class="language-text"><code>① 1차 정규형 - 2차 정규화 대상
② 2차 정규형 - 3차 정규화 대상
③ 3차 정규형 - 보이스코드 정규화대상
④ 보이스코드정규형 4차 정규화 대상
</code></pre><p><strong>정답:</strong> ①</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
①번은 “지금은 기본 정리만 돼 있고, 더 정리해야 해!”<br>
학번만으로 결정되는 정보는 따로 떼야 해!</p>
<p><strong>📚 전문 해설:</strong><br>
현재 구조는 1차 정규형은 만족하지만,<br>
부분 함수 종속(학번 → 지도교수명, 학과명)이 존재하므로<br>
2차 정규화를 수행해야 합니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>1차 정규형 상태, 2차 정규화 필요</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>2차 정규형 상태 아님</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>보이스코드 정규형은 아직 아님</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>4차 정규화는 너무 고차원</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
2차 정규화 = <strong>부분 함수 종속 제거</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 67: 2차 정규화 = 부분 종속 제거</li>
<li>🃏 카드 68: 정규화 판단 기준 = 함수 종속성 분석</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">40</span><span class="token punctuation">]</span>  
다음 중 데이터 모델에 대한 반정규화를 고려할 때 판단요소에 대한 설명으로 가장 적절한 것은?

① 반정규화 정보에 대한 재현의 적시성으로 판단한다. 예들 들어, 빌링의 잔액<span class="token punctuation">(</span>balance<span class="token punctuation">)</span>은 다수 테이블에 대한 다량의 조인이 불가피하므로 데이터 제공의 적시성 확보를 위한 필수 반정규화 대상 정보이다.  
② 탐색 대상 데이터의 크기로 판단한다. 왜냐하면 다량 데이터에 대한 인덱스를 활용한 탐색은 Random처리의 특성으로 성능 저하가 불가피하다.  
③ RDBMS는 현재 레코드 기준으로 이전 또는 이후 위치의 레코드에 대한 접근이 원천적으로 불가능하므로 반정규화를 하지 않으면 해당 정보에 대한 데이터 접근 자체가 불가능하다.  
④ 반정규화 테이블은 집계 테이블에 국한하여 적용하도록 한다.
</code></pre><p><strong>정답:</strong> ①</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
①번은 “빨리 보여줘야 할 정보는 미리 계산해서 저장해!”<br>
잔액 같은 건 바로 보여줘야 하니까!</p>
<p><strong>📚 전문 해설:</strong><br>
반정규화는 <strong>데이터 제공의 적시성</strong>을 확보하기 위한 전략이에요.<br>
특히 잔액처럼 여러 테이블을 조인해야 하는 경우,<br>
성능을 위해 미리 계산된 값을 저장하는 것이 효과적입니다.</p>
<p>※ 적시성 : 사용자가 필요로 하는 시점에 정확하고 신속하게 데이터를 제공할 수 있는 능력</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>적시성 확보 → 반정규화 판단 기준</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>탐색 크기만으로 판단은 부족</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>RDBMS 순차 접근 가능 → 설명 오류</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>집계 테이블에만 적용 → 제한적</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
반정규화 판단 기준 = <strong>성능 + 적시성</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
<li>🃏 카드 69: 반정규화 판단 기준 = 적시성 + 조인 복잡도</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">41</span><span class="token punctuation">]</span>  
다음 중 하나의 테이블의 전체 칼럼 중 자주 이용하는 집중화된 칼럼들이 있을 때  디스크 I/O를 줄이기 위해 해당 칼럼들을 별도로 모아놓는 반정규화 기법으로 가장 적절한 것은?

① 칼럼추가 - 부분갈림 추가  
② 칼럼추가 - 중복칼럼 추가  
③ 테이블추가 - 중복테이블추가  
④ 테이블추가 - 부분테이블추가
</code></pre><p><strong>정답:</strong> ④</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
④번은 “자주 쓰는 정보만 따로 모아놓자!”<br>
그래야 빨리 찾고 덜 느려져!</p>
<p><strong>📚 전문 해설:</strong><br>
자주 사용하는 칼럼만 따로 모아서 별도 테이블로 분리하면<br>
디스크 접근량이 줄어들고 성능이 향상돼요.<br>
이런 방식이 바로 <strong>부분테이블추가</strong> 기법입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>칼럼 분기: 구조 복잡</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>중복 칼럼: 관리 어려움</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>중복 테이블: 데이터 중복</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>부분 테이블: 성능 향상</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧸 <strong>쉬운 해설:</strong><br>
④번은 “자주 쓰는 정보만 따로 모아놓자!”<br>
그래야 빨리 찾고 덜 느려져!</p>
<p>🧠 <strong>기억법:</strong><br>
부분테이블추가 = <strong>핵심 칼럼만 따로 빼서 빠르게 접근</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
<li>🃏 카드 70: 부분테이블추가 = 자주 쓰는 칼럼 분리</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">42</span><span class="token punctuation">]</span>  
다음 중 칼럼에 대한 반정규화 기법으로 가장 부적절한 것은?

① 중복칼럼을 추가 - 조인감소를 위해 여러 테이블에 동일한 칼럼을 갖도록 한다.  
② 파생칼럼을 추가한다 - 조회 성능을 우수하게 하기 위해 미리 계산된 칼럼을 갖도록 한다.  
③ FK에 대한 속성을 추가한다 - FK관계에 해당하는 속성을 추가하여 조인성능을 높인다.  
④ 이력테이블에 기능 칼럼을 추가한다 - 최신값을 처리하는 이력의 특성을 고려하여 기능성 칼럼을 추가한다.
</code></pre><p><strong>정답:</strong> ③</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
③번은 “외래키 속성을 그냥 더 넣자!”는 말인데,<br>
그건 반정규화가 아니라 관계 유지야!</p>
<p><strong>📚 전문 해설:</strong><br>
FK 속성을 추가하는 것은 반정규화가 아니라 <strong>정규화된 관계를 유지하는 방식</strong>이에요.<br>
반정규화는 성능 향상을 위해 <strong>중복, 계산값, 기능성 칼럼</strong> 등을 추가하는 방식입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>중복칼럼 추가: 반정규화 맞음</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>파생칼럼 추가: 반정규화 맞음</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>FK 속성 추가: 정규화 유지 목적</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>기능 칼럼 추가: 반정규화 맞음</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
반정규화 = <strong>중복, 계산, 기능 칼럼 추가</strong><br>
❌ FK 속성 추가는 관계 유지 목적!</p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
<li>🃏 카드 71: 반정규화 칼럼 유형 = 중복, 파생, 기능</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">43</span><span class="token punctuation">]</span>  
다음 중 아래의 주문, 주문목록, 제품에 대한 데이터모델과 이를 이용하여 데이터를 조회하는 SQL문에서 조회를 빠르게 수행하기 위한 반정규화 방법으로 가장 적절한 것은?
</code></pre><div class="mermaid">erDiagram
    주문 ||--o{ 주문목록 : 포함한다
    제품 ||--o{ 주문목록 : 포함된다

    주문 {
        string 주문번호
    }

    주문목록 {
        string 주문번호 FK
        string 제품번호 FK
    }

    제품 {
        string 제품번호
        int 단가
    }

</div><pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> A<span class="token punctuation">.</span>주문번호<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span>단가<span class="token punctuation">)</span>
<span class="token keyword keyword-FROM">FROM</span> 주문 A<span class="token punctuation">,</span> 주문목록 B<span class="token punctuation">,</span> 제품 C
<span class="token keyword keyword-WHERE">WHERE</span> A<span class="token punctuation">.</span>주문번호 <span class="token operator">=</span> '<span class="token number">2015</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">001</span>
<span class="token operator">AND</span> A<span class="token punctuation">.</span>주문번호 <span class="token operator">=</span> B<span class="token punctuation">.</span>주문번호
<span class="token operator">AND</span> B<span class="token punctuation">.</span>제품번호 <span class="token operator">=</span> C<span class="token punctuation">.</span>제품번호
<span class="token keyword keyword-GROUP">GROUP</span> <span class="token keyword keyword-BY">BY</span> A<span class="token punctuation">.</span>주문번호
</code></pre><pre data-role="codeBlock" data-info="" class="language-text"><code>① 제품 엔터티에 단가를 합한 계산된 칼럼을 추가하도록 한다.
② 주문목록 엔터티에 단가를 합한 계산된 칼럼을 추가하도록 한다.
③ 주문 엔터티에 단가를 합한 계산된 칼럼을 추가하도록 한다.
④ 제품 엔터티에 최근값 여부에 대한 칼럼을 추가하도록 한다.
</code></pre><p><strong>정답:</strong> ③</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
③번은 “주문할 때마다 총액을 미리 계산해서 넣자!”<br>
그래야 조회가 빠르지!</p>
<p><strong>📚 전문 해설:</strong><br>
단가의 합계는 주문 단위로 자주 조회되므로,<br>
주문 엔터티에 <strong>계산된 합계 칼럼</strong>을 추가하면 성능이 향상됩니다.</p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>제품에 합계 추가 → 제품은 단가만 가짐</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>주문목록에 합계 추가 → 주문 단위 아님</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>주문에 합계 추가 → 정답</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>최근값 여부 → 성능과 무관</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
반정규화 = <strong>자주 쓰는 계산값 미리 저장</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
<li>🃏 카드 71: 파생 칼럼 = 미리 계산된 값 저장</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">44</span><span class="token punctuation">]</span>  
다음 중 아래 데이터모델에 대한 설명으로 가장 부적절한 것은?
</code></pre><div class="mermaid">erDiagram
    공급자 ||--o{ 전화번호 : "가진다"
    공급자 ||--o{ 메일주소 : "가진다"
    공급자 ||--o{ 위치 : "가진다"

    공급자 {
        string 공급자번호
        string 공급자명
        string 공급자EAN
        string 공급자ASN
    }

    전화번호 {
        string 공급자번호(FK) PK
        INT    순번          PK
        string 전화번호
    }

    메일주소 {
        string 공급자번호(FK) PK
        INT    순번          PK
        string 메일주소
    }

    위치 {
        string 공급자번호(FK) PK
        INT    순번          PK
        string 위치
    }

</div><blockquote>
<ul>
<li>공급자의 데이터는 1000만건 이상의 대량 데이터를 가진 테이블임</li>
<li>전화번호, 메일주소, 위치는 자주 변경이 될 수 있으며 데이터 조회를 할 때는 항상 최근에 변경된 값을 조회하게 됨</li>
</ul>
</blockquote>
<pre data-role="codeBlock" data-info="" class="language-text"><code>① 공급자별로 최근에 변경된 전화번호, 메일주소, 위치와 공급자 이름을
같이 조회할 때 이 값들을 공급자 테이블에 반정규화로 갖고 있는 경우
에 비해 조회 성능이 저하되지 않는다.
② 데이터를 조회할 때 과도한 조인으로 인해 조회성능이 저하될 수 있으
므로 공급자 테이블에 가장 빈번하게 조회되는 값인 최근 변경값에
해당하는 전화번호, 메일주소, 위치를 반정규화하여 조회 성능을 향상
시킬 수 있다.
③ 전화번호, 메일주소, 위치에 대한 가장 최근에 변경된 값을 알 수 있도
록 최신여부 라는 속성을 추가함으로써 최근 값을 찾기 위한 조회 성능
저하를 예방할 수 있다.
④ 조회 성능을 위해서는 하나의 테이블로 통합하여 전화번호, 메일주소,
위치 등이 변경될 경우 전체 속성이 계속 발생되는 이력의 형태로 설계
될 수 있다. 이럴 경우 조회에 대한 성능은 향상이 되나, 과도한 데이터
가 한 테이블에 발생하게 되어 용량이 너무 커지는 단점이 있다.
</code></pre><p><strong>정답:</strong> ①</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
①번은 “조인 없이도 성능 괜찮아!”라고 말하는데,<br>
실제로는 조인 때문에 느려질 수 있어!</p>
<p><strong>📚 전문 해설:</strong><br>
조회 시마다 조인이 발생하면 성능이 저하됩니다.<br>
최근 변경값을 자주 조회한다면 공급자 테이블에 반정규화하는 것이 효과적입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>반정규화 없어도 성능 저하 없음 → ❌</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>최근값 반정규화 → 성능 향상</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>최신여부 속성 추가 → 조회 효율화</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>통합 테이블 → 장단점 설명 정확</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
자주 조회되는 값 = <strong>반정규화 대상</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
<li>🃏 카드 71: 반정규화 칼럼 유형 = 중복, 파생, 기능</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">45</span><span class="token punctuation">]</span>  
다음 중 칼럼수가 많은 테이블에 대한 설명으로 가장 적절한 것은?

①한 테이블에 많은 칼럼을 가지고 있으면 조인이 발생되지 않아 여러
개 테이블일 때에 비해 성능이 항상 우수하다고 할 수 있다.
② 로우체이닝이 발생할 정도로 한 테이블에 많은 칼럼들이 존재할 경우
조회성능저하가 발생할 수 있다. 한 테이블내에서 칼럼의 위치를 조정
하면 디스크 <span class="token number">1</span>/0가 줄어들어 조회 성능을 향상 시킬 수 있다.
③로우채이닝이 발생할 정도로 한 테이블에 많은 칼럼들이 존재할 경우
조회성능저하가 발생할 수 있다. 트랜잭션이 접근하는 칼럼유형을 분
석하여 <span class="token number">1</span>:1로 테이블을 분리하면 디스크 <span class="token number">1</span>/0가 줄어들어 조회 성능을
향상 시킬 수 있다.
④ 로우체이닝이 발생할 정도로 한 테이블에 많은 칼럼들이 존재할 경우
조회성능저하가 발생할 수 있다. 그러나 이를 분리할 경우 조인으로
인한 성능 저하가 더 심하게 나타날 수 있으므로 감수하는 것이 좋다.

</code></pre><p><strong>정답:</strong> ③</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
③번은 “자주 쓰는 칼럼만 따로 떼자!”<br>
그래야 디스크 접근이 줄어들어 빨라져!</p>
<p><strong>📚 전문 해설:</strong><br>
칼럼이 많으면 로우체이닝이 발생해 성능이 저하될 수 있어요.<br>
트랜잭션이 접근하는 칼럼 유형에 따라 <strong>1:1 테이블 분리</strong>가 성능 개선에 효과적입니다.</p>
<blockquote>
<p>로우체이닝(Row Chaining)은 데이터베이스에서 하나의 행(row)이 여러 블록에 나뉘어 저장되는 현상을 말해요. 이 현상은 특히 칼럼이 많거나, 자주 업데이트되는 테이블에서 발생</p>
</blockquote>
<blockquote>
<p>해결 방법: 칼럼 유형별 테이블 분리<br>
자주 접근하는 칼럼과 그렇지 않은 칼럼을 1:1 관계로 분리</p>
</blockquote>
<p>예: 사용자 테이블에서 로그인 정보는 자주 쓰지만 프로필 사진은 드물게 쓰임 → 따로 분리!</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>칼럼 많아도 성능 우수 → 과도한 일반화</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>칼럼 위치 조정 → 일부 효과</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>칼럼 유형별 분리 → 성능 개선</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>분리하면 더 느려짐 → 근거 부족</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
칼럼 많을 땐 → <strong>접근 패턴 따라 분리</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
<li>🃏 카드 72: 로우체이닝 = 칼럼 과다로 인한 성능 저하</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">46</span><span class="token punctuation">]</span>  
아래 설명에서 데이터 액세스 성능을 향상시키기 위해 적용하는 방법에 대해서 <span class="token punctuation">[</span>빈칸<span class="token punctuation">]</span> 채우시오.


<span class="token operator">&gt;</span>하나의 데이블에 많은 양의 데이터가 저장되면 인덱스를 추가하고
테이블을 몇 개로 쪼개도 성능이 저하되는 경우가 있다. 이때 논리적
으로는 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리
하여 데이터 액세스 성능도 향상시키고, 데이터 관리방법도 개선할
수 있도록 테이블에 적용하는 기법을 <span class="token punctuation">[</span>  빈칸  <span class="token punctuation">]</span>이라고 한다.
</code></pre><p><strong>정답:</strong> 파티셔닝</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
“너무 큰 테이블은 나눠서 관리하자!”<br>
그게 바로 파티셔닝이야!</p>
<p><strong>📚 전문 해설:</strong><br>
파티셔닝은 하나의 테이블을 <strong>물리적으로 여러 개로 나누는 기법</strong>이에요.<br>
대량 데이터의 성능 향상과 관리 효율을 위해 사용됩니다.</p>
<p>🧠 <strong>기억법:</strong><br>
파티셔닝 = <strong>물리적 분할로 성능 향상</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 73: 파티셔닝 = 대용량 테이블 분할</li>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">47</span><span class="token punctuation">]</span>  
다음 중 아래 데이터 모델과 SQL문에 대해 개선해야 할 사항에 대한 설명으로 가장 적절한 것은?
</code></pre><div class="mermaid">erDiagram
    긴급사건 {
        int 긴급사건번호 PK
        string 사건명
        date 발생일시
    }

    특수사건 {
        int 특수사건번호  PK
        string 사건명
        date 발생일시
    }

    일반사건 {
        int 일반사건번호  PK
        string 사건명
        date 발생일시
    }

</div><pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> 긴급사건번호<span class="token punctuation">,</span> 사건명 <span class="token keyword keyword-FROM">FROM</span> 긴급사건 <span class="token keyword keyword-WHERE">WHERE</span> 발생일시 <span class="token operator">=</span> <span class="token string">'20150905'</span>
<span class="token keyword keyword-UNION">UNION</span> <span class="token keyword keyword-ALL">ALL</span>
<span class="token keyword keyword-SELECT">SELECT</span> 특수사건번호<span class="token punctuation">,</span> 사건명 <span class="token keyword keyword-FROM">FROM</span> 특수사건 <span class="token keyword keyword-WHERE">WHERE</span> 발생일시 <span class="token operator">=</span> <span class="token string">'20150905'</span>
UNIONALL
<span class="token keyword keyword-SELECT">SELECT</span> 일반사건번호<span class="token punctuation">,</span> 사건명 <span class="token keyword keyword-FROM">FROM</span> 일반사건 <span class="token keyword keyword-WHERE">WHERE</span> 발생일시 <span class="token operator">=</span> '<span class="token number">20150905</span>

※ 전제조건 : 위 세 테이블은 함께 조회하는 경우가 대부분이고 아직 시스템을
오픈하지 않았다<span class="token punctuation">.</span>
</code></pre><pre data-role="codeBlock" data-info="" class="language-text"><code>① UNION ALL로 조회하면 정렬로 인한 성능이 저하되므로 UNION으로 조합하여 조회한다.
② 긴급사건, 특수사건, 일반사건을 하나의 테이블로 통합하고 PK를 사건 분류코드 + 사건번호로 조합하여 구성하도록 한다.
③ 긴급사건, 특수사건, 일반사건 테이블을 개별로 유지하되 PK에 사건 분류코드를 포함하도록 한다.
④ 세 개의 테이블을 그대로 유지하되 반정규화된 형태의 통합테이블을 하나 더 생성하여 조회의 성능을 향상하도록 한다.
</code></pre><p><strong>정답:</strong> ②</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
②번은 “자주 같이 쓰니까 하나로 합치자!”<br>
그리고 구분코드로 구분하면 돼!</p>
<p><strong>📚 전문 해설:</strong><br>
세 테이블을 자주 함께 조회하므로 하나의 테이블로 통합하고<br>
<strong>사건 분류코드 + 사건번호</strong>로 PK를 구성하는 것이 효율적입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>UNION → 정렬 오버헤드</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>통합 + 복합 PK → 효율적</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>개별 유지 + 분류코드 → 중복 유지</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>통합테이블 추가 → 관리 복잡</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
자주 함께 조회 = <strong>통합 + 구분코드</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
<li>🃏 카드 74: 통합 테이블 설계 = 분류코드 활용</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">48</span><span class="token punctuation">]</span>  
다음 중 논리데이터모델의 슈퍼타입과 서브타입 데이터모델을 물리적인 테이블 형식으로 변환할 때 설명으로 가장 부적절한 것은?

① 트랜잭션은 항상 전체를 대상으로 일괄 처리하는데 테이블은 서브타입 별로 개별 유지하는 것으로 변환하면 Union 연산에 의해 성능이 저하 될 수 있다.
② 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합하여 변환하면 불필요하게 많은 양의 데이터가 집적되어 있어 성능이 저하될 수 있다.
③ 트랜잭션은 항상 슈퍼+서브 타입을 함께 처리하는데 개별로 유지 하면 조인에 의해 성능이 저하될 수 있다.
④ 트랜잭션은 항상 전체를 통합하여 분석 처리하는데 하나로 통합되어 있으면 데이터 집적으로 인해 성능이 저하될 수 있다.
</code></pre><p><strong>정답:</strong> ④</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
④번은 “하나로 합치면 무조건 좋아!”라고 말하는데,<br>
너무 많으면 오히려 느려져!</p>
<p><strong>📚 전문 해설:</strong><br>
통합 테이블은 데이터 집적이 심해져서 성능 저하가 발생할 수 있어요.<br>
④번은 통합이 항상 좋다고 했기 때문에 부적절합니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>서브타입 분리 → UNION 성능 저하</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>통합 시 과도한 집적 → 맞음</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>개별 유지 시 조인 성능 저하 → 맞음</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>통합이 항상 좋다 → 과도한 일반화</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
통합 = 관리 편함<br>
하지만 <strong>성능은 상황 따라 다름</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 66: 반정규화 = 성능 개선 전략</li>
<li>🃏 카드 74: 슈퍼/서브타입 설계 = 처리 패턴에 따라 결정</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">49</span><span class="token punctuation">]</span>  
다음 중 아래와 같은 <span class="token string">'현금출급기실적'</span> 테이블과 이 테이블에서 데이터를 조회할 때 사용되는 아래의 SQL패턴에 대한 설명으로 가장 적절한 것은?
</code></pre><div class="mermaid">erDiagram
    현금출급기실적 {
        date 거래일자       PK
        string 사무소코드   PK
        string 출급기번호   PK
        string 명세표번호
        int 건수
        int 금액
    }
</div><pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> 건수<span class="token punctuation">,</span> 금액
<span class="token keyword keyword-FROM">FROM</span> 현금출급기실적
<span class="token keyword keyword-WHERE">WHERE</span> 거래일자 <span class="token operator">BETWEEN</span>  <span class="token string">'20140701'</span> <span class="token operator">AND</span> <span class="token string">'20140702'</span>
<span class="token operator">AND</span> 사무소코드<span class="token operator">=</span> <span class="token string">'000368'</span>
<span class="token punctuation">(</span>단<span class="token punctuation">,</span> PK인덱스는 설계된 순서 그대로 생성함<span class="token punctuation">)</span> 
</code></pre><pre data-role="codeBlock" data-info="" class="language-text"><code>① 사무소코드가 '='로 상수값이 들어 왔고, 거래일자가 범위 'BETWEEN'으로 들어왔기 때문에 거래일자+사무소코드+출급기번호+명세표번호로 구성된 PK인덱스는 최적의 효율성을 가지고 있음.  
② 사무소코드가 '='로 상수값이 들어 왔고, 거래일자가 범위 'BETWEEN'으로 들어왔기 때문에 PK의 순서를 사무소코드+출급기번호+명세표번호+거래일자로 바꾸고 인덱스를 생성하는 것이 성능에 유리함.  
③ 사무소코드가 '='로 상수값이 들어 왔고, 거래일자가 범위 'BETWEEN'으로 들어왔기 때문에 PK의 순서를 거래일자+출급기번호+명세표번호+사무소코드로 바꾸고 인덱스를 생성하는 것이 성능에 유리함.  
④ 사무소코드가 '='로 상수값이 들어 왔고, 거래일자가 범위 'BETWEEN'으로 들어왔기 때문에 PK의 순서를 사무소코드+거래일자+출급기번호+명세표번호로 바꾸고 인덱스를 생성하는 것이 성능에 유리함.
</code></pre><p><strong>정답:</strong> ④</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
④번은 “먼저 정확히 찾고, 그다음 범위로 좁히자!”<br>
정확한 조건이 앞에 있어야 빨라!</p>
<p><strong>📚 전문 해설:</strong><br>
인덱스는 WHERE절 조건의 사용 순서와 일치해야 성능이 좋습니다.<br>
사무소코드가 '=' 조건이고 거래일자가 범위 조건이므로,<br>
사무소코드가 먼저 오고 거래일자가 뒤에 오는 인덱스 순서가 가장 효율적입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>거래일자 먼저 → 범위 조건 먼저는 비효율</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>거래일자 맨 뒤 → 조건 순서 불일치</td>
<td>❌</td>
</tr>
<tr>
<td>③</td>
<td>사무소코드 맨 뒤 → 비효율</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>사무소코드 + 거래일자 순서 → 정확</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
인덱스 순서 = <strong>EQUAL 조건 먼저, 범위 조건 뒤</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 75: 인덱스 설계 = 조건 순서와 일치</li>
<li>🃏 카드 76: WHERE절 조건 = 인덱스 효율 결정</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">50</span><span class="token punctuation">]</span>  
다음 중 아래의 엔터티와 이 엔터티를 매우 빈번하게 참조하는 SQL의 성능에 대한 설명으로 가장 적절한 것은?
</code></pre><div class="mermaid">erDiagram
    실적 {
        date 일자   PK
        string 지사코드 PK
        string 명세번호  PK
        int 금액
        int 액수
    }
</div><pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> 건수<span class="token punctuation">,</span> 금액
<span class="token keyword keyword-FROM">FROM</span> 실적
<span class="token keyword keyword-WHERE">WHERE</span> 일자 <span class="token operator">BETWEEN</span> <span class="token string">'20110101'</span> <span class="token operator">AND</span> <span class="token string">'20110102'</span>
<span class="token operator">AND</span> 지사코드 <span class="token operator">=</span><span class="token string">'1001'</span>

<span class="token punctuation">(</span>단<span class="token punctuation">,</span> PK 인덱스가 존재하며 칼럼순서대로 인덱스가 생성되어 있고<span class="token punctuation">,</span> 이 <span class="token keyword keyword-SQL">SQL</span>이 트랜잭션의 대부분을 차지한다고 가정함<span class="token punctuation">)</span>
</code></pre><pre data-role="codeBlock" data-info="" class="language-text"><code>① 명세번호를 실적 테이블에 맨 처음 칼럼으로 옮기면 PK 인덱스의 이용 효율성이 향상된다.  
② 지사코드에 대해 입력 값이 EQUAL 조건으로 사용되므로 지사코드를 실적 테이블의 맨 처음 위치로 옮겨서 일자 칼럼의 앞에 두면 인덱스 이용 효율성이 높아진다.  
③ 일자가 SQL 문장의 WHERE절에 첫 번째 조건으로 나왔으므로 칼럼 순서에서도 첫 번째에 위치하는 것이 효율성이 높다.  
④ 일자, 명세번호, 지사코드로 칼럼 순서를 바꾸어야 일자 범위에 대한 내용을 먼저 식별하고, 그 다음으로 지사코드를 찾기에 용이할 수 있으므로 이때 인덱스의 효율성이 가장 높다.
</code></pre><p><strong>정답:</strong> ②</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
②번은 “정확히 찾는 조건을 먼저 써야 빨라!”<br>
지사코드가 '='니까 앞에 두자!</p>
<p><strong>📚 전문 해설:</strong><br>
지사코드가 '=' 조건으로 자주 사용되므로,<br>
인덱스 순서에서 지사코드를 앞에 배치하면 성능이 향상됩니다.<br>
범위 조건인 일자는 뒤로 배치하는 것이 효율적입니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>명세번호 먼저 → ❌</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>지사코드 먼저 → ✅</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>범위 조건 먼저 → 비효율</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>일자 먼저, 명세번호 중간 → ❌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
인덱스 순서 = <strong>정확 조건(EQUAL) 먼저, 범위(BETWEEN) 뒤</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 75: 인덱스 설계 = 조건 순서와 일치</li>
<li>🃏 카드 76: WHERE절 조건 = 인덱스 효율 결정</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">51</span><span class="token punctuation">]</span>  
다음 중 아래 데이터모델에 표현된 FK<span class="token punctuation">(</span>Foreign Key<span class="token punctuation">)</span>에 대한 설명으로 가장 적절한 것을 <span class="token number">2</span>개 고르시오.
</code></pre><div class="mermaid">erDiagram
    학사기준 ||--o{ 수강신청 : "기준으로 등록된다"

    학사기준 {
        int 학사기준번호  PK
        int 년도
        int 학기
        string 특이사항
    }

    수강신청 {
        string 강의번호  PK
        string 학번     PK
        int 학사기준번호 FK
        string 성명
        string 연락처1
        string 연락처2
        int 등록년도
        string 감면코드
    }

</div><pre data-role="codeBlock" data-info="" class="language-text"><code>단, 학사기준과 수강신청은 조인하여 정보를 조회할 업무가 많음

① 학사기준번호는 부모 테이블에 이미 인덱스가 존재하기 때문에 상속받아 생긴 수강신청에는 학사기준번호 칼럼에 대한 별도의 인덱스가 필요하지 않다.  
② 학사기준번호는 부모 테이블에 이미 인덱스가 존재하나 수강신청과 조인에 의한 성능저하 예방을 위해 상속받아 생긴 수강신청에도 학사기준번호 칼럼에 대한 별도의 인덱스가 필요하다.  
③ 데이터모델에서는 관계를 연결하고 데이터베이스에 FK 제약조건 생성을 생략하는 경우에 학사기준번호에 대한 인덱스를 생성할 필요가 없다.  
④ 데이터모델에서는 관계를 연결하고 데이터베이스에 FK 제약조건 생성을 생략하는 경우에도 데이터의 조인관계가 필요하므로 학사기준번호에 대한 인덱스를 생성할 필요가 있다.
</code></pre><p><strong>정답:</strong> ②, ④</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
②,④번은 “조인할 거면 인덱스는 꼭 있어야 해!”<br>
제약조건 없어도 성능엔 인덱스가 중요해!</p>
<p><strong>📚 전문 해설:</strong><br>
조인 성능을 위해 FK 칼럼에도 인덱스를 생성하는 것이 좋습니다.<br>
제약조건을 생략하더라도 조인 성능을 위해 인덱스는 필요합니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>부모 인덱스만 있으면 된다 → ❌</td>
<td>❌</td>
</tr>
<tr>
<td>②</td>
<td>자식 테이블에도 인덱스 필요 → ✅</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>제약조건 없으면 인덱스 불필요 → ❌</td>
<td>❌</td>
</tr>
<tr>
<td>④</td>
<td>제약조건 없어도 인덱스 필요 → ✅</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong><br>
FK 인덱스 = <strong>조인 성능 확보용 필수 요소</strong></p>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 62: FOREIGN KEY = 연결 다리</li>
<li>🃏 카드 76: WHERE절 조건 = 인덱스 효율 결정</li>
</ul>
<hr>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token punctuation">[</span>문제 <span class="token number">52</span><span class="token punctuation">]</span>  
다음 중 데이터가 여러 지역에 분산되어 있지만 하나의 데이터베이스처럼 사용하기를 원하는 분산데이터베이스 환경에서 데이터베이스 분산 설계를 적용하여 효율성을 증대시킬 수 없는 것은?


① 공통코드, 기준정보 등 마스터 데이터는 분산데이터베이스에 복제분산을 적용한다.  
② 거의 실시간<span class="token punctuation">(</span>Near Real Time<span class="token punctuation">)</span> 업무적인 특성을 가지고 있을 때 분산 데이터베이스를 사용하여 구성할 수 있다.  
③ 백업 사이트를 구성할 때 간단하게 분산기능을 적용하여 구성할 수 있다.  
④ Global Single Instance<span class="token punctuation">(</span>GSI<span class="token punctuation">)</span>를 구성할 때 분산데이터베이스를 활용하여 구성하는 것이 효율적이다.
</code></pre><p><strong>정답:</strong> ④</p>
<p>🧸 <strong>쉬운 해설:</strong><br>
④번은 “하나로 운영하는 시스템에 분산을 쓰자!”는 말인데,<br>
그건 구조가 안 맞아! GSI는 하나의 인스턴스로 통합 운영하는 방식이야.</p>
<p><strong>📚 전문 해설:</strong><br>
Global Single Instance(GSI)는 <strong>단일 인스턴스</strong>로 운영되는 구조이기 때문에<br>
분산데이터베이스처럼 여러 지역에 데이터를 나눠서 운영하는 방식과는 <strong>개념적으로 충돌</strong>합니다.<br>
GSI는 통합성과 일관성을 중시하는 구조로, 분산DB의 분리성과 지역 최적화와는 방향이 다릅니다.</p>
<p><strong>보기 설명:</strong></p>
<table>
<thead>
<tr>
<th>보기 번호</th>
<th>설명</th>
<th>적절성</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>마스터 데이터 복제 → 분산 설계 가능</td>
<td>✅</td>
</tr>
<tr>
<td>②</td>
<td>실시간 업무 → 분산DB 구성 가능</td>
<td>✅</td>
</tr>
<tr>
<td>③</td>
<td>백업 사이트 구성 → 분산 기능 활용 가능</td>
<td>✅</td>
</tr>
<tr>
<td>④</td>
<td>GSI에 분산DB 적용 → 구조적 충돌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>🧠 <strong>기억법:</strong></p>
<ul>
<li>GSI = Global Single Instance = 단일 인스턴스</li>
<li>분산DB = 여러 지역에 나눠서 운영</li>
<li>❌ GSI에 분산DB 적용은 구조적으로 부적절</li>
</ul>
<p><strong>필요 암기카드:</strong></p>
<ul>
<li>🃏 카드 79: 분산 설계 방식 = 복제, 분할, 집계</li>
<li>🃏 카드 80: GSI = 단일 인스턴스, 통합 운영</li>
<li>🃏 카드 77: 수평 분할 = 지역/행 단위 분리</li>
</ul>

      </div>
      
      
    
    
    <script type="module">
// TODO: If ZenUML gets integrated into mermaid in the future,
//      we can remove the following lines.


var MERMAID_CONFIG = ({"startOnLoad":false});
if (typeof MERMAID_CONFIG !== 'undefined') {
  MERMAID_CONFIG.startOnLoad = false
  MERMAID_CONFIG.cloneCssStyles = false
  MERMAID_CONFIG.theme = "default"
}

mermaid.initialize(MERMAID_CONFIG || {})
if (typeof(window['Reveal']) !== 'undefined') {
  function mermaidRevealHelper(event) {
    var currentSlide = event.currentSlide
    var diagrams = currentSlide.querySelectorAll('.mermaid')
    for (var i = 0; i < diagrams.length; i++) {
      var diagram = diagrams[i]
      if (!diagram.hasAttribute('data-processed')) {
        mermaid.init(null, diagram, ()=> {
          Reveal.slide(event.indexh, event.indexv)
        })
      }
    }
  }
  Reveal.addEventListener('slidetransitionend', mermaidRevealHelper)
  Reveal.addEventListener('ready', mermaidRevealHelper)
  await mermaid.run({
    nodes: document.querySelectorAll('.mermaid')
  })
} else {
  await mermaid.run({
    nodes: document.querySelectorAll('.mermaid')
  })
}
</script>
    
    
    
  
    </body></html>