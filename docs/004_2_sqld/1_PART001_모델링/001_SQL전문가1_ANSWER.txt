### 답안
과목 I. 데이터 모델링의 이해
1. 2 
해설: 모델링은 단지 시스템 구현을 위해 수행하는 타스크가 아니며, 시스템 구현을 포함한 업무분석 및 업무형상화를 하는 목적도 있음.

2. 3
해설: 데이터 모델링을 하는 주요한 이유는 업무정보를 구성하는 기초가 되는 정보들에 대해 일정한 표기법에 의해 표현함으로써 정보시스템 구축의 대상이 되는 업무 내용을 정확하게 분석하는 것이 첫 번째 목적이다. 두 번째는 분석된 모델을 가지고 실제 데이터베이스를 생성하여 개발 및 데이터관리에 사용하기 위한 것이 두 번째 목적이다. 다시 말하면, 데이터모델링이라는 것은 단지 데이터베이스만을 구축하기 위한 용도로 쓰이는 것이 아니라 데이터모델링 자체로서 업무를 설명하고 분석하는 부분에 서도 매우 중요한 의미를 가지고 있다고 할 수 있다.

3. 3
해설: 데이터모델링을 할 때 유의할 사항은 중복성, 비유연성, 비일관성 등이다.

유의사항1: 중복(Duplication)
데이터 모델은 같은 데이터를 사용하는 사람, 시간, 그리고 장소를 파악하는데 도움을 줌으로써 데이터베이스가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록 한다. 

유의사항2: 비유연성(Inflexibility)
데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경됨으로써 유지보수의 어려움을 가중시킬 수 있다. 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리 케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다.

유의사항3: 비일관성(Inconsistency)
데이터의 중복이 없더라도 비일관성은 발생할 수 있는데, 예를 들면 신용 상태에 대한 갱신 없이 고객의 납부 이력 정보를 갱신하는 경우이다. 개발자가 서로 연관된 다른 데이터와 모순된다는 고려 없이 일련의 데이터를 수정할 수 있기 때문에 이와 같은 문제 가 발생할 수 있다. 데이터 모델링을 할 때 데이터와 데이터 간의 상호 연관 관계에 대해 명확하게 정의한다면 이러한 위험을 사전에 예방하는데 도움을 줄 수 있다. 사용자가 처리하는 프로세스 혹은 이와 관련된 프로그램과 테이블의 연계성을 높이는 것은 데이터 모델이 업무 변경에 대해 취약하게 만드는 단점에 해당한다. 


4. 2
해설: 데이터 모델링 시의 유의점에 대한 사항 중 비유연성(Inflexibility)에 대한 설명이다.
데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경됨으로써 유지보수의 어려움을 가중시킬 수 있다. 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화 를 일으킬 수 있는 가능성을 줄인다.


5. 1
해설: 전사적 데이터 모델링이나 EA 수립 시에 많이 하며, 추상화 수준이 높고 업무 중심적이면서 포괄적인 수준의 모델링을 진행하는 것을 개념적 데이터 모델링 이라고 하며, 실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등의 물리적인 성격을 고려한 데이터 모델링 방식은 물리적 데이터 모델링이라고 한다.


6. 2
해설: 데이터베이스 스키마 구조는 3단계로 구분되고 각각은 상호 독립적인 의미를 가지고 고유한 기능을 가진다. 그 중 통합관점의 스키마구조를 표현한 것을 개념스키마(Conceptual Schema)라고 하며, 데이터 모델링은 통합관점의 뷰를 가지고 있는 개념 스키마를 만들어가는 과정으로 이해할 수 있다.


7. 4
해설: 부모 엔터티에 데이터가 입력될 때 자식 엔터티에 해당 값이 존재하는지의 여부와 상관없이 입력될 수 있는 구조로 표현되어 있기 때문에, 고객 엔터티에 새로운 고객번호 데이터를 입력하는 것은 주문 엔터티에 해당 고객번호가 존재하고 있는지의 여부와 상관없이 가능하다.


8. 4
해설: 엔터티를 어디에 배치하는가에 대한 문제는 필수사항은 아니지만 데이터 모델링 툴 사용 여부와 상관없이 데이터 모델의 가독성 측면에서 중요한 문제이다. 일반적으로 사람의 눈은 왼쪽에서 오른쪽, 위쪽에서 아래쪽으로 이동하는 경향이 있기 때문에, 데이터 모델링에서도 가장 중요한 엔터티를 왼쪽 상단에 배치하고, 이것을 중심으로 다른 엔터티를 나열하면서 전개하면 사람의 눈이 따라가기에 편리한 데이터 모델을 작성할 수 있다. 해당 업무에서 가장 중요한 엔터티는 왼쪽 상단에서 조금 아래쪽 중앙에 배치하여 전체 엔터티와 어울릴 수 있도록 하면 향후 관련 엔터티와 관계선을 연결할 때 선이 꼬이지 않고 효과적으로 배치할 수 있게 된다.


9.2
해설: 병원은 S병원1개이므로 엔터티로 성립되지 않으며, 이름, 주소는 엔터티의 속성으로 인식될 수 있다. 엔터티는 2개 이상의 속성과 2개 이상의 인스턴스를 가져 소위 면적으로 표현될 수 있어야 비로소 기본적인 엔터티의 자격을 갖췄다 할 수 있으므로 '여러 명'의 복수 인스턴스와 이름, 주소 등의 복수 속성을 가진 '환자'가 엔터티로 가장 적절하다고 할 수 있다. 


10. 3
해설: 엔터티의 특징은 다음과 같다.
☞ 첫 번째, 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다.
(예, 환자, 토익의 응시횟수...)
☞ 두 번째, 유일한 식별자에 의해 식별이 가능해야 한다.
세 번째, 영속적으로 존재하는 (두 개 이상의) 인스턴스의 집합이어야 한다. ("한 개"가 아니라 "두 개 이상")
네 번째, 엔터티는 업무 프로세스에 의해 이용되어야 한다.
다섯 번째, 엔터티는 반드시 속성이 있어야 한다.
☞ 여섯 번째, 엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다.


11. 1
해설: 엔터티의 중요한 특징의 하나는 다른 엔터티와 관계를 가져야 한다는 것이다. 그러나 공통코드, 통계성 엔터티의 경우는 관계를 생략할 수 있다.


12.  1
해설: 기본엔터티(키엔터티)란 그 업무에 원래 존재하는 정보로서 다른 엔터티와의 관계에 의해 생성되지 않고 독립적으로 생성이 가능하고 자신은 타 엔터티의 부모의 역할을 하게 된다. 
   다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지게 된다. 예를 들어 사원, 부서, 고객, 상품, 자재 등이 기본엔티티가 될 수 있다.


13. 1
해설: 엔터티를 명명하는 일반적인 기준은 다음과 같다. 용어를 사용하는 모든 표기법이 다 그렇듯이 첫 번째는 가능하면 현업업무에서 사용하는 용어를 사용한다. 
두 번째는 가능하면 약어를 사용하지 않는 다. 세 번째는 단수명사를 사용한다. 네 번째는 모든 엔터티를 통틀어서 유일하게 이름이 부여되어야 한다. 다섯 번째는 엔터티 생성의미대로 이름을 부여한다.


14. 속성(ATTRIBUTE)
해설: 속성이란 사전적인 의미로는 사물(事物)의 성질, 특징 또는 본질적인 성질이다. 그것이 없다면 실체를 생각할 수 없는 것으로 정의할 수 있다. 본질적 속성이란 어떤 사물 또는 개념에 없어서는 안 될 징표(表)의 전부이다. 이 징표는 사물이나 개념이 어떤 것인지를 나타내고 그것을 다른 것과 구별하 는 성질이라고 할 수 있다. 이런 사전적인 정의 외에 데이터모델링 관점에서 속성을 정의하자면, "업무 에서 필요로 하는 인스턴스에서 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 단위" 로 정의할 수 있다. 업무상 관리가 가능한 최소의 의미 단위로 생각할 수 있고, 이것은 엔터티에서 한 분야를 담당하고 있다.


15, 3
해설: 하나의 인스턴스에서 각각의 속성은 한 개의 속성값을 가져야 한다. 


16. 3
해설: 이자는 계산된 값으로 파생속성이 맞지만, 이자율은 원래 가지고 있어야 하는 속성이므로 기본속성에 해당한다.


17.  1
해설: 데이터를 조회할 때 빠른 성능을 할 수 있도록 하기 위해 원래 속성의 값을 계산하여 저장할 수 있도록 만든 속성을 파생속성(Derived Attribute)이라 한다


18. 4
해설: 각 엔터티 (테이블)의 속성에 대해서 어떤 유형의 값이 들어가는지를 정의하는 개념은 도메인(Domain)에 해당함


19. 3
해설 :속성의 명칭은 애매모호하지 않게, 복합 명사를 사용하여 구체적으로 명명함으로써 전체 데이터모델에서 유일성을 확보하는 것이 반정규화, 통합 등의 작업을 할 때 혼란을 방지할 수 있는 방법이 됨


20. 3. 4
해설: 데이터모델링에서는 존재적 관계와 행위에 의한 관계를 구분하는 표기법이 없으며, UML에서는 연관관 계와 의존관계에 대해 다른 표기법을 가지고 표현하게 되어 있다.


21. 2
해설: 관계 표기법은 관계명, 관계차수, 선택성(선택사양)의 3가지 개념으로 표현한다.


22. 2
해설: 관계의 기수성을 나타내는 개념은 관계차수에 해당함


23. 3
해설: 3 업무기술서, 장표에 관계연결을 가능하게 하는 동사 (Verb)가 있는가? 가 되어야 한다. 동사는 관계를 서술하는 업무기술서의 가장 중요한 사항이다.


24, 4
해설: 4개의 항목 모두 관계를 정의할 때 체크해야 할 항목이다.


25. 4
• 주식별자에 의해 엔터티내에 모든 인스턴스들이 유일하게 구분되어야 한다.
• 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
• 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
• 주식별자가 지정이 되면 반드시 값이 들어와야 한다.
 

26. 4
해설: 사번은 업무적으로 의미 있는 식별자로 시스템적으로 부여된 인조식별자가 아니라 일반적으로 사원
인스턴스의 탄생과 함께 업무적으로 부여되는 사원 인스턴스의 본질적인 속성에 해당한다 할 수 있기 때문에 본질식별자로 볼 수 있다.


27. 2
해설: 명칭, 내역등과 같이 이름으로 기술되는 것들은 주식별자로 지정하기에 적절하지 않다. 특히 사람의 이름은 동명이인이 있을 수 있기 때문에 주식별자로서 더더욱 부적절하다.


28. 2
해설: 주식별자를 도출하기 위한 기준은 다음과 같다.
- 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
- 명칭, 내역 등과 같이 이름으로 기술되는 것들은 가능하면 주식별자로 지정하지 않는다.
- 복합으로 주식별자로 구성할 경우 너무 많은 속성이 포함되지 않도록 한다.
자주 수정되는 속성이 주식별자가 되면 자식 엔터티에 대한 연쇄 수정이 필요하여 시스템 상에 부하의 원인이 될 수 있기 때문에 주식별자로서 적합하지 않다.


29. 4
해설: 부모엔터티의 주식별자를 자식엔터티에서 받아 손자엔터티까지 계속 흘려 보내기 위해서는 식별자관 계를 고려해야 한다. 
3의 경우는 비식별자관계를 선택하는 기준으로 고려하기에 가장 마지막으로 고려할만한 비중을 갖는다고 할 수 있다. 즉, 비식별자관계의 선택이 단순히 SQL 문장의 복잡도를 낮추는 목적에서 고려되는 것은 바람직하지 않음을 의미한다.


30. 2
해설: 엔터티별로 데이터의 생명주기(LIFE CYCLE)를 다르게 관리할 경우, 예를 들어 부모엔터티의 인스턴스 가 자식의 엔터티와 관계를 가지고 있었지만 자식만 남겨두고 먼저 소멸될 수 있는 경우 비식별자관계 로 연결하는 것이 적절하다. 부모엔터티의 인스턴스가 자식 엔터티와 같이 소멸되는 경우는 비식별자 관계보다 식별자관계로 정의하는 것이 더 적합하다.
 



제2장. 데이터 모델과 성능

31, 1
정답 및 해설
해설: 분석/설계 단계에서 데이터베이스 처리 성능을 향상 시킬 수 있는 방법을 주도 면밀하게 고려해야 한다. 만약 어떤 트랜잭션이 해당 비즈니스 처리에 핵심적이고 사용자 업무처리에 있어 중요함을 가지고 있고 성능이 저하되면 안되는 특징을 가지고 있다면, 프로젝트 초기에 운영환경에 대비한 테스트 환경을 구현하고 그곳에 트랜잭션을 발생시켜 실제 성능을 테스트해 보아야 한다. 이때 데이터 모델의 구조도 변경하면서 어떠한 구조가 해당 사이트에 성능상 가장 적절한 구조인지를 검토하여 성능이 좋은 모습으로 디자인 하는 전략이 요구된다. 보기에서 문제 발생 시점의 SQL을 중심으로 집중 튜닝하는 것은 성능 데이터모델링과 무관한 내용이다.



32. 반정규화(역정규화)
해설: 데이터 모델링 단계에서 성능을 충분히 고려하기 위한 성능 데이터 모델링 수행 절차에 대한 설명으로, 그 과정은 다음과 같다.
첫번째, 데이터모델링을 할 때 정규화를 정확하게 수행한다. 두번째, 데이터베이스 용량산정을 수행한다.
세번째, 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
네번째, 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
다섯번째, 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다. 
여섯번째, 성능관점에서 데이터모델을 검증한다.




33. 4
해설: 성능을 고려한 데이터모델링은 정규화를 수행한 이후에 용량산정과 트랜잭션 유형을 파악하여 반정규 화를 수행한다. 또한 PK/FK등을 조정하여 인덱스의 특징을 반영한 데이터모델로 만들고 이후에 데이 터모델을 검증하는 방법으로 전개한다.


34. 1
해설: 정규화가 항상 조회 성능을 저하시킨다는 것은 잘못된 생각이며 기본적으로 중복된 데이터를 제거함으 로써 조회성능을 향상시킬 수 있음을 알아야 한다.


35. 3
해설: 함수종속성의 규칙에 따라 관서번호}
→ (관리점번호, 관서명, 상태, 관서등록일자)인 관서번호가   PK인 엔터티가 2차 정규화로 분리되어야 한다.
 

36. 3
해설: 매각기일은 일자별로 매각이 시행되는 장소와 시간을 의미하는 것으로, 일자별매각물건 엔터티의 매각시간, 매각장소 속성은 두 개의 주식별자 속성 중 매각일자에만 종속되기 때문에 2차 정규화
대상이 된다.
그러므로 매각일자를 주식별자로 하고 매각시간과 매각장소 속성을 포함하는 매각기일 엔터티를 독립 시킨다. 이때 매각기일 엔터티는 일자별매각물건의 주식별자 중 일부로부터 독립했기 때문에 매각기 일과 일자별매각물건은 1:M 관계로 연결된다.
이와 같은 2차 정규화를 통해 특정 장소에서 이루어진 매각내역을 조회하고자 할 때 100만건의 일자별 매각내역 데이터를 모두 읽어 원하는 장소에 해당하는 인스턴스들을 찾아 매각일자별로 그룹핑한 후 매각일자별매각내역과 조인할 필요가 없이 매우 적은 수의 매각기일 엔터티에서 특정 장소에 해당 하는 매각일자들을 찾아 매각일자별매각내역과 1:1로 바로 조인하면 되기 때문에 I/O를 현저하게 감소시킬 수 있어 성능 향상 효과를 얻을 수 있다.
 


37. 4
해설: 칼럼에 의한 반복적인 속성값을 갖는 형태는 속성의 원자성을 위배한 제1차 정규화의 대상이 된다. 이와 같은 반복적인 속성 나열 형태에서는 각 속성에 대해 'or' 연산자로 연결된 조건들이 사용되는데, 이 때 어느 하나의 속성이라도 인덱스가 정의되어 있지 않게 되면 'or'로 연결된 모든 조건절들이 인덱스를 사용하지 않고 한 번의 전체 데이터 스캔으로 처리되게 되어 성능 저하가 나타날 수 있게 되며, 또한 모든 반복 속성에 인덱스를 생성하게 되면 검색 속도는 좋아지겠지만 반대급부적으로 너무 많은 인덱스로 인해 입력, 수정, 삭제의 성능이 저하되므로, 1차 정규화를 통해서 자연스럽게 문제가 해결될 수 있도록 해야 한다.



38. 1
해설: 컬럼 단위에서 중복된 경우도 1차 정규화의 대상이 된다. 이에 대한 분리는 1:M의 관계로 두 개의 엔터티로 분리된다.
 

39. 1
해설: PK에 대해 반복이 되는 그룹(Repeating)이 존재하지 않으므로 1차 정규형이라고 할 수 있으며, 부분 함수종속의 규칙을 가지고 있으므로 2차 정규형이라고 할 수 없음. 2차 정규화의 대상이 되는 엔터티임.



40. 1
해설: 
• 다량 데이터 탐색의 경우 인덱스가 아닌 파티션 및 데이터 클러스터링 등의 다양한 물리 저장 기법을 활용하여 성능 개선을 유도할 수 있다. 다만, 하나의 결과셋을 추출하기 위해 다량의 데이터를 탐색하는
 처리가 반복적으로 빈번하게 발생한다면 이때는 반정규화를 고려하는 것이 좋다.
• 이전 또는 이후 위치의 레코드에 대한 탐색은 window function으로 접근 가능하다.
•집계 테이블 이외에도 다양한 유형(다수 테이블의 키 연결 테이블 등)에 대하여 반정규화 테이블 적용이 필요할 수 있다.


41. 4
해설: 반정규화의 기법은 테이블, 속성, 관계에 대해서 반정규화를 적용할 수 있으며, 하나의 테이블의 전체 칼럼 중 자주 이용하는 집중화된 칼럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 칼럼들을 별도로 모아 놓는 반 정규화 기법은 테이블추가 반정규화 기법 중에서 부분테이블 추가에 해당한다.


42. 3
해설: 3 FK에 대한 속성 추가는 반정규화 기법이라기 보다는 데이터모델링에서 관계를 연결할 때 나타나는 자연스러운 현상이다.


43. 3
해설: 제품 엔터티에 단가를 주문번호별로 합하는 것은 해당 제품이 여러 주문에 포함될 수 있기 때문에 특정 주문번호만의 단가 합계금액을 갖고 있을 수 없고, 주문목록 엔터티에 주문번호별 단가 합계 금액을 추가하게 되면 하나의 주문에 포함된 제품번호마다 동일한 합계 금액을 반복적으로 저장해야 해서 일관성 문제가 발생할 수 있다. 또한 제품 엔터티에 최근값 여부 칼럼을 추가하는 것은 단가 합계 금액을 빠르게 얻기 위한 반정규화와 무관한 조치이다. 그러므로 주문 엔터티에 전체를 통합한 계산된 칼럼을 추가하는 것이 한번에 데이터를 조회하는 방법이 되므로 가장 효과적인 반정규화 기법 이다.


44. 1
해설: 최근에 변경된 값만을 조회할 경우 과도한 조인으로 인해 성능이 저하되어 나타나게 된다.
 

45. 3
해설: 한 테이블에 많은 칼럼들이 존재할 경우 데이터가 물리적으로 저장되는 디스크 상에 넓게 분포할 가능성이 커지게 되어 디스크 1/0가 대량으로 발생할 수 있고, 이로 인해 성능이 저하될 수 있음. 따라서 트랜잭션이 접근하는 칼럼유형을 분석해서 자주 접근하는 칼럼들과 상대적으로 접근 빈도가 낮은 칼럼들을 구분하여 1:1로 테이블을 분리하면 디스크 I/O가 줄어들어 성능을 향상 시킬 수 있다. 테이블 내에서 칼럼의 위치를 조정하는 것은 데이터 주로 채워지는 칼럼을 앞 쪽에 위치시키고, 데이터 가 채워지지 않고 주로 NULL 상태로 존재하는 칼럼들을 뒤쪽에 모아둠으로써 로우의 길이를 어느 정도 감소시킬 수 있으나, NULL 상태이던 칼럼에 나중에 데이터가 채워지게 될 경우 더 많은 로우 체인이 발생할 수도 있기 때문에 바람직한 해결책이라고 보기에 부족하며, 무엇보다도 데이터가 채워 지지 않고 NULL 상태로 존재하게 되는 칼럼들이 많이 나타나는 경우는, 너무 많은 엔터티들에 무리하 게 동질성을 부여하여 통합을 수행했거나, 예측하기 어려운 미래 시점을 겨냥하여 과도하게 의욕적으 로 속성을 확장한 경우 등에서 주로 나타나기 때문에, 자주 사용되는 칼럼들이나 현시점에서 주로 사용되는 칼럼들을 한데 모으고, 사용빈도가 낮은 칼럼들이나 미래 시점에 사용될 것으로 예상되는 나머지 칼럼들을 한데 모아 별도의 1:1 관계 엔터티로 분리하는 등의 데이터모델 설계 수정을 고려해 보는 것이 좋다.




46. 파티셔닝(Partitionning)



47. 2
해설: 개별 테이블을 모두 조회하는 트랜잭션이 대부분이라는 가정이 있으므로 UNION/UNION ALL할 경우 개별조회에 따른 시간소요와 이것을 조합하는 성능저하가 발생된다. 따라서 하나의 테이블로 통합하도록 하고 대신 PK체계나 일반속성에 각 사건을 구분할 수 있도록 구분자를 부여한다.


48. 4
해설: 트랜잭션은 항상 전체를 통합하여 분석 처리하는데 슈퍼-서브타입이 하나의 테이블로 통합되어 있으면 하나의 테이블에 집적된 데이터만 읽어 처리할 수 있기 때문에 다른 형식에 비해 더 성능이 우수하다. (조인 감소)


49. 4
해설: 인덱스는 값의 범위에 따라 일정하게 정렬이 되어 있으므로 상수값으로 EQUAL 조건으로 조회되는 칼럼이 가장 앞으로 나오고 범위조회 하는 유형의 칼럼이 그 다음에 오도록 하는 것이 인덱스 액세스 범위를 좁힐 수 있는 가장 좋은 방법이 됨


50. 2
해설: '='로 들어온 조건에 해당하는 칼럼이 인덱스의 가장 앞쪽에 위치할 때 인덱스의 이용 효율성이 가장
높다고 할 수 있다.
 

51. 2, 4
해설: 엔터티 간에 논리적 관계가 있을 경우 즉, 엔터티 간에 관계(Relationship)을 정의하여 관련 엔터티 상호간에 업무적인 연관성이 있음을 표현한 경우에는, 이 데이터들이 업무적으로 밀접하게 연결되어 상호간에 조인이 자주 발생한다는 것을 의미하는 것이기 때문에, 데이터베이스 상에서 DBMS가 제공 하는 FK Constraints를 생성했는지 여부와 상관없이 조인 성능을 향상시키기 위한 인덱스를 생성해주 는 것이 좋다. 그러므로 수강신청테이블의 학사기준번호에 인덱스가 필요하다.
데이터베이스에 생성하는 FK Constraints는 데이터 모델 상에 표현된 논리적 관계에 따라 관련 인스 턴스 간에 일관성을 보장하기 위해 설계된 제약조건을 구현할 수 있도록 DBMS가 제공해주는 하나의 '지원 기능'으로 이해될 수 있다.



52, 4
해설: Global Single Instance(GSI)는 통합된 한 개의 인스턴스 즉, 통합 데이터베이스 구조를 의미하므로, 분산데이터베이스와는 대치되는 개념이다.
공통코드, 기준정보 등과 같은 마스터 데이터를 한 곳에 두고 운영하는 경우 원격지에서의 접근이 빈번할수록 실시간 업무처리에 대해 좋은 성능을 얻기가 어려울 수 있기 때문에 분산 환경에 복제분산 을 하는 방법으로 분산데이터베이스를 구성할 수 있다. 또한 백업 사이트 구성에 대해서도 분산 환경으 로 구성하여 적용할 수 있다. 

