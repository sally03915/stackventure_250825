
136, 2
137, 3, 4
해설: 1 인테스를 생성할 때 정렬 순서를 내림차순으로 하면 내림차순으로 정렬된다.
138.0.3
2 비용기반 옵티마이저는 SQL을 수행하는데 있어 소요되는 비용을 계산하여 실행계획을 생성하므로 인테스가 존재하더라도 전체 테이블 스캔이 유리하다고 판단할 수도 있다.
5 규칙기반 옵티마이저의 규칙에 따라 적절한 인덱스가 존재하면 전체 테이블 스캔보다는 항상 인덱
스를 사용하려고 한다.
4 인덱스 범위 스캔은 결과 건수만큼 반환하지만, 결과가 없으면 한 건도 반환하지 않을 수 있다.
해설: 2 REGIST_DATE 조건이 범위 조건이고 DEPTNO 컬럼이 후행 컬럼이므로 효율적인 조건 검색을 할 수 없다.
139, 4
4 b*tree index는 일반적으로 테이블 내의 데이터 중 10%이하의 데이터를 검색할 때 유리하다.
해설: 인덱스를 스캔하여 테이블로 데이터를 찾아가는 방식이 랜덤 엑세스인데, 이러한 랜덤 엑세스의 부하가 크기 때문에 매우 많은 양의 데이터를 읽을 경우에는 인덱스 스캔보다 테이블 전체 스캔이 유리할 수도 있다.
140, 2
해설: 대량의 데이터를 조회하는 경우 인덱스를 이용한 조회보다는 테이블 전체 스캔 방식으로 조회 하는것이 더 빠를 수도 있으며, 인덱스를 구성하는 컬럼들의 순서는 데이터 조회 시 성능적인 관점에서 매우 중요한 역할을 한다. 또한 인덱스를 구성하는 컬럼 이외의 데이터가 UPDATE될 때는 인덱스로 인한 부하가 발생하지 않는다.
141, 2
해설: NL Join은 데이터를 집계하는 업무 보다는 OLTP의 목록 처리 업무에 많이 사용된다. DW 등의 데이터 집계 업무에서 많이 사용되는 Join 기법은 Hash Join 또는 Sort Merge Join 이다.
142, (3)
해설: 소트 머지 조인(Sort Merge Join)을 수행하기에 두 테이블이 너무 커서 소트(Sort) 부하가 심할 때는
143. 4
Hash Join이 유용하다.
해설: EXISTS 절은 실행계획상에 주로 SEMI JOIN으로 나타난다. NESTED LOOP, HASH, SORT MERGE의 SEMI JOIN이 모두 나타날 수 있지만, 위의 인덱스 정보와 SQL을 볼 때 HASH SEMI JOIN 보다는
NESTED LOOP SEMI JOIN 이 나타날 가능성이 가장 크다.