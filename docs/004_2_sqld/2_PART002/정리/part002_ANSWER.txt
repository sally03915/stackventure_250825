
과목 II. SQL 기본 및 활용
제1장. SQL 기본
1. 4
해설: 데이터 제어어(DCL:Data Control Language)는 데이터베이스에 접근하고 객체들을 사용할 수 있도록 권한을 부여하거나 회수하는 명령어로 GRANT, REVOKE가 있다.
2. 2
해설: 데이터의 구조를 정의하는 명령어는 DDL(데이터 정의어)에 해당하며 DDL 문으로는 CREATE. ALTER, DROP, RENAME 이 있다.
3. TCL
46
해설: Transaction를 제어하는 명령어는 TCL(Transaction Control Language)이다.
4. 1
해설: As-Is: 비절차적 데이터 조작어(DML)는 사용자가 무슨(What) 데이터를 원하는 지만을 명세함. To-Be: 비절차적 데이터 조작어(DML)는 사용자가 무슨(What) 데이터를 원하는 지만을 명세하지만, 절차적 데이터 조작어는 어떻게 (How) 데이터를 접근해야 하는지 명세 한다. 절차적 데이터 조작어로 는 PL/SQL(오라클), T-SQL(SQL Server 등이 있다.
5. 1, 2
해설: DDL(Data Definition Language): CREATE, DROP, ALTER, RENAME
DML(Data Modification Language): SELECT, INSERT, UPDATE, DELETE
DCL(Data Control Language): GRANT, GRANT, REVOKE
TCL(Transaction Control Language): COMMIT, ROLLBACK
6. 4
해설: 1은 PK를 지정하는 ALTER TABLE 문장에 문법 오류가 존재하고, 올라른 문법이 사용된 문장은 다음과 같다.
(오류 발생) ALTER TABLE PRODUCT ADD PRIMARY KEY PRODUCT_PK ON (PROD_ID);
(오류 수정) ALTER TABLE PRODUCT ADD CONSTRAINT PRODUCT_PK PRIMARY KEY (PROD_ID);
2 NOT NULL 컬럼에 대해서 NOT NULL 제약조건을 지정하지 않았다.
3은 테이블을 생성할 때 PK를 지정하는 문장에 문법 오류가 존재한다.


7. 4
해설 : 1, 2 SQLServer에서는 여러개의 컬럼을 동시에 수정하는 구문은 지원하지 않으므로 오류가 발생한다.
8. 3
또한 SQLServer에서는 괄호를 사용하지 않는다.
3 분류명을 수정할 때 NOT NULL 구문을 지정하지 않으면, 기존의 NOT NULL 제약조건이 NULL 변경되므로 NOT NULL 요건을 만족하지 않는다.
해설: NULL은 공백문자(Empty String) 혹은 숫자 0과 동일하지 않다.
9. 2
해설: DELETE FROM T; 이후 데이터 현황
10. 1
-T 테이블: 두건 모두 삭제됨
- S 테이블 (Cascade 옵션): 두건 모두 삭제됨
-R 테이블 (Set Null 옵션) : Child 해당 필드(FK: B칼럼) 값이 Null로 변경됨
해설: PK= UNIQUE & NOT NULL 특징을 가짐.
UNIQUE는 테이블 내에서 중복되는 값이 없지만, NULL 입력이 가능하다.
11. 1
해설: 테이블명과 칼럼명은 반드시 문자로 시작해야 한다.
사용되는 글자는 A-Z, a-z, 0-9, $, #만 허용함.
12. 1, 3
해설: 2 SQL 문장은 정상적으로 수행되지만, DEPT_CODE 컬럼에 NOT NULL 제약조건이 생성되지 않는다. NOT NULL 제약조건이 생성되지 않으면 명시적으로 DEPT_CODE 컬럼에 NULL을 입력하게 되면 NULL이 입력되는 문제가 발생한다. DEL MUIGATE OF MUIGATE MANSS
13. 3
4 테이블 생성문과 인덱스 생성문은 정상적으로 수행되지만, 테이블 생성문장에서 이미 PRIMARY KEY를 지정하였으므로 ALTER TABLE 문장에서 오류가 발생한다.
해설: 학번 칼럼이 PK 이기 때문에 NULL 값이 없다. count(*)와 COUNT(학번)의 결과는 항상 같다.
14. 2, 3
해설: 1 테이블 생성시 설정할 수 있다.
2 외래키 값은 널 값을 가질 수 없다. 있다
3 한 테이블에 하나만 존재해야 한다. 여러 개 존재할 수 있다.
4 외래키 값은 참조 무결성 제약을 받을 수 있다.

15. 3
해설: 고유키(Unique Key)로 지정된 모든 컬럼은 Null 값을 가질 수도 있으므로 3번 보기에 오류가 있다.
16. ALTER, DROP COLUMN
해설: Table 스키마 변경 시 사용하는 SQL문은 DDL (Data Definition Language)로 컬럼 삭제 시 활용되는
17. 2
문장은 다음과 같다.
ALTER TABLE 테이블명
DROP COLUMN 컬럼명
해설: 참조무결성 규정
DELETE FROM 부서 WHERE 부서번호= '20'; →
CASCADE 참조 무결성 규정이므로 직원 테이블의 '2000', '3000'도 같이 삭제됨
SELECT COUNT(직원번호) FROM 직원
직원 테이블 1000'에 대한 1건이 출력됨
Delete(/Modify) Action: Cascade, Set Null, Set Defanit Rastrict (부서-사원)
1) Cascade
2) Set Null
3) Set Default 4) Restrict
5) No Action
: Master 삭제 시 Child 같이 삭제
: Master 삭제시 Child 해당 필드 Null
: Master 삭제 시 Child 해당 필드 Default 값으로 설정
: Child 테이블에 PK 값이 없는 경우만 Master 삭제 허용
: 참조무결성을 위반하는 삭제/수정 액션을 취하지 않음
18. RENAME STADIUM TO STADIUM_JSC;
해설: RENAME OLD OBJECT NAME TO NEW_OBJECT_NAME (ANSI 표준 기준, 오라클과 동일함)
RENAME STADIUM TO STADIUM_JSC;



19. 4
해설: -
Delete(/Modify) Action: Cascade, Set Null, Set Default, Restrict (부서-사원)
1) Cascade
2) Set Null
3) Set Default
4) Restrict
5) No Action
: Master 삭제 시 Child 같이 삭제
: Master 삭제 시 Child 해당 필드 Null
: Master 삭제 시 Child 해당 필드 Default 값으로 설정
: Child 테이블에 PK 값이 없는 경우만 Master 삭제 허용
: 참조무결성을 위반하는 삭제/수정 액션을 취하지 않음
- Insert Action: Automatic, Set Null, Set Default, Dependent (부서-사원)
1) Automatic
2) Set Null
3) Set Default
: Master 테이블에 PK가 없는 경우 Master PK를 생성 후 Child 입력
: Master 테이블에 PK가 없는 경우 Child 외부키를 Null 값으로 처리
: Master 테이블에 PK가 없는 경우 Child 외부키를 지정된 기본값으로 입력
: Master 테이블에 PK가 존재할 때만 Child 입력 허용
4) Dependent
5) No Action
: 참조무결성을 위반하는 입력 액션을 취하지 않음
20. 4
해설: 1: 삽입 컬럼을 명시하지 않았을 경우 모든 컬럼을 삽입해야 한다.
21, 2
2: DEGREE 컬럼의 길이는 VARCHAR2(1)이다. 'AB'는 컬럼 길이를 초과한다.
3: Not Null 컬럼인 AMT 필력을 명시하지 않았다.
해설: 2번 SQL은 REG_DATE 컬럼에 NOT NULL 제약조건이 있지만 INSERT INTO 구문에는 REG_DATE 컬럼이 대입되지 않아 NULL로 입력되므로 오류가 발생한다.
22. 1, 3
쿠모
해설: 2는 고객 테이블에 존재하지 않는 고객ID의 주문을 입력하려고하여 무결성 제약 오류가 발생한다. 1번 SQL을 수행 후에는 정상 입력된다.)
23. 1
4는 고객 테이블의 고객ID 'CO02'를 삭제하려고 할 때 SQL에 의해 추가된 CONSTRAINT에 따라 주문 테이블의 고객ID를 NULL로 업데이트하려고 DBMS에서 시도하지만, 주문 테이블 고객ID 컬럼의 NOT NULL 제약조건에 의해 실패한다.
해설: TRUNCATE TABLE과 DROP TABLE은 로그를 남기지 않으므로 개발 기준과 상충된다. 지문2는 문법에 맞지 않다.


24. DISTINCT
25.
해설: 데이터의 중복을 제거하는 명령어는 "DISTINCT" 이다. GROUP BY문을 사용하여 다음과 같이 중복
데이터를 제거 할 수 있다.
SELECT 거주지, 근무지
FROM 고객지역
GROUP BY 거주지, 근무지:
해설: 1 특정 테이블의 모든 데이터를 삭제하고, 디스크 사용량을 초기화 하기위해서는 TRUNCATE TABLE 명령을 사용하여야 한다.
2 DELETE TABLE은 테이블의 데이터를 모두 삭제하지만, 디스크 사용량을 초기화 하지는 않는다.
3 DROP TABLE은 테이블의 데이터를 모두 삭제하고 디스크 사용량도 없앨(초기화) 수 있지만, 테이 블의 스키마 정의도 함께 삭제된다.
4 DELETE TABLE FROM은 존재하지 않는 명령어이다.
26. 1, 4
해설:
DROP
DDL
Rollback 불가능
Auto Commit
테이블이 사용했던 Storage
Release
테이블의 정의 자체를
완전히 삭제함
TRUNCATE
DDL
(일부 DML 성격 가짐)
Rollback 불가능
Auto Commit
테이블이 사용했던 Storage중 최초 테이블 생성시 할당된 Storage만 남기고 Release
테이블을 최초 생성된
초기상태로 만듬
DELETE
DML
Commit 이전 Rollback 가능
사용자 Commit
데이터를 모두 Delete해도 사용했던 Storage는 Release되지 않음
데이터만 삭제
1 ES



27. 2, 4
해설: 데이터베이스 트랜잭션의 4가지 특성: 일관성과 지속성의 설명이 바뀌었다.
특성
원자성 (atomicity)
설명
트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아 있어야 한다. (All or Nothing)
일관성
(consistency)
고립성 (isolation)
트랜잭션이 실행 되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다. 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다.
지속성 (durability)
트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다.
28. 1, 4
해설: 1 Dirty Read: 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 데이터를 읽는 것을 말한다. 4 isolation(트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다)은 데이터베이스 트랜잭션의 4가지 특성으로 문제점이 아니고 목표라고 할 수 있다.
29. 3
해설: 1 ORACLE에서는 DDL 문장 수행 후 자동으로 COMMIT을 수행한다.
2 SQL Server에서는 DDL 문장 수행 후 자동으로 COMMIT을 수행하지 않는다.
3 ORACLE에서 DDL 문장의 수행은 내부적으로 트랜젝션을 종료 시키므로 B 테이블은 생성된다.
4 SQL Server에서는 CREATE TABLE 문장도 TRANSACTION의 범주에 포함된다. 그러므로 ROLLBACK 문장에 의해서 최종적으로 B 테이블은 생성되지 않는다.
30. ᄀ : 트랜젝션 또는 Transaction
ᄂ: 커밋 또는 Commit
ᄃ : 롤백 또는 Rollback
31, 3
해설: ROLLBACK 구문은 COMMIT되지 않은 상위의 모든 Transaction을 모두 rollback한다.
32. LCD-TV
해설: ROLLBACK TRANSACTION SP2 문장에 의해 UPDATE 상품 SET 상품명= '평면-TV' WHERE 상품ID= '001'이 ROLLBACK 되었고, 첫 번째 UPDATE 문장만 유효한 상태에서 COMMIT 되었으므로 첫 번째 UPDATE한 내역만 반영 된다. 그러므로 LCD-TV가 된다.


33. WHERE 또는 WHERE 절
해설: WHERE 절은 SQL을 이용하여 데이터베이스로부터 데이터를 검색할 때 조회되어야 하는 데이터를
34. 2
필터링하는데 사용된다.
해설: 논리연사자의 우선순위는 NOT> AND > OR 순이다.
35, 4
(EMPNO > 100 AND SAL>= 3000) OR EMPNO=200
해설: NULL 값이 포함된 4칙 연산의 결과는 NULL이다.
30+20=50
NULL+40=NULL
50+NULL=NULL
36.
해설: NULL 값을 조건절에서 사용하는 경우 IS NULL, IS NOT NULL이란 키워드를 사용해야 한다.
37. 4
해설: 1 서비스번호 컬럼의 모든 레코드가 '001'과 같은 숫자형식으로 입력되어 있어야 오류가 발생하지 않는다. 2ᄂ과같이 데이터를 입력하면, 서비스명 컬럼의 데이터에 대해서 ORACLE에서는 NULL로 입력된다. 3 ᄂ과같이 데이터가 입력되어있을 때, ORACLE에서 데이터를 조회하려면 서비스명 IS NULL 조건 으로 조회하여야 한다.
38. 4
4 ᄂ과같이 데이터가 입력되어있을 때, SQL Server에서 데이터를 조회하려면 서비스명='로 조회하 여야 한다.
해설: 1의 조건은 2014년 03월부터 12월까지 매출금액과 2015년 03월부터 2013년 12월까지의 매출금액의 합이다.
39. 4
2의 조건은 1의 조건과 동일하다.
3의 조건은 2014년 01월부터 12월까지의 매출금액과 2015년 01월부터 12월까지의 매출금액의 합이다. 즉, 전체 데이터의 합이다.
4의 조건은 2014년 11월부터 2015년 03월까지의 매출금액의 합이며, 연산자의 우선순위(AND > OR) 에 의해 괄호가 없어도 된다.
해설: 1, 2, 3번 SQL은 모두 가입이 2014년 12월 01일 00시에 발생했고 서비스 종료일시가 2015년 01월 01일 00시 00분 00초와 2015년 01월 01일 23시 59분 59초 사이에 만료되는 데이터를 찾는 조건이지만, 4번 SQL은 가입 조건은 동일하지만, 서비스 종료일시가 2015년 01월 01일 00시 00분 00초에 종료되는 SQL을 찾는 조건이다.

40. 2
해설: 다) 1:M 조인이라 하더라 M쪽에서 출력된 행이 하나씩 단일행 함수의 입력값으로 사용되므로 사용할
수 있다.
라) 다중행 함수도 단일행 함수와 동일하게 단일 값만을 반환한다.
41. 3
해설: 라인수를 구하기 위해서 함수를 이용해서 작성한 SQL이다.
LENGTH: 문자열의 길이를 반환하는 함수
CHR: 주어진 ASCII 코드에 대한 문자를 반환하는 함수 (CHR(10) → 줄바꿈)
REPLACE: 문자열을 치환하는 함수 (REPLACE(C1, CHR(10)) -→ 줄바꿈 제거)
함수 결과 값
ROWNUM
C1
1
A
3
LENGTH(C1) REPLACE(C1, CHR(10)) LENGTH(REPLACE(C1, CHR(10))) 변경 전 변경 후
2
A
A
AA
2
B
5
B
B
AHOBB B
변경 전
변경 후
3
BBB
42, 3
해설: 오라클에서 날짜의 연산은 숫자의 연산과 같다. 특정 날짜에 1을 더하면 하루를 더한 결과와 같으므로 1/24/60= 1분을 의미한다. 1/24/(60/10)= 10분과 같으므로 2015년 1월 10일 10시에 10분을 더한 결과와 같다.
43. LOC WHEN 'NEW YORK' THEN 'EAST'
해설: SEARCHED_CASE_EXPRESSION SIMPLE_CASE_EXPRESSION으로 변환하는 문제임.
SELECT LOC,
CASE LOC WHEN 'NEW YORK' THEN 'EAST'
ELSE 'ETC'
END as AREA
FROM DEPT;
44. 4
해설: 지문 4는 CASE 문장에서 데이터가 없는 경우를 0으로 표시해야(ELSE 0),
다른 3개의 지문과 같은 결과가 나온다.

45, 2
해설: ISNULL 함수는 결과값이 NULL일 경우 지정된 값을 반환한다. 칼럼의 NULL 값을 확인할 때는 IS
NULL을 사용해야 한다.
46. NULLIF
해설 : NULLIF 함수는 EXPR1이 EXPR2와 같으면 NULL을, 같지 않으면 EXPR1을 리턴한다.
47. 4
특정 값을 NULL로 대체하는 경우에 유용하게 사용할 수 있다.
NULLIF (EXPR1, EXPR2)
해설: NULL이 포함된 연산의 결과는 NULL이다.
분모가 0이 들어가는 경우 연산 자체가 에러를 발생하며 원하는 결과를 얻을 수 없다.
1, 0/300 = 0
2.5000/0: 에러 발생
3. 1000/NULL= NULL
A
48. 3
해설: 따라서, 결과의 합은 6이다.
COALESCE 함수는 첫번째 NULL이 아닌 값을 반환한다.
COALESCE(C1, C2, C3)는 각 Row에서 첫번째로 NULL이 아닌 값인 1, 2, 3을 반환한다.
49. ᄀ : NVL, ᄂ: NULLIF, ᄃ : COALESCE
해설: ISNULL, NVL 함수는 표현식1의 결과값이 NULL이면 표현식의 값을 출력하며, NULLIF는 표현식1일 표현식2와 같으면 NULL을 같지 않으면 표현식을 리턴한다. COALESCE는 임의의 개수 표현식에서 NULL이 아닌 최초의 표현식을 나타낸다.


50. 3
해설: SELECT AVG(COL3) FROM TAB_A;→ (20+0)/2건=10 →세번째 행 COL3의 NULL은 AVG 연산 대상에서 제외됨
COL1
COL2
COL3
30
NULL 0
NULL 40
20
0
10
NULL
SELECT AVG(COL3) FROM TAB_A WHERE COLI> 0;→ (20)/1건=20
→ WHERE절에 의해 COL1이 NULL인 두번째 행은 NULL 연산 제외 조건으로 제외됨 →WHERE절에 의해 COL1이 0인 세번째 행은 연산 대상에서 제외됨
COLT
30
COL2
NULL
COL3
20
SELECT AVG(COL3) FROM TAB_A WHERE COLI IS NOT NULL; → (20)/1건=20
→ COLI NULL인 두번째 행은 NOT NULL 조건으로 인해 제외됨
→세번째 행 COLBD의 NULL은 AVG 연산 대상에서 제외됨
30 0
COL2
COL3
NULL 10
20
NULL
51. 3
해설: SQL1) SELECT COUNT(GRADE) FROM EMP;
800A
645건: 사원 500명+ 대리 100명+ 과장 30명+ 차장 10명+ 부장 5명 이때 NULL 25건은 제외된다.
010
SQL2) SELECT GRADE FROM EMP WHERE GRADE IN (차장', '부장',''); 15건: 차장 10명+ 부장 5명
HAVING
'널'이 텍스트로 입력된 데이터는 없다고 봐야 함
정의되지 않은 미지의 값인 NULL과 '널' 텍스트 데이터는 다름. 또한 IN ('차장', '부장', NULL)로 변경하여도 실제 NULL 데이터는 출력되지 않음. NULL 비교는 오직 'IS NULL, IS NOT NULL'만 가능
SQL3) SELECT GRADE, COUNT(*) FROM EMP GROUP BY GRADE; 671 : 5개 직급+ NULL 기준별 데이터 수가 6건 출력됨



52. 2
해설: 광고게시 테이블에서 광고매체ID별로 광고시작일자가 가장 빠른 데이터를 추출하는 SQL을 작성해야
한다.
1의 경우 연관 서브쿼리를 활용하는 방법이지만, 이를 활용하기위해서는 WHERE 절에서 사용되어야 한다. (Inline View에서는 사용할 수 없다)
3은 광고ID별로 광고매체ID와 광고시작일자의 최소값을 출력하므로 틀린 결과이다.
4은 광고게시의 전체데이터에서 광고매체ID의 최소값과 광고시작일자의 최소값을 가져오므로 틀린
결과이다.
53. 4
해설: 3 GROUP BY로 그룹핑된 컬럼에 대해서 HAVING 조건절을 사용할 경우 집계된 컬럼의 FILTER 조건으로 사용할 수가 있다. 이런 경우 HAVING절에 집계함수가 없이도 사용할 수 있다. 4 중첩된 그룹함수의 경우 최종 결과값은 1건이 될 수밖에 없기에 GROUP BY절에 기술된 메뉴ID와 사용유형코드는 SELECT에 기술될 수 없다.
54. 2
해설: SQL 실행 순서에 의해 HAVING절은 SELECT절보다 선행처리 되기에, SELECT COUNT 함수 사용 여부는 관계없다. 위의 SQL은 나 컬럼으로 GROUP BY를 수행하였을 때 건수가 2건 이상인 데이터를 추출하여 SUM(다)의 값이 큰 순으로 정렬하는 SQL이므로 아래와 같은 결과에서
가
나
다
CNT
009
A003
600
4
005
A002
500
3
002
A001
300
2
010
A004
200
1
CNT가 2이상인 것만 출력된다.
55. 2
해설: Group By Having 한 결과에 대해 정렬 연산을 하는 것이다.
ID 건수가 2개이며, ORDER BY CASE문에 의해 999는 0으로 치환되고 그 외는 ID 값으로 정렬된다.
234 | SQL 자격검정 실전문제



56, 3
해설: 2 SQL 실행 순서에 의하면 SELECT 이후에 ORDER BY 절이 수행되기 때문에 SELECT 절에 기술되지 않는 '년' 칼럼으로 정렬하는 것은 논리적으로 맞지 않다. 하지만 오라클은 행기반 DATABASE 이기에 데이터를 액세스할 때 행 전체 칼럼을 메모리에 로드한다. 이와 같은 특성으로 인해 SELECT절에 기술되지 않은 칼럼으로도 정렬을 할 수 있다.
단, 아래와 같은 SQL일 경우에는 정렬을 할 수 없다.
SELECT 지역, 매출금액
FROM (
SELECT 지역, 매출금액
FROM 지역별매출
ORDER BY ASC;
57. 3
이는 IN-LINE VIEW가 먼저 수행됨에 따라 더 이상 SELECT 외 칼럼을 사용할 수 없기 때문이다.
3 GROUP BY를 사용할 경우 GROUP BY 표현식이 아닌 값은 기술될 수 없다.
4 GROUP BY 표현식이기에 가능하다.
해설: ORDER BY 절에 컬럼명 대신 Alias 명이나 컬럼 순서를 나타내는 정수를 혼용하여 사용할 수 있다.
58. 2
해설: CASE절을 이용해서 원래의 정렬 순서를 변경하였다. 그래서 ID가 'A'인 것이 가장 먼저 표시되도록 하였다.
59. 4
해설: SELECT 문장의 실행 순서는 FROM - WHERE - GROUP BY - HAVING - SELECT – ORDER BY
60. 4
이다.
해설: SQL Server의 TOP N 질의문에서 N에 해당하는 값이 동일한 경우 함께 출력되도록 하는 WITH TIES 옵션을 ORDER BY 절과 함께 사용하여야 한다.
61, 3
해설: 여러 테이블로부터 원하는 데이터를 조회하기 위해서는 전체 테이블 개수에서
최소 N-1 개 만큼의 JOIN 조건이 필요하다.
SQL 자격검정 실전문제 | 235

62, 4
해설: 영화명과 배우명은 출연 테이블이 아니라 영화와 배우 테이블에서 가지고 와야 하는 속성이므로 출연테 이블의 영화번호와 영화테이블의 영화번호 및 출연테이블의 배우번호와 배우테이블의 배우번호를
63. 4
조인하는 SQL문을 작성해야 함.
해설: DBMS 옵티마이저는 From 절에 나열된 테이블이 아무리 많아도 항상 2개의 테이블씩 짝을 지어
64. 3
Join을 수행한다.
해설: LIKE 연산자를 이용한 조인의 이해가 필요하다.
SQL의 실행결과는 다음과 같다.
EMPNO
ENAME
RULE
1000
SMITH
S%
1100
SCOTT
S%
1000
SMITH
%T%
1100
SCOTT
%T%
236 | SQL 자격검정 실전문제



65. 2
제2장. SQL 활용
해설: 순수 관계 연산자에는 SELECT, PROJECT, JOIN, DIVIDE가 있다.
66. 3, 4
해설: 1 NOT EXIST 절의 연관서브쿼리에 X. 컨텐츠ID= B. 컨텐츠ID가 존재하지 않아 단 하나의 컨텐츠라도
67. 1, 2
비선호로 등록한 고객에 대해서는 모든 컨텐츠가 추천에서 배재 된다.
2 추천컨텐츠를 기준으로 비선호컨텐츠와의 LEFT OUTER JOIN이 수행되고 비선호컨텐츠의 컨텐츠 ID에 대해서 IS NULL 조건(3 번과 같이)이 있다면 정확히 비선호 컨텐츠만 필터링할 수 있다. (고객이 비선호로 등록하지 않은 컨텐츠는 추천컨텐츠에만 등록 되어있으므로)
해설: 3 데이터 모델을 보면 제품과 생산라인 엔터티에는 생산제품과 대응되지 않는 레코드가 있을 수 있다.
4 특정 생산라인에서 생산되는 제품의 제품명을 알기위해서는 제품과 생산제품까지 2개의 엔터티만을 Inner Join 하면 된다.
68. 2
해설: 구매이력이 있어야 하므로 INNER JOIN이 필요하며, 구매 횟수이므로 COUNT 함수를 사용한다.
69. 3
해설: 1 두 번째 ON 절이 B. 사용시간대 BETWEEN C. 시작시간대 AND C. 시작시간대가 되어야 한다. 2 INNER JOIN 구문 오류가 발생한다.
70. 1
4 BETWEEN JOIN 이란 구문은 없다. 구문 오류가 발생한다.
해설: TEAM, STADIUM 두 테이블을 조인하여 사용한다.
1 USING 조건절을 이용한 EQUI JOIN에서도 NATURAL JOIN과 마찬가지로 JOIN 칼럼에 대해서는
ALIAS나 테이블 이름과 같은 접두사를 붙일 수 없다. 지문 1는 SYNTAX 에러 발생함.
USING T.STADIUM_ID=S.STADIUM_ID
→ USING (STADIUM_ID)
SELECT T.REGION_NAME, T.TEAM_NAME, T.STADIUM_ID, S.STADIUM_NAME
→ SELECT T.REGION_NAME, T.TEAM_NAME, STADIUM_ID, S.STADIUM_NAME
SQL 자격검정 실전문제 | 237


71. CROSS JOIN
72,
해설: CROSS JOIN EP. CODD 박사가 언급한 일반 집합 연산자의 PRODUCT의 개념으로 테이블 간 JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합을 말한다. 조건이 없거나 CROSS JOIN
키워드를 사용할 수 있다.
해설: WHERE 절에 A. 고객번호 IN (11000, 12000) 조건을 넣었다면 정답은 2 번이 되었을 것이나, ON 절에 A. 고객번호 IN (11000, 12000) 조건을 넣었기 때문에 모든 고객에 대해서 출력을 하되 JOIN 대상 데이터를 고객번호 11000과 12000으로 제한되어 1 번과 같은 결과가 출력된다.
73, @
74.
해설: 보기의 3개의 SQL은 모두 Full Outer Join과 동일한 결과를 반환한다.
해설: 주키와 외래키는 영향을 미치지 않는다.
LEFT OUTER JOIN
A
B
C
D
E
1
b
W
1
10
3
d
W
1
10
5
У
y
FULL OUTER JOIN
A
B
C
D
E
1
b
W
1
10
3
d
W
1
10
5
У
y
Z
V
42
11
22
RIGHT OUTER JOIN
A
B
C
D
E
1
b
W
1
10
3
d
W
1
10
2
4
11
V
2
22
75. LEFT JOIN E LEFT OUTER JOIN
해설:LEFT OUTER JOIN은 좌측 테이블이 기준이 되어 결과를 생성한다. 즉, TABLE A와 B가 있을 때 (TABLE 'X'가 기준이 됨). A와 B를 비교해서 B의 JOIN 칼럼에서 같은 값이 있을 때 B테이블에서 해당 데이터를 가져오고, B의 JOIN 칼럼에서 같은 값이 없는 경우에는 B 테이블에서 가져오는 칼럼들 은 NULL 값으로 채운다. 그리고, LEFT JOIN으로 OUTER 키워드를 생략해서 사용할 수 있다.

76. 2
해설: 아우터 조인에서 ON절은 조인할 대상을 결정한다. 그러나 기준 테이블은 항상 모두 표시된다. 결과 건에 대한 필터링은 WHERE절에서 수행된다.
77.1
해설: 보기는 게시판별 게시글의 개수를 조회하는 SQL이다. 이때 게시글이 존재하지 않는 게시판도 조회되어 야 한다. ORACLE에서는 OUTER JOIN 구문을 (+) 기호를 사용하여 처리할 수도 있으며, 이를 ANSI 문장으로 변경하기 위해서는 Inner쪽 테이블(게시글)에 조건절을 ON절에 함께 위치시켜야 정상적인 OUTER JOIN을 수행할 수 있다.
78.5
2번의 경우는 Outer 대상이 되는 테이블(게시판)의 조건절이 ON절에 위치하였으므로 원하는 결과가 출력되지 않는다.
해설: 조건에 맞는 Student 데이터는 다음과 같다.
st_num
st name
d_num
1001
Yoo
10
1003
Lee
20
1004
Park
10
1005
Choi
20
1006
Jeong
10
79. 4
TA
해설: EXCEPT는 차집합에 대한 연산이므로 NOT IN 또는 NOT EXISTS로 대체하여 처리가 가능하다. 2는 NOT IN을 사용하였으나, PK컬럼 A, B에 대하여 각각 NOT IN 연산을 수행하여 다른 결과가 생성된다.
80. 2
해설: 수행한 SQL은 이용된 적이 있었던 서비스를 추출하는 SQL이다.
1 이용된 적이 있었던 서비스를 추출하는 것은 동일하나 서비스와 서비스이용은 1in 관계이므로 서비스이용건수 만큼 추출되므로 전체 결과가 다르다. GROUP BY를 수행하면 동일한 결과를 출력할 수 있다.
2 전체 서비스에서 이용된 적이 있었던 서비스를 MINUS하였으므로 이용된 적이 없었던 서비스가 서브쿼리에서 추출된다. 그러므로 NOT EXISTS 구문을 적용하면 이용된 적이 있었던 서비스가 출력된다.(정답)
3 서비스를 기준으로 OUTER JOIN을 수행하였으므로, 이용된 적이 없었던 서비스만 출력된다. B. 서비스ID IS NOT NULL로 변경해야 동일한 결과가 출력된다.
4 서비스와 서비스이용 테이블의 순서를 변경하고 IN 절을 NOT IN으로 변경하면 동일한 결과를 출력할 수 있다.



81. 2
해설: SET OPERATOR : 합집합은 UNION, 교집합은 INTERSECT, 차집합은 MINUS/EXCEPT 이다.
82, 2
해설: UNION ALL을 사용하는 경우 칼럼 ALIAS는 첫번째 SQL 모듈 기준으로 표시되며, 정렬 기준은
83, 1
마지막 SQL 모듈에 표시하면 됨.
해설: 집합 연산자는 SQL에서 위에 정의된 연산자가 먼저 수행된다. 그러므로 UNION이 나중에 수행되므로 결과적으로 중복 데이터가 모두 제거되어 1과 같은 결과가 도출된다. 만일 UNION과 UNION ALL의 순서를 바꾼다면 2과 같은 결과가 도출된다.
84. 1
해설: 가 SELECT A, B, C FROM R1
UNION ALL
SELECT A, B, C FROM R2;
(중복 레코드 유지, 정렬 안함)
R(A,B,C)
A
B
C
A3
B2
C3
A1
B1
C1
A2
B1
C2
A1
B1
C1
A3
B2
C3
4 SELECT A, B, C FROM R1
UNION
SELECT A, B, C FROM R2;
(중복 레코드 제거함, 정렬 발생)
R(A,B,C)
A
B
C
A1
B1
C1
A2
B1
C2
A3
B2
C3
2001


85. 3
해설: 집합 C는 집합 A와 집합 B의 교집합이며, 데이터베이스에서 교집합 기능을 하는 집합 연산은 Intersection 이다.
86, 3
해설 : 1 1:1, 양쪽 필수 관계를 시스템적으로 보장하므로 두 엔터티간의 EXCEPT 결과는 항상 공집합이다. 2 1:1. 양쪽 필수 관계를 시스템적으로 보장하므로 UNION을 수행한 결과는 회원기본정보의 전체건수와 동일하지만, UNION ALL을 수행하였으므로 결과건수는 회원기본정보의 전체건수에 2배가 된다. 4 1:1, 양쪽 필수 관계를 시스템적으로 보장하므로 연산 수행결과는 같다.
87. C
해설: SQL의 실행결과는 다음과 같다.
C3
A
C
B
D
88. 4
해설: Oracle 계층형 질의에서 루트 노드의 LEVEL 값은 1이다.
89. 1
해설: CONNECT BY 절에 작성된 조건절은 WHERE 절에 작성된 조건절과 다르다. START WITH 절에서 필터링된 시작 데이터는 결과목록에 포함되어지며, 이후 CONNECT BY 절에 의해 필터링 된다. 그러 므로 매니저 사원번호가 NULL인 데이터는 결과목록에 포함되며, 이후 리커시브 조인에 의해 입사일자 가 필터링 된다.
90. 4
4번은 AND PRIOR 입사일자 BETWEEN '2013-01-01' AND '2013-12-31'에 대한 결과이다.
해설: 4 오라클 계층형 질의문에서 PRIOR 키워드는 SELECT, WHERE 절에서도 사용할 수 있다.



91. 1
해설: 위의 결과는 중간 레벨인 도쿄지점(120)을 시작으로 상위의 전체 노드(역방향 전개)와 하위의 전체 노드(순방향 전개)를 검색하여 매출액을 추출하는 SQL이다. 부서 테이블의 전체 데이터를 보면 LEVLE은 1~3까지 이지만 추출된 데이터의 LEVEL은 1과 2만 추출된 것으로 보면 중간 LEVEL에서 추출된 것을 짐작할 수 있다.
2 최상위 노드인 아시아지부(100)를 시작으로 하위의 모든 부서를 추출(순방향 전개)하므로 아래와 같은 결과가 추출된다.
부서코드
부서명
상위부서코드
매출액
LVL
100
아시아지부
NULL
NULL
2
110
한국지사
100
NULL
2
111
서울지점
110
1000
3
112
부산지점
110
2000
3
120
일본지사
100
NULL
2
121
도쿄지점
120
1500
3
122
오사카지점
120
1000
3
100
130
중국지사
100
NULL
2
131
베이징지점
130
1500
3
132
상하이지점
130
2000
3
3 최하위 노드인 도쿄 지점(121)에서 상위의 모든 노드(역방향 전개)를 추출하게 되므로 아래와 같은
결과가 추출된다.
부서코드
부서명
상위부서코드
매출액
LVL
100
아시아지부
NULL
NULL
3
120
일본지사
121
도쿄지점
100 120
NULL
2
тови
1500
1
92. 1
4 WHERE 절의 서브쿼리를 보면 일본 지사(120)를 시작으로 역방향 전개하여 최상위 노드를 추출하여 다시 순방향 전개를 수행하고 있다. 이렇게 되면 2 와 동일한 결과를 추출하게 된다.
해설: SELF JOIN은 하나의 테이블에서 두 개의 칼럼이 연관 관계를 가지고 있는 경우에 사용한다.
93. 3
해설: 1는 일자별매출액에 일자별 매출 테이블과 동일하게 출력된다.
2, 4는 작은 날짜쪽에 제일 큰 누적금액이 출력된다.
3은 일자별매출 테이블을 Self Join하여, A Alias 쪽에 먼저 읽혔다고 가정하면 다음처럼 데이터가
생성될 것이다.
1. A가 {2015.11.01. 1000아 일 때 B는 {2015.11.01. 1000아
2. A가 (2015.11.02., 1000} 일 때 B는 {{2015.11.01. 1000}, {2015.11.02. 1000}}
3. A가 (2015.11.03., 1000} 일 때 B는 {{2015.11.01. 1000}, {2015.11.02. 1000},
(2015.11.03. 1000}}
242 | SQL 자격검정 실전문제


94. 3
위의 Self Join은 Equi Join이 아닌 Range Join이므로 A의 레코드는 B의 레코드 수 만큼 증가하게 된다. (A*B) 그러므로 위의 3번의 경우 A는 B의 레코드 개수와 동일하게 되므로 SUM(매출금액)을 하면 3,000이 된다. 이런 식으로 A Alias의 모든 레코드 개수를 Scan하면 누적 값을 출력하게 된다.
해설: WHERE 절의 단일행 서브쿼리인 (SELECT D FROM DEPT WHERE E=Y)에 의해서 DEPT 테이블의 D 컬럼 값이 x인 행이 선택되고, D= (SELECTD FROM DEPT WHERE E=Y) 조건에 의해 EMP 테이블의 (A=1, B=a), (A=2, B=a) 인 2건이 출력된다. 출력된 결과가 모두 UNIQUE하기 때문에 DISTINCT 연산자는 결과 건수에 영향을 주지 않는다.
95. 2
해설: 다) 서브쿼리의 결과가 복수 행 결과를 반환하는 경우에는 IN, ALL, ANY 등의 복수 행 비교 연산자와 사용하여야 한다.
마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인 쿼리의 조건과 비교되는 데, SQL Server에서는 현재 지원하지 않는 기능이다.
96. 3
해설: '현재 부양하는 가족들이 없는 사원들의 이름을 구하라'를 구현하는 방법은 가족 테이블에 부양사이 없는 사원 이름을 사원 테이블에서 추출 하면 되고, SQL 문장으로 NOT EXISTS, NOT IN, LEFT OUTER JOIN을 사용하여 구현 할 수 있다.
1. NOT EXISTS
SELECT 이름
FROM 사원
WHERE NOT EXISTS (SELECT * FROM 가족 WHERE 사번= 부양사번)
2. NOT IN
SELECT 이름
FROM 사원
WHERE 사번 NOT IN (SELECT 부양사번 FROM 가족)
3. LEFT OUTER JOIN
SELECT 이름
FROM 사원 LEFT OUTER JOIN 가족 ON (사번= 부양사번) WHERE 부양사번 IS NULL
SQL 자격검정 실전문제 | 243


97. 3
해설: 위의 SQL은 약관항목 중 단 하나라도 동의를 하지 않은 회원을 구하는 SQL이다. HAVING 절에서
98. 3
동의여부가 N인 데이터가 한 건이라도 존재하는 데이터를 추출한다.
1은 회원 테이블과 동의항목 테이블의 회원번호 컬럼으로 연관 서브쿼리를 수행하여 동의여부 컬럼의 값이 N인 데이터가 한 건이라도 존재하면 회원 데이터를 출력하게 된다.
는 동의항목 테이블에서 동의여부가 N인 한 건이라도 존재하는 회원을 추출하여 회원테이블과 IN 연산을 수행한다.
3의 회원 테이블과 동의항목 테이블간에 회원번호 컬럼으로 연관 서브쿼리로 처리되어야 정상적으로 처리할 수 있다.
4는 HAVING절로 처리되던 조건을 WHERE절에 위치시켜 더 간편하게 Join으로 처리하였다. 또한 회원과 동의항목은 1:N 관계이므로 JOIN된 결과는 N건으로 발생됨에 따라 GROUP BY를 추가하여 중복을 제거 하였다.
해설: 이벤트 시작일자가 '2014.10.01. '과 같거나 큰 이벤트를 기준으로 단 한차례라도 이메일 발송이 누락된 회원을 추출하는 SQL 문장이다.
99. 2
ᄂ을 제거하고 ᄀ의 EXISTS 연산자를 IN 연산자로 변경하게 되면 회원별로 메일을 발송한 건수를 계산할 수 없으므로 원하는 결과를 추출할 수 없다.
GROUP BY 및 집계함수를 사용하지 않고 HAVING 절을 사용하였다고 하여 SQL 문장이 오류가 발생하 지는 않는다.
해설: 1 단일 행 서브쿼리의 비교연산자로는, <, <, >, >, ◇가 되어야 한다. IN, ALL 등의 비교연산자는 다중 행 서브쿼리의 비교연산자 이다.
100. 3
2 단일 행 서브쿼리의 비교연산자는 다중 행 서브쿼리의 비교연산자로 사용할 수 없지만, 반대의 경우는 가능하다.
3비 연관 서브쿼리가 주로 메인쿼리에 값을 제공하기 위한 목적으로 사용된다.
4 메인 쿼리의 결과가 서브쿼리로 제공될 수도 있고, 서브쿼리의 결과가 메인쿼리로 제공될 수도 있으므로 실행 순서는 상황에 따라 달라진다.
해설: 2014년에 입사한 사원들의 사원, 부서 정보와 부양가족수를 추출하는 SQL이다.
SELECT 절에 사용된 서브쿼리는 단일행 연관 서브쿼리로 JOIN 으로도 변경이 가능하며, FROM 절에 사용된 서브쿼리는 Inline View 또는 Dynamic View 이고, WHERE 절에 사용된 서브쿼리는
다중행 연관 서브쿼리 이다.
3번 보기의 경우 이미 FROM절에 Inline View로 사원 테이블의 입사년도 조건을 명시하였으므로 WHERE 절의 EXISTS 조건은 부서와 사원 테이블간의 JOIN 조건에 의해 결과에 어떠한 영향도 미치
지 못하므로 삭제되어도 무방하다.
O
244 | SOL 자격검정 실전문제



101, 2
해설 : 1 Inline View D 에서 평가결과 엔터티의 특정상품 및 평가항목에 대한 최종 평가회차가 아닌 전체
102. 3
데이터 중 평가회차가 가장 큰 값을 가지고 JOIN을 수행하므로 원하는 결과가 아니다.
2 연관 서브쿼리를 활용하여 특정 상품, 평가항목별로 최종 평가회차와 Join을 수행하여 원하는 결과를 출력한다.
3 특정 평가회차에 대한 결과가 아닌, 평가결과 엔터티의 평가회차, 평가등급, 평가일자 속성에 대해 서 개별 MAX 값을 구하므로 원하는 결과가 아니다.
4 특정 평가회차에 대한 결과가 아닌, 상품ID, 평가항목ID별로 개별 MAX값을 구하므로 원하는 결과 가 아니다.
해설: 1 연관 서브쿼리를 활용한 UPDATE 에서 WHERE절은 UPDATE 대상이 되는 데이터의 범위를 결정하 게 되는데, WHERE 철이 누락되어 부서의 모든 데이터가 UPDATE 대상이 되므로 부서코드 A007, A008을 제외한 모든 데이터가 NULL 값으로 변경된다.
103. 2
2 WHERE 절 조건이 부서임시가 아닌 부서 테이블이므로 A007, A008을 제외한 모든 데이터가 NULL 값으로 변경된다.
4 1과 같은 사유로 부서코드 A007, A008을 제외한 모든 데이터가 NULL 값으로 변경된다. 또한 변경일자를 하드 코딩하는 것은 답이 될 수 없다.
해설:2 뷰의 장점중 독립성은 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 된다.
104, 2
eor
해설: 조회 SQL 실행시 V_TBL은 뷰 스크립트로 치환되어 수행된다. 뷰 생성 스크립트에서 부여된 조건과 조회 SQL에서 부여된 조건 모두를 만족해야 한다.
105. 3
해설: ROLLUP은 계층 구조를 가진 SUB TOTAL을 생성하는 함수로 나열된 컬럼의 순서가 변경되면 수행 결과도 변경된다. 위의 SQL문장은 서비스ID에 대해서 가입일자별 가입건수 및 소계와 전체 가입건수 를 구하되 Outer Join을 수행하였으므로 가입내역이 없는 서비스ID(004)에 대해서도 SUB TOTAL을 출력하고 있다.
1은 서비스ID 에 대해서 가입일자별 가입건수 및 소계와 전체 가입건수를 구한 것은 맞으나 LEFT OUTER JOIN이 아닌 INNER JOIN에 대한 결과로 서비스ID 004가 출력되지 않았다.
O
SQL 자격검정 실전문제 | 245


106. 2
해설: 위의 결과 데이터는 지역에 대해서 월별 이용량 및 소계와 전체 이용량을 출력하였으므로, ROLLUP
함수를 활용할 수 있다. ROLLUP 집계 그룹 함수는 나열된 컬럼에 대해 계층 구조로 집계를 출력하는 함수로서 ROLLUP(A, B)를 수행하면 (A, B)별 집계, A별 집계와 전체 집계를 출력할 수 있다. 1번 보기의 경우 CASE 절의 GROUPING 함수의 사용이 잘못(0이 아닌 1이 되어야 함) 되었으며, 3번 보기처럼 CUBE를 사용하게 되면, 결합 가능한 모든 값에 대하여 다차원 집계를 생성하게 된다. 4번 보기처럼 GROUPING SETS를 사용하게 되면 계층구조 없이 지역에 대한 합계와 월별 합계를 각각 생성하게 된다.
107. ROLLUP
해설: 위 SQL의 결과는 (구매고객, 구매월)별, 구매고객별 그리고 전체에 대한 구매건수와 구매금액을 출력한 결과이다. 집계에 계층 구조가 있으므로 나열된 컬럼에 대해 계층 구조로 집계를 출력하는 ROLLUP을 사용하여 집계 SQL을 작성할 수 있다.
108, 4
해설: 1 CUBE, GROUPING SETS, ROLLUP 세가지 그룹 함수 모두 일반 그룹 함수로 동일한 결과를 추출할 수 있다.
2 함수의 인자로 주어진 컬럼의 순서에 따라 다른 결과를 추출하게 되는 그룹 함수는 ROLLUP 이며, 나열된 컬럼에 대해 계층 구조로 집계를 출력한다.
3 CUBE, ROLLUP, GROUPING SETS 함수들에 의해 집계된 레코드에서 집계 대상 컬럼 이외의 GROUP 대상 컬럼의 값은 NULL을 반환한다.
109. 2, 3
해설: SQL의 결과를 보면 설비ID와 에너지코드의 모든 조합에 대하여 사용량합계를 추출하고 있다. CUBE 함수는 인수로 나열된 항목의 가능한 모든 조합에 대하여 GROUPING을 수행한다. 또한 GROUPING SETS은 사용자가 원하는 다양한 조합을 인수로 사용할 수 있다. 위 문제에서 2번은 CUBE를 사용하였 으므로 CUBE절에 나열된 컬럼의 모든 조합 즉, ((설비ID), (에너지코드), (설비ID, 에너지코드))에 대해 SUB TOTAL을 만들게 된다. 3번은 GROUPING SETS를 활용하여 2번의 모든 조합을 직접 기술 하였다. 1, 4의 보기별 결과는 아래와 같다.
246 | SQL 자격검정 실전문제


110.4
해설: 집계 그룹 함수에는 ROLLUP, CUBE, GROUPING SETS 함수가 있다.
문제의 결과 데이터는 (자재번호별) SUB TOTAL과 (자재번호, 발주처별) SUB TOTAL을 출력하고 있다. GROUPING SETS 함수를 사용하여 입력된 인수들에 대한 개별 집계를 구할 수 있으며, CUBE 함수의 경우는 나열된 모든 인수의 결합 가능한 집계가 출력 된다. 그러므로 위의 문제에서는 GROUP BY GROUPING SETS(자재번호, (발주처ID, 발주일자))가 되어야 한다. 1, 2, 3의 보기별 결과는
아래와 같다.
2
1
자재번호 발주ID 발주일자
발주수량
자재번호 발주체D
발주일자 발주수량
1
20140102
100
1
1
1
20140102
100
1
1
20140103
200
1
1
20140103
200
1
1
발주일자전체
300
1
발주처전체 발주일자전체
300
1
발주처전체
20140102
100
2
1
20140102
200
1
발주처전체
20140103
200
2
2
20140102
100
1
발주처전체
발주일자전체
300
2
발주처전체 발주일자전체
300
2
1
20140102
200
3
1
20140103
100
2
1
발주일자전체
200
2
2
20140102
100
3
2
20140103
200
2
2
발주일자전체
100
3
발주처전체 발주일자전체
300
2
발주처전체
20140102
300
자재전체
1
20140102
300
2
발주처전체 발주일자전체
300
자재전체
1
20140103
300
3
1
20140103
100
자재전체
2
20140102
100
3
1
발주일자전체
100
자재전체
2
20140103
200
3
2
20140103
200
자재전체 발주처전체 발주일자전체
900
3
2
발주일자전체
200
3
발주처전체
20140103
300
3
3
발주처전체 발주일자전체
300
자재번호 발주체D
발주일자
발주수량
자재전체
1
20140102
300
1 발주처 전체 발주일자전
300
자재전체
1
20140103
300
2
발주처전체 발주일자 전체
300
자재전체
1
발주일자전체
600
3
발주처전체 발주일자전체
자재전체
2
300
20140102
100
자재전체
2
자재전체
1
발주일자전체
20140103
600
200
자재전체 2
자재전체
발주일자전체
2
발주일자전체
300
300
자재전체 발주처전체
20140102
자재전체 발주처전체
400
20140102
400
자재전체 발주처전체 20140103
자재전체 발주처전체 20140103
500
자재전체 발주처전체 발주일자전체
500
900
248 | SQL 자격검정 실전문제

------


115. 3
해설: ROW_NUMBER 함수는 ORDER BY절에 의해 정렬된 데이터에 동일 값이 존재하더라도 유일한 순위를
116. 3
부여하는 함수로서 데이터 그룹 내에 유일한 순위를 추출할 때 사용할 수 있는 함수이다. 문제의 SQL은 추천경로별(PARTITION BY 추천경로)로 추천점수가 가장 높은(ORDER BY 추천점수
DESC) 데이터를 한건씩만 출력하지만,
1은 전체 데이터를 그대로 출력하였으며
2는 전체에서 추천점수가 가장 높은 데이터 한건만을 출력하였고
4은 추천경로별로 추천점수가 가장 낮은 데이터를 각 한건씩 출력하였다.
해설: GROUP BY 절의 집합을 원본으로 하는 데이터를 WINDOW FUNCTION과 함께 사용한다면 GROUP BY 절과 함께 WINDOW FUNCTION을 사용한다고 하더라도 오류가 발생하지 않으며, 유사개수 컬럼 은 상품분류코드로 GROUPING된 집합을 원본집합으로 하여 상품분류코드별 평균상품가격을 서로 비교하여 현재 읽혀진 상품분류코드의 평균가격 대비 -10000~ +10000사이에 존재하는 상품분류코 드의 개수를 구한 것이다.
117.
해설: 안쪽 IN-LINE VIEW에 의해 아래와 같이 사원ID와 부서별 최고연봉이 결과로 생성되며
사원ID
최고연봉
001
3000
002
3000
003
4500
004
4500
005
4500
006
4500
007
4500
이를 다시 사원 테이블과 사원ID= 사원ID AND 최고연봉 = 연봉으로 JOIN을 하게 되면 부서별 최고연봉의 사원이 출력된다. 아래의 SQL로도 동일한 결과를 얻을 수 있다.
SELECT 사원ID, 사원명, 부서ID, 연봉
FROM (SELECT 사원ID, 사원명, 부서ID, 연봉
, MAX(연봉) OVER(PARTITION BY 부서ID) AS 최고연봉
FROM 사원)
WHERE 연봉 최고연봉
=
200
400



118.
해설: LAG 함수는 현재 읽혀진 데이터의 이전 값을 LEAD 함수는 이후 값을 알아내는 함수이다. 위의 SQL에서 각 레코드별 FLAG1, FLAG2의 값은 다음과 같으며,
ID
END VAL
메인 쿼리의 WHERE절이 FLAG1=0OR FLAG2= 0 이므로 1,4,5,6번째의 행이 출력된다. START_VAL
FLAG1
FLAG2
A
10
14
0
1
A
14
15
1
1
A
15
15
1
1
A
15
18
1
0
A
20
25
0
1
A
25
1
0
119.ᄀ : GRANT
ᄂ : REVOKE
해설: GRANT 명령은 DBMS 사용자에게 권한을 부여할 때 사용하며, REVOKE 명령은 부여된 권한을 회수할 때 사용한다.
120, 4
해설: 권한을 부여하는 명령어는 GRANT이며, WHERE 조건의 데이터를 찾기 위한 SELECT 권한과 데이터 변경을 위한 UPDATE 권한이 필요하다.
121. ROLE
해설: ROLE은 많은 DBMS 사용자에게 개별적으로 많은 권한을 부여하는 번거로움과 어려움을 해소하기 위해 다양한 권한을 하나의 그룹으로 묶어놓은 논리적인 권한의 그룹이다.
122, 1, 3
해설: 1. Lee: GRANT SELECT, INSERT, DELETE ON R TO Kim WITH GRANT OPTION;
→Kim에게 테이블 R에 SELECT, INSERT, DELETE 권한을 주면서, Kim 이 다른 유저에게 테이블 R에 동일한 권한을 줄 수 있다.
2. Kim: GRANT SELECT, INSERT, DELETE ON R TO Park;
→Kim이 테이블 R에 Lee에게 받은 권한을 Park에게 준다.
3. Lee: REVOKE DELETE ON R FROM Kim;
→Kim에서 테이블 R의 DELETE 권한을 취소한다.
4. Lee: REVOKE INSERT ON R FROM Kim CASCADE;
→Kim과 Park에서 INSERT 권한을 취소한다. WITH GRANT OPTION으로 Kim으로부터 받은
Park의 권한은 CASCADE 명령어로 받은 권한을 취소 할 수 있다.


123. 3
해설: PL/SQL로 작성된 Procedure, User Defined Function은 작성자의 기준으로 트랜젝션을 분할할 수
124. 3
있으며, 또한 프로시저 내에서 다른 프로시저를 호출할 경우에 호출 프로시저의 트랜젝션과는 별도로 PRAGMA AUTONOMOUS_TRANSACTION을 선언하여 자율 트랜젝션 처리를 할 수 있다.
해설: PL/SQL 에서는 동적 SQL 또는 DDL 문장을 실행할 때 EXECUTE IMMEDIATE를 사용하여야 한다. 2 번은 ROLLBACK이 가능하도록 삭제하는 것이 아니므로 옳은 답이 아니다.
125. 4
해설: Stored Module(ex: PL/SQL, LP/SQL, T-SQL)로 구현 가능한 기능은 1, 2, 3 세 가지이며, 4 데이터의 무결성과 일관성을 위해서 사용자 정의 함수를 사용하는 것은 트리거의 용도이다.
126. 3
해설: Trigger는 Procedure와 달리 Commit 및 Rollback 과 같은 TCL을 사용할 수 없다.
127. 4
해설: TRIGGER는 테이블과 뷰, 데이터베이스 작업을 대상으로 정의할 수 있으며, 전체 트랜잭션 작업에 대해 발생되는 TRIGGER와 각 행에 대해서 발생되는 TRIGGER가 있다.


제3장. SQL 최적화 기본 원리
128. CBO, 비용기반 옵티마이저, Cost Based Optimizer
129. 4
해설: 실행계획은 예상 정보이다. 실제 처리 건수는 트레이스 정보를 통해서 알 수 있다.
130,
3, 4, 2
해설: 실행계획을 읽는 순서는 위에서 아래로, 안에서 밖으로 읽는다.
131, 3
그러므로 3→4→2→6→5→ 1 순으로 수행된다.
해설 : 실행계획 즉, 실행방법이 달라진다고 해서 결과가 달라지지는 않는다.
132, 2, 4
해설: SQL 처리 흐름도는 SQL 실행계획을 시각화해서 표현한 것이다. SQL 처리 흐름도만 보고 실행 시간을 알 수는 없다.
133. 1, 4
해설: 규칙기반 옵티마이저에서 제일 낮은 우선순위는 전체 테이블 스캔이고, 제일 높은 우선순위는 ROWID 를 활용하여 테이블을 액세스하는 방법이다.
134. 2
SQL 처리 흐름도는 SQL문의 처리 절차를 시각적으로 표현한 것으로, 인덱스 스캔 및 전체 테이블 스캔 등의 액세스 기법을 표현할 수 있으며, 성능적인 측면도 표현할 수 있다.
인덱스 범위 스캔은 결과 건수만큼 반환하지만, 결과가 없으면 한 건도 반환하지 않을 수 있다.
해설: 기본 인덱스(Primary Key)는 UNIQUE & NOT NULL의 제약조건을 가진다.
135, 2, 4
보조 인덱스는 UNIQUE 인덱스가 아니라면 중복 데이터의 입력 가능하며, 자주 변경되는 속성을 인덱스로 선정할 경우 UPDATE, DELETE 성능에 좋지 않은 영향을 미치므로 인덱스 후보로 적절하지 않다.
해설: 테이블의 전체 데이터를 읽는 경우는 인덱스를 사용하지 않는 FTS를 사용한다.
인덱스는 조회만을 위한 오브젝트이며, 삽입, 삭제, 갱신의 경우 오히려 부하를 가중한다. Balance Tree는 관계형 데이터베이스에서 가장 많이 사용되는 인덱스이다.
인덱스가 존재하는 상황에서 데이터를 입력하면, 매번 인덱스 정렬이 일어나므로 데이터 마이그레이 션 같이 대량의 데이터를 삽입할 때는 모든 인덱스를 제거하고, 데이터 삽입이 끝난 후에 인덱스를 다시 생성하는 것이 좋다.



136, 2
137, 3, 4
해설: 1 인테스를 생성할 때 정렬 순서를 내림차순으로 하면 내림차순으로 정렬된다.
138.0.3
2 비용기반 옵티마이저는 SQL을 수행하는데 있어 소요되는 비용을 계산하여 실행계획을 생성하므로 인테스가 존재하더라도 전체 테이블 스캔이 유리하다고 판단할 수도 있다.
5 규칙기반 옵티마이저의 규칙에 따라 적절한 인덱스가 존재하면 전체 테이블 스캔보다는 항상 인덱
스를 사용하려고 한다.
4 인덱스 범위 스캔은 결과 건수만큼 반환하지만, 결과가 없으면 한 건도 반환하지 않을 수 있다.
해설: 2 REGIST_DATE 조건이 범위 조건이고 DEPTNO 컬럼이 후행 컬럼이므로 효율적인 조건 검색을 할 수 없다.
139, 4
4 b*tree index는 일반적으로 테이블 내의 데이터 중 10%이하의 데이터를 검색할 때 유리하다.
해설: 인덱스를 스캔하여 테이블로 데이터를 찾아가는 방식이 랜덤 엑세스인데, 이러한 랜덤 엑세스의 부하가 크기 때문에 매우 많은 양의 데이터를 읽을 경우에는 인덱스 스캔보다 테이블 전체 스캔이 유리할 수도 있다.
140, 2
해설: 대량의 데이터를 조회하는 경우 인덱스를 이용한 조회보다는 테이블 전체 스캔 방식으로 조회 하는것이 더 빠를 수도 있으며, 인덱스를 구성하는 컬럼들의 순서는 데이터 조회 시 성능적인 관점에서 매우 중요한 역할을 한다. 또한 인덱스를 구성하는 컬럼 이외의 데이터가 UPDATE될 때는 인덱스로 인한 부하가 발생하지 않는다.
141, 2
해설: NL Join은 데이터를 집계하는 업무 보다는 OLTP의 목록 처리 업무에 많이 사용된다. DW 등의 데이터 집계 업무에서 많이 사용되는 Join 기법은 Hash Join 또는 Sort Merge Join 이다.
142, (3)
해설: 소트 머지 조인(Sort Merge Join)을 수행하기에 두 테이블이 너무 커서 소트(Sort) 부하가 심할 때는
143. 4
Hash Join이 유용하다.
해설: EXISTS 절은 실행계획상에 주로 SEMI JOIN으로 나타난다. NESTED LOOP, HASH, SORT MERGE의 SEMI JOIN이 모두 나타날 수 있지만, 위의 인덱스 정보와 SQL을 볼 때 HASH SEMI JOIN 보다는
NESTED LOOP SEMI JOIN 이 나타날 가능성이 가장 크다.


144. 4
해설: EQUI JOIN에서만 동작하는 Join 방식은 Hash Join 이다. Sort Merge Join은 Non-EQUI JOIN 조건에서도 사용할 수 있다.
145, 4
해설: 유니크 인덱스를 활용하여 수행시간이 적게 걸리는 소량 테이블을 조인할 때는 NL 조인이 적합하다.
146.1
해설: 2 Sort Merge Join은 비 동등 Join(Not Equi Join)에서도 사용할 수 있다.
3 Hash Join은 행의 수가 작은 테이블을 선행 테이블로 선택하는 것이 유리하다.
4 Hash Join은 Sort Merge Join보다 일반적으로 더 우수한 성능을 보이지만, Join 대상 테이블이
Join Key 컬럼으로 정렬되어 있을 때는 Sort Merge Join이 더 우수한 성능을 낼 수도 있다.

